//--------GUIA 1 ----
//1) Escribir un programa que reemplace una bolita de color Roja con otra de color Verde 
//en la celda  actual. Pruebe su programa en la computadora, modificando el tablero 
//inicial de forma que el programa funcione satisfactoriamente
procedure ReemplazarBolita (){
 Poner(Verde)
 Sacar(Rojo)
}
//2)Escribir un programa que mueva una bolita de color Negro de la celda actual a la celda vecina 

//al Este, dejando el cabezal en la celda lindante al Este
procedure MoverBolitaAlEste (){
    Sacar(Negro)
    Mover(Este)
    Poner(Negro)
}
//3)Escribir un programa que ponga una bolita de color Azul en la celda vecina al Norte de la actual .
procedure PonerAlNorte(){
    Mover(Norte)
    Poner(Azul)
    Mover(Sur)
}
//4)Cuadrados verdes --> Escribir los siguientes programas:
//a. uno que ponga un cuadrado de tamaño 3 con bolitas de color verde, con centro en la celda.
//inicial (dejando el cabezal en dicha celda al finalizar)
//i. ¿Qué ocurre si el tablero ya tenı́a bolitas verdes? ¿Es esto un problema, o el efecto
//obtenido es acorde al propósito?
//ii. ¿Qué ocurriría si desde la celda inicial no hay espacio para colocar las bolitas
//necesarias para que se cumpla el propósito?
//b. uno que saque un cuadrado de tamaño 3 con bolitas de color verde (saca una bolita de cada
//celda), siendo la celda inicial el centro del cuadrado, dejando el cabezal en dicha celda al finalizar.
//i. ¿Qué sucede si no hay al menos una bolita verde en cada una de las celdas necesarias?
//¿Y si el tablero no tiene el tamaño adecuado?
procedure DibujarCuadradoDeTresVerde(){
    IniciarDibujo()
    DibujarColumnaDeTresVerde()
    PasarAProximaColumna()
    DibujarColumnaDeTresVerde()
    PasarAProximaColumna()
    DibujarColumnaDeTresVerde()
    FinalizarDibujo()
}
procedure IniciarDibujo(){
    Mover(Oeste)
}
procedure DibujarColumnaDeTresVerde(){
    /* Proposito:  dibujar un cuadrado de color verde de tres celdas de largo a partir 
                   del centro del mismo y finaliza en mismo lugar de inicio.
       Precondicion: debe existir al menos una direccion en cada direccion.
    */
    Poner(Verde)
    Mover(Norte)
    Poner(Verde)
    Mover(Sur)
    Mover(Sur)
    Poner(Verde)
    Mover(Norte)
}
procedure PasarAProximaColumna(){
    Mover(Este)
}
procedure FinalizarDibujo(){
    Mover(Oeste)
}
//9)a. Escribir un procedimiento DibujarRectánguloRojoYNegroDe5x3() cuyo contrato es el siguiente:
//PROPÓSITO: Poner un rectángulo sólido de 5 celdas de ancho y 3
//celdas de alto. Desde la celda actual hacia el Este y hacia el Norte.
//PRECONDICIONES:
//* Hay al menos 4 celdas al Este y 2 celdas al Norte de la celda
//actual.
//* Las celdas contenidas en el rectángulo de 5x3 desde la celda
//actual hacia el Este y hacia el Norte están vacias.
//------------TOP DOWN---------------------------------------------------------------------------------
procedure DibujarRectánguloRojoYNegroDe5x3(){
      /*PROPÓSITO: Poner un rectángulo sólido de 5 celdas de ancho y 3
                    celdas de alto. Desde la celda actual hacia el Este y hacia el Norte.
        PRECONDICIONES:
                * Hay al menos 4 celdas al Este y 2 celdas al Norte de la celda actual.
                * Las celdas contenidas en el rectángulo de 5x3 desde la celda actual hacia el Este 
                   y hacia el Norte están vacias.*/
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        PasarAProximaLínea()
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        PasarAProximaLínea()
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        VolverAlInicioDelRectángulo()
} 
procedure PasarAProximaLínea(){
     /*PROPÓSITO: Pasar a la proxima línea a dibujar .
       PRECONDICIONES: debe existir al menos una celda al Norte.*/
       Mover(Norte)
}
procedure  DibujarLíneaRojaYNegraDeTamaño5HaciaElEste(){
     /*PROPÓSITO: Poner una línea sólida de cinco celdas de ancho hacia el Este.
         PRECONDICIONES: Hay al menos cuatro celdas al Este de la celda actual y 
                         las celdas contenidas en la misma línea están vacias.*/
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        Mover4VecesAlOeste()
}
procedure VolverAlInicioDelRectángulo(){
    /*PROPÓSITO: volver a la celda inicial del rectángulo.
      PRECONDICIONES: debe existir al menos dos celdas al Sur.*/
      Mover(Sur)
      Mover(Sur)
}
procedure PonerUnaNegraYUnaRoja(){
       /*PROPÓSITO: Poner una bolita Roja y Negra en la celda actual.
         PRECONDICIONES: la celda actual debe estar vacía*/ 
         Poner(Negro)
         Poner(Rojo)
}
procedure Mover4VecesAlOeste(){
     Mover(Oeste)
     Mover(Oeste) 
     Mover(Oeste)
     Mover(Oeste)
}
procedure PasarAProximaCelda(){
      Mover(Este)
}
//10) Escribir un programa que ponga un “arco iris”, poniendo una bolita Azul en 
//la celda actual,una Negra en la celda siguiente al Este, una Roja en la siguiente 
//al Este, y una Verde en la siguiente al Este, dejando el cabezal en la celda inicial.
procedure PonerArcoIris(){
     /* Proposito:  poner un arco iris en direccion Este.
       Precondicion: debe existir al menos tres celdas lindantes al Este.*/
       Poner(Azul)
       Mover(Este)
       Poner(Negro)
       Mover(Este)
       Poner(Rojo)
       Mover(Este)
       Poner(Verde)
       IrAlBorde(Oeste)
}
//----BIBLITECA------------------------------------------------
// a.
procedure  PonerUnaDeCada(){   
    /*PROPÓSITO: Poner en la celda actual una bolita Roja , 
                 Negra, Verde, Azul.
         PRECONDICIONES: la celda actual debe estar vacía.
    */
         Poner(Rojo)
         Poner(Negro)
         Poner(Verde)
         Poner(Azul)
}
//-------------------------------------------------------------
// b.
procedure Mover3VecesAlOeste(){
    /*PROPÓSITO:Mover el cabezal al Oeste .
      PRECONDICIONES: debe existir al menos dos celdas 
                      lindantes al Oeste.
    */
      Mover(Oeste)
      Mover(Oeste)
      Mover(Oeste)
      }
// c.
 procedure DibujarLíneaMulticolorDeLargo4() {
    /*PROPÓSITO: Dibujar una línea multicolor .
      PRECONDICIONES: debe existir al menos tres celdas vacias 
                      lindantes al Este.
    */ 
      PonerUnaDeCada()
      PasarAProximaCelda()   // realizado en punto 2.
      PonerUnaDeCada()
      PasarAProximaCelda()
      PonerUnaDeCada()
      PasarAProximaCelda()
      PonerUnaDeCada()
      Mover3VecesAlOeste()
 } 
 procedure VolverAlinicioDelCuadrado(){
    /*PROPÓSITO: Vuelve al inicio del cuadrado.
      PRECONDICIONES: debe existir al menos 3 celdas lindasnte 
                      al sur.
    */
     Mover(Sur)
     Mover(Sur)
     Mover(Sur)
 }

 procedure DibujarCuadradoMulticolorDeLado4(){
     /*PROPÓSITO: Dibuja un cuadrado multicolor .
      PRECONDICIONES: debe existir al menos 4 celdas vacias lindantes al Norte y al Este.*/
     DibujarLíneaMulticolorDeLargo4()
     PasarAProximaLínea()         // realizado en punto2.
     DibujarLíneaMulticolorDeLargo4()
     PasarAProximaLínea()
     DibujarLíneaMulticolorDeLargo4()
     PasarAProximaLínea()
     DibujarLíneaMulticolorDeLargo4()
     VolverAlinicioDelCuadrado()
}
//11) Escriba un programa que saque del tablero un cuadrado multicolor de dos celdas de lado, 
//donde la celda actual representa el vértice inferior izquierdo del mismo.
//Recuerde escribir primero el contrato del programa, y luego el código.
//Considere las siguientes preguntas como guía para escribir su programa:
//a. ¿Qué hace el programa? (Determina el propósito del programa)
//b. ¿Cuándo funciona tal cual se espera? (Determina la precondición del programa)
//c. ¿Cómo lo hace? (Determina el código del programa)
procedure SacarCuadradoDeDosMulticolor(){
    /* Proposito: sacar un cuadrado multicolor de dos celdas de largo.
       Precondicion: debe existir al menos una celda al Norte y Este con al menos una
                     bolita de cada color en cada celda.*/
    SacarCeldaMulticolor()
    PasarAproximaCelda()
    SacarCeldaMulticolor()
    PasarASiguienteCelda()   
    SacarCeldaMulticolor()
    PasarAUltimaCelda()
    SacarCeldaMulticolor()
    VolverAlInicio()
}
procedure SacarCeldaMulticolor(){
      /* Proposito: sacar una bolita de cada color de la celda actual.
         Precondicion:debe existir al menos una bolita de cada color.*/
         Sacar(Verde)
         Sacar(Rojo)
         Sacar(Negro)
         Sacar(Azul)
}
procedure PasarAproximaCelda(){
    /* Proposito: pasar a la proxima celda.
       Precondicion: debe existir al menos una celda al Norte*/
       Mover(Norte)
}
procedure PasarASiguienteCelda(){
    /* Proposito: pasar a la proxima celda.
       Precondicion: debe existir al menos una celda al Este*/
       Mover(Este)
}
procedure PasarAUltimaCelda(){
    /* Proposito: pasar a la proxima celda.
       Precondicion: debe existir al menos una celda al Sur.*/
       Mover(Sur)
}
procedure VolverAlInicio(){
    /* Proposito: volver a la celda inicial a partir de lacelda actual.
       Precondicion: debe existir al menos una celda al Oeste*/
       Mover(Oeste)
}

program{
    PonerArcoIris()
}
//1)Escribir un programa que ponga sus iniciales en el tablero usando bolitas color Verde para los nombres
//y color Rojo para el apellido, dejando el cabezal en la celda inicial. Para escribir sus iniciales, se debe
//definir cómo se verán las letras en el tablero.
procedure PonerInicialesDemiNombre(){
    /*Proposito: poner iniciales de nombre en color verde e inicial de apellido en color rojo, en tamaño de 3 celdas.
      Precondicion: tener al menos 2 celdas al norte y 10 al este.
      */
      PonerMVerde()
      PasarASiguienteInicial()
      PonerFVerde()
      PasarApellido()
      PasarASiguienteInicial()
      PonerFRojo()
      VolverAlInicio()
}
procedure PonerMVerde() {
    /*Proposito: poner una letra M verde.
      Precondicion: tener al menos 2 celdas al norte y al este.*/
      PonerColumna3Verde()
      PonerUnionMVerde()
      PonerColumna3Verde()
       }
procedure PonerColumna3Verde(){
    /*Proposito: poner una columna de 3 celdas en color verde.
      Precondicion: tener al menos 2 celdas al norte. */
     Poner(Verde)
     Mover(Norte)
     Poner(Verde)
     Mover(Norte)
     Poner(Verde)
     Mover(Sur)
     Mover(Sur)
}
procedure PonerUnionMVerde(){
    /*Proposito: poner la union central que forma la letra M en color verde, el cabezal finaliza en la prox columna.
      Precondicion: tener al 2 una celda al este y una al norte.*/
      Mover(Este)
      Mover(Norte)
      Poner(Verde)
      Mover(Sur)
      Mover(Este)
}
procedure PasarASiguienteInicial(){
    /* Proposito: pone el cabezal en la siguiente inicial.
       Precondicion: Tener al menos una siguiente inicial.*/
        Mover(Este)
        Mover(Este)
}
procedure PonerFVerde(){
    /* Proposito: pone un letra F verde.
       Precondicion: tener al menos 2 celdas al este y 2 celdas al norte.*/
        PonerColumna3Verde()
        PonerLinea2Verde()
        PonerPuntoVerde()
}
procedure PonerLinea2Verde(){
    /* Proposito: poner una linea verde de 2 celdas.
       Precondicion: Tener al menos dos celda al este y dos al norte.*/
        Mover(Este)
        Mover(Norte)
        Mover(Norte)
        Poner(Verde)
        Mover(Este)
        Poner(Verde)
}
procedure PonerPuntoVerde(){
    /* Proposito: poner un punto verde.
       Precondicion: tener al menos una celda al sur y una al oeste. */
        Mover(Sur)
        Mover(Oeste)
        Poner(Verde)
}
procedure PasarApellido(){
    /* Proposito: pasar el cabezal a la inicial del apellido.
       Precondicion: tener al menos 2 celdas al este y una al sur.*/
        Mover(Este)
        Mover(Este)
        Mover(Sur)
}
procedure PonerFRojo(){
    /*Proposito: poner una F roja.
      Precondicion: tener al menos 2 celdas al este y 2 celdas al norte.*/
      PonerColumna3Rojo()
      PonerLinea2Rojo()
      PonerPuntoRojo()
}
procedure PonerColumna3Rojo(){
    /*Proposito: poner una columna de 3 celdas roja.
      Precondicion: tener al menos 2 celdas al norte.*/
      Poner(Rojo)
      Mover(Norte)
      Poner(Rojo)
      Mover(Norte)
      Poner(Rojo)
      Mover(Sur)
      Mover(Sur)
}
procedure PonerLinea2Rojo(){
    /* Proposito: poner una linea roja de 2 celdas.
       Precondicion: tener al menos 2 celdas al este y 2 celdas al norte. */
       Mover(Este)
       Mover(Este)
       Mover(Norte)
       Mover(Norte)
       Poner(Rojo)
       Mover(Oeste)
       Poner(Rojo)
}
procedure PonerPuntoRojo(){
    /*Proposito: poner un punto rojo.
      Precondicion: tener al menos una celda al sur.*/
    Mover(Sur)
    Poner(Rojo)
}
procedure VolverAlInicio(){
    /*Proposito: poner el inicial en el inicio del tablero.
      Precondicion: tener al menos 8 celdas al oeste y una sur. */
    Mover(Sur)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
}
---GUIA 2 ----------------------------------------------------------------------------------
//1)Consztruir un procedimiento PonerGuardaDe5Azulejos(), que arme una “guarda” de 5 azulejos
//(como las que decoran las paredes). Cada azulejo está conformado por 1 bolita verde, 5 negras y 9
//rojas.
procedure PonerGuardaDe5Azulejos(){
    /*PROPÓSITO: poner una guarda decorativa de cinco azulejos de largo.
      PRECONDICIONES: debe existir al menos cuatro celdas vacias lindantes al Este.*/
      PonerAzulejo()
      PasarAProximaCelda() //  realizado en el punto 2.
      PonerAzulejo()
      PasarAProximaCelda()
      PonerAzulejo()
      PasarAProximaCelda()
      PonerAzulejo()
      PasarAProximaCelda()
      PonerAzulejo()
}
procedure PonerAzulejo(){
    /*PROPÓSITO: poner un azulejo decorativo en la celda actual.
      PRECONDICIONES: la celda actual debe estar vacía.*/
      PonerDiseñoRojo()
      PonerDiseñoNegro()
      PonerDiseñoVerde()
}
procedure PonerDiseñoVerde(){
    /*PROPÓSITO: poner en la celda actual el diseño verde del azulejo.
      PRECONDICIONES: la celda actual debe estar vacía.*/
      Poner(Verde)
}
procedure PonerDiseñoNegro(){
    /*PROPÓSITO: poner en la celda actual el diseño Negro del azulejo.
      PRECONDICION: no debe existir bolitas Negras.*/
      Poner(Negro)
      Poner(Negro)
      Poner(Negro)
      Poner(Negro)
      Poner(Negro)
}
procedure PonerDiseñoRojo(){
    /*PROPÓSITO: poner en la celda actual el diseño Rojo del azulejo.
      PRECONDICIONES: no debe existir bolitas Rojas .*/
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
}
//5)Utilizando bolitas pueden representarse diversos elementos; un ejemplo de esto es la posibilidad de
//representar una fecha. Una fecha que los argentinos deberíamos recordar, para no repetirla jamás, es
//el 24 de marzo de 1976, hoy constituido como Día de la Memoria por la Verdad y la Justicia en Argentina.
//Hacer un procedimiento RegistrarElDíaDeLaMemoria() que
//● en la celda actual, ponga 24 bolitas Azules, que representan el día
//● en la celda lindante al Este de la actual, ponga 3 bolitas Rojas, que representan el mes, y
//● en la celda lindante al Este de la anterior, ponga 1976 bolitas Verdes, representando el año
//3)Hacer un procedimiento PonerGuardaEnL(), que arme una guarda en L de 2x2,
//dejando el cabezal en la posición inicial.
 procedure PonerGuardaEnL(){
     /*PROPÓSITO: poner una guarda decorativa en forma de L.
       PRECONDICIONES: debe existir al menos dos celdas vacias al Norte y al Este.*/
       PonerLadoVerticalDeGuarda()
       PosicionarLadoHorizontalDeGuarda()
       PonerLadoHorizontalDeGuarda()
 }
 procedure PonerLadoVerticalDeGuarda(){
     /*PROPÓSITO: poner en forma vertical una guarda decorativa a partir de la celda actual.
       PRECONDICIONES: debe existir al menos dos celdas vacias lindantes al Norte.*/
       PonerAzulejo()
       PasarAProximoAzulejo()
       PonerAzulejo()
       PasarAProximoAzulejo()
       PonerAzulejo()
       VolverAlLadoVertiocal()
 }
 procedure PosicionarLadoHorizontalDeGuarda(){
     /*PROPÓSITO: posicionar para poner el lado horizpontal de la guarda.
       PRECONDICIONES: debe existir una celd vacía lindate al Este.*/
       Mover(Este)
 }
 procedure PasarAProximoAzulejo(){
     /*PROPÓSITO: pasar al próximo azulejo.
       PRECONDICIONES: debe existir al menos una celda lindante al Norte.*/
       Mover(Norte)
 }
 procedure VolverAlLadoVertiocal(){
     /*PROPÓSITO: volver al inicio del lado vertical del azulejo a partir de la celda actual.
       PRECONDICIONES: debe existir al menos dos celdas al Sur.*/
       Mover(Sur)
       Mover(Sur)
 }
 procedure PonerLadoHorizontalDeGuarda(){
    /* PROPÓSITO: poner en forma horizontal una guarda decorativa a partir de la celda actual.
       PRECONDICIONES:debe existir al menos una celda lindante al Este.*/
       PonerAzulejo()
       PasarAProximaCelda()  //realizado en ejercicio2-
       PonerAzulejo()
       Mover2VecesAlOeste()  
 }
 procedure Mover2VecesAlOeste(){
      /*PROPÓSITO:Mover el cabezal al Oeste .
      PRECONDICIONES: debe existir al menos dos celdas lindantes al Oeste.*/
      Mover(Oeste)
      Mover(Oeste)
 }
/*4) Escribir un programa para cultivar tomates en todo un lote de 5x3. Los procedimientos
primitivos en este ejercicio son Sembrar y Regar con los siguientes contratos:  */
procedure Sembrar()
/* PROPÓSITO: Sembrar una semilla en la celda actual
PRECONDICIONES:
* la celda actual está vacía
*/
procedure Regar()
/* PROPÓSITO: Regar la celda actual
PRECONDICIONES:
* hay una semilla sembrada en la celda actual
*/
procedure CultivarTomatesEnLoteDe5X3 (){
    /* PROPÓSITO: cutivar tomates en  un lote.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y dos al Norte vacias.
       OBSERVACION: Llamamos a una parcela auna celda.
    */
    CultivarPrimerFilaDeTomate()
    PasarAProximaFila()
    CultivarSegundaFilaDeTomate()
    PasarAProximaFila()
    CultivarTercerFilaDeTomate()
}
procedure PasarAProximaFila(){
    /* PROPÓSITO: pasa a la proxima fila de parcelas.
       PRECONDICIONES:debe existir  al menos una parcela vacia  lindante al  Norte.
       OBSERVACION: Llamamos a una parcela a una celda.
    */
    Mover(Norte)
}
procedure CultivarPimerFilaDeTomate(){
    /* PROPÓSITO: cutivar tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    SembrarFila()
    RegarFila()
}
procedure CultivarSegundaFilaDeTomate(){
    /* PROPÓSITO: cutivar tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    SembrarFila()
    RegarFila()
}
procedure CultivarTercerFilaDeTomate(){
    /* PROPÓSITO: cutivar tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    SembrarFila()
    RegarFila()
}
procedure SembrarFila(){
    /* PROPÓSITO: siembra  tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    Sembrar() Mover(Este) Sembrar() Mover(Este) 
    Sembrar() Mover(Este) Sembrar() Mover(Este) 
    Sembrar()
    IrAlBorde(Oeste)
}
procedure RegarFila(){
    /* PROPÓSITO: riega una fila de tomates recien sembrados.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben tener un tomate sembrado.
       OBSERVACION: llamamos parcela a una celda.
    */
    Regar() Mover(Este) Regar() Mover(Este)
    Regar() Mover(Este) Regar() Mover(Este)
    Regar() 
    IrAlBorde(Oeste)
}
/*6)Escribir un programa que construya una pared de ladrillos de ocho ladrillos de alto por
cuatro ladrillos de ancho, para lo cual se provee una guía al final del enunciado. Una
pared de ladrillos está compuesta por hileras de ladrillos pegadas entre sí con cemento.
Las hileras se alternan entre hileras con 4 ladrillos enteros (hilera inferior), e hileras con
3 ladrillos enteros y 2 medios ladrillos en los bordes (hilera superior). Cada fila del
tablero puede llevar 2 hileras, una hilera inferior en la parte inferior de las celdas, y una
hilera superior arriba de esa. El tablero inicial estará vacío.

Los procedimientos primitivos en este ejercicio son PonerCemento, PonerLadrillo,
PonerMedioLadrilloEnElBordeOeste y PonerMedioLadrilloEnElBordeEste
con los siguientes contratos:*/
procedure PonerCemento()
/* PROPÓSITO: Poner cemento en la celda actual
PRECONDICIONES:
* o bien la celda actual está vacía,
* o bien la celda actual tiene un ladrillo entero en la
Parte inferior, sin cemento sobre él
*/
procedure PonerLadrillo()
/* PROPÓSITO: Poner un ladrillo en la celda actual
PRECONDICIONES:
* si no hay ladrillos en la celda actual, hay
cemento en la misma
* si hay un ladrillo entero en la celda actual, hay
cemento sobre el mismo, y existe una celda al Oeste
que ya contiene un ladrillo entero y medio ladrillo del
lado izquierdo
*/
procedure PonerMedioLadrilloEnElBordeOeste()
/* PROPÓSITO: Poner medio ladrillo en la celda actual
PRECONDICIONES:
* la celda actual está en el borde Oeste
* hay un ladrillo entero en la parte inferior de la
celda actual, y cemento sobre él
*/
procedure PonerMedioLadrilloEnElBordeEste()
/* PROPÓSITO: Poner medio ladrillo en la celda actual
PRECONDICIONES:
* la celda actual esté en el borde Este
* hay un ladrillo entero en la parte inferior de la
celda actual, cemento sobre él, y medio ladrillo del lado
izquierdo de la celda
*/
/*No olvidar seguir la metodología de trabajo top-down, y utilizar nombres adecuados para
las subtareas. Como guía para la utilización de tal metodología, se proponen los
siguientes ítems. Una ayuda: para poder utilizar adecuadamente los procedimientos
primitivos, deben analizarse con cuidado las precondiciones y determinar qué tareas
deben realizarse primero.
a.
Para construir una pared, deben construirse repetidamente hileras de ladrillos en
la parte inferior de cada celda de una fila, e hileras en la parte superior, teniendo
en cuenta las precondiciones de cada una de las operaciones.
b.
Los ladrillos de la hilera superior se colocan con un corrimiento respecto de los
de la hilera inferior. Observar con cuidado la precondición del procedimiento de
colocar ladrillos enteros y probar su funcionamiento en una hilera superior, luego
de cumplir sus precondiciones.
*/
procedure ConstruirPared(){ // IMPORT--<<< La construccion se hace hacia el Este por las precondiciones dadas.
    /*PROPÓSITO: contruir una pared de ladrillos a ´partir de la celda actual.
      PRECONDICIONES: debe existir al menor tres celdas vacias al Este y al Norte.
    */
    ConstruirHilera()
    ConstruirOtraHilera()
    PasarAProxiamHilera()
    ConstruirHilera()
    ConstruirOtraHilera()
    PasarAProxiamHilera()
    ConstruirHilera()
    ConstruirOtraHilera()
    PasarAProxiamHilera() 
    ConstruirHilera()
    ConstruirOtraHilera()
    IrAlBorde(Sur)
}
procedure PasarAProxiamHilera(){
    /*PROPÓSITO: pasa a la proxima hilera a construir.  .
      PRECONDICIONES: debe existir una celda lindante al lado Este.
    */
    Mover(Norte)
}

procedure ConstruirHilera(){
    /*PROPÓSITO:construir una hilera de ladrillos a partir de la celda actual .
      PRECONDICIONES: debe existir al menos tres celdas vacias y lindas al Norte.
    */
    PonerLacrillosYCemento()
    PasarAlProximoLadrillo()
    PonerLacrillosYCemento()
    PasarAlProximoLadrillo()
    PonerLacrillosYCemento()
    PasarAlProximoLadrillo()
    PonerLacrillosYCemento()
    IrAlBorde(Oeste)
}
procedure ConstruirOtraHilera(){  // IMPORT--<<aqui tiene que moverse al Este para poner el ladrillo entero.
    /*PROPÓSITO:construir otra  hilera de ladrillos posicionados de otra forma a partir de la celda actual .
      PRECONDICIONES: debe existir al menos tres celdas vacias y lindas al Norte.
    */
    PonerMedioLadrilloEnElBordeOeste()
    PasarAlProximoLadrillo()
    PonerLadrillo()
    PasarAlProximoLadrillo()
    PonerLadrillo()
    PasarAlProximoLadrillo()
    PonerLadrillo()
    PonerMedioLadrilloEnElBordeEste()
    IrAlBorde(Oeste)
}
procedure PonerLacrillosYCemento(){
    /*PROPÓSITO: Pone cemento y ladrillos en la celda actual .
      PRECONDICIONES: la celda actual debe estar vacia.
    */
    PonerCemento()
    PonerLadrillo()
    PonerCemento()  
}
procedure PasarAlProximoLadrillo(){
    /*PROPÓSITO: pasa al proximo ladrillo a partir de la celda actual .
      PRECONDICIONES: debe esxistir al menos una celda lindante al Norte.
    */
    Mover(Este)
}
//8) El bosque, parte 1
//En este ejercicio, se usará el tablero para representar un bosque. Cada celda representa a una parcela.
//Cada bolita verde representa un árbol. Cada bolita roja representa una semilla. Una bolita negra
//representa una bomba. Una bolita azul representa una unidad de nutrientes.
//Escribir los siguientes procedimientos de representación, que hacen lo que su nombre indica. Todos
//trabajan siempre sobre la celda actual.
//a
procedure PonerUnaSemilla(){
    /*PROPÓSITO: poner una semilla en la parcela actual.
      PRECONDICIONES:en  la parcela actual no debe existir semillas.*/
      Poner(Rojo)
}
//b
procedure PonerUnÁrbol(){
     /*PROPÓSITO: poner un árbol en la parcela actual.
      PRECONDICIONES: en  la parcela actual no debe existir arbol.*/
      Poner(Verde)
}
//c
procedure PonerUnaBomba(){
     /*PROPÓSITO: poner una bomba en la parcela actual.
      PRECONDICIONES:en  la parcela actual no debe existir bombas.*/
      Poner(Negro)
}
//d
procedure PonerUnNutriente(){
    /*PROPÓSITO: poner un nutriente en la parcela actual.
      PRECONDICIONES: en  la parcela actual no debe existir nutriente.*/
    Poner(Azul)
}
//e
procedure SacarUnaSemilla(){
    /*PROPÓSITO: sacar un nutriente de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos una semilla.*/
      Sacar(Rojo)
}
//f
procedure SacarUnÁrbol(){
    /*PROPÓSITO: sacar un árbol de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos una  arbol.*/
      Sacar(Verde)
}
//g
procedure SacarUnaBomba(){
    /*PROPÓSITO: sacar una bomba de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos una  bomba.*/
      Sacar(Negro)
}
//h
procedure SacarUnNutriente(){
     /*PROPÓSITO: sacar un nutriente de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos un nutriente.*/
      Sacar(Azul)
}
//9)Dibujar un reloj analógico de agujas en un tablero cuadriculado puede ser un desafío. Una
//simplificación posible sería representar solamente algunos de los números que aparecen en el mismo:
//el 12 arriba, el 3 a la derecha, el 9 a la izquierda y el 6 abajo.
//Construir un procedimiento DibujarRelojAnalógicoSimplificado(), que ponga los números del reloj tal como se indicó, 
//alrededor del casillero actual. El tamaño del reloj será de 2 celdas de “radio” (suponiendo que miramos al reloj como un círculo)
procedure DibujarRelojAnalógicoSimplificado(){
    /* Propósito: dibujar un reloj analógico a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes en sus cuatro direcciónes. */
    Dibujar12()
    Dibujar03()
    Dibujar06()
    Dibujar09()
}
procedure  Dibujar03(){
     /* Propósito: dibujar las  03 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Este. */
    MoverseAlEsteDelReloj()
    Poner3BolitasRojas()
    MoverseAlOesteDelReloj()
}
procedure Dibujar06(){
     /* Propósito: dibujar las  06 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Sur. */
    MoverseAlSurDelReloj()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    MoverseAlNorteDelReloj()
}
procedure Dibujar09(){
     /* Propósito: dibujar las  09 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Oeste. */
    MoverseAlOesteDelReloj()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    MoverseAlEsteDelReloj()
}
procedure Dibujar12(){
     /* Propósito: dibujar las  12 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Norte. */
    MoverseAlNorteDelReloj()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    MoverseAlSurDelReloj()
}
procedure  MoverseAlSurDelReloj(){
     /* Propósito: mueve al Sur del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Sur.*/
    Mover(Sur)
    Mover(Sur)
}
procedure MoverseAlNorteDelReloj(){
     /* Propósito: mueve al Norte del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Norte.*/
    Mover(Norte)    
    Mover(Norte)
}
procedure  MoverseAlOesteDelReloj(){
     /* Propósito: mueve al Oeste del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Oeste.*/
    Mover(Oeste)    
    Mover(Oeste)
}
procedure MoverseAlEsteDelReloj(){
      /* Propósito: mueve al Este del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Este.*/
    Mover(Este)
    Mover(Este)
}
procedure Poner3BolitasRojas(){
     /* Propósito: pone tres bolitas Rojas en la celda actual.
        Precondición: la celda actual debe estar vacía. */
    Poner(Rojo)  
    Poner(Rojo)
    Poner(Rojo) 
}
//10) Comenzar por redactar el contrato y la precondición correspondientes.
//a. Luego aplicar la técnica de división en subtareas expresadas con procedimientos. Dado que no
//se trata de hacer el código de nuevo, se propone identificar partes de código que se repitan,
//darles un buen nombre y extraer esa parte de la estrategia en procedimientos auxiliares. Por
//supuesto, cada procedimiento auxiliar debe tener un nombre adecuado, y debe documentarse
//su propósito y precondición.
//b. ¿Puede apreciar las ventajas de contar con el contrato y de expresar la estrategia como parte
//del código en forma de procedimientos? Hay más de una forma de dividir en subtareas.
//Comparar la solución propuesta con la de otros compañeros, y discutir las ventajas y
//desventajas de la dada con las que resulten diferentes.
procedure  ConstruirEscaleraAzulDe4Escalones(){
  /*Propósito: contruye una escalera de 4 escalones y deja el cabezal al final de la misma.
    Precondición: debe existie al menos 4 celdas vacias o sin bolitas Azules??? lindantes al Este y 
                  3 celdas vacias o sin bolitas azules???al Norte
  */
  ConstruirEscalonYPasarAlProximo()
  ConstruirEscalonYPasarAlProximo()
  ConstruirEscalonYPasarAlProximo()
  ConstruirEscalon()
}
procedure ConstruirEscalonYPasarAlProximo(){
  /*Propósito: contruye un escalon y deja el cabezal listo para construir el proximo escalon.
    Precondición: debe existie al menos una celda vacia o sin bolitas Azules??? lindantes al Este y
     una celda vacia o sin bolitas Azules?? al Norte.
  */
  Poner(Azul) Mover(Este) Poner(Azul) Mover(Norte)
}
procedure ConstruirEscalon(){
/*Propósito: contruye un escalon y deja el cabezal al final del mismo.
    Precondición: debe existie al menos una celda vacia o sin bolitas Azules??? lindantes al Este.
*/
 Poner(Azul) Mover(Este) Poner(Azul)
}
/*program {
    ConstruirEscaleraAzulDe4Escalones()
}
*/
-------GUIA3Y4-REPETICIN SIMPLE----------------------------
// 1.Escribir un procedimiento Mover3VecesAlNorte() que mueva el 
//cabezal tres posiciones al Norte de la actual.
procedure Mover3VecesAlNorte(){
    /* Propósito:mueve el cabezal hacia el Norte tres veces .
        Precondición: debe existir al menos dos celdas al Norte a partir de la celda actual.
    */
    repeat(3){
        Mover(Norte)
    }
}
// 2.Escribir un procedimiento Mover3VecesAlEste() que mueva el cabezal tres posiciones al Este de la actual.
// a. ¿Qué similitudes encuentra entre este procedimiento y el anterior?
// Todo el procedimiento es igual excepto la direccion que le paso como argumento.
// b. ¿Qué cambiaría si quisiera hacer un procedimiento que mueva tres veces al Oeste, o tres al Sur?
// Solo el argumento ya que la unica diferencia es la direccion del mismo.
procedure Mover3VecesAlEste(){
    /* Propósito:mueve el cabezal hacia el Este tres veces .
        Precondición: debe existir al menos dos celdas al Este a partir de la celda actual.
    */
     repeat(3){
        Mover(Este)
    }
}
// 3. Escribir un procedimiento Poner6DeColorNegro() que ponga 6 bolitas de color Negro en la 
// celda actual.
procedure Poner6DeColorNegro(){
    /* Propósito:pone seis bolitas Negras en la celda actual.
       Precondición: en la celda actual no debe existir bolitas Negras.
    */
    repeat(6){
        Poner(Negro)
    }
}
// 4. Escribir un procedimiento Poner6DeColorVerde() que ponga 6 bolitas de color Verde en la
//celda actual.
procedure Poner6DeColorVerde(){
    /* Propósito:pone seis bolitas Verdes en la celda actual.
       Precondición: en la celda actual no debe existir bolitas Verdes.
    */
      repeat(6){
        Poner(Verde)
    }
}
------REPETICIÓN SIMPLE EN SUBTAREAS-------------------------------------------------------------------
// 5.  Escribir un procedimiento DibujarRectánguloRojoYNegroDe5x3() que dibuje un rectángulo
//sólido de 5 celdas de largo por 3 de alto, similar al realizado en “P2. 2. Por Arriba”, pero esta vez, utilice
//repetición para solucionar el problema.
procedure DibujarRectánguloRojoYNegroDe5x3(){
    /*PROPÓSITO: Poner un rectángulo sólido de 5 celdas de ancho y 3
                    celdas de alto. Desde la celda actual hacia el Este y hacia el Norte.
     PRECONDICIONES:
                * Hay al menos 4 celdas al Este y 2 celdas al Norte de la celda actual.
                * Las celdas contenidas en el rectángulo de 5x3 desde la celda actual hacia el Este 
                   y hacia el Norte están vacias.
    */
    repeat(3){
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        PasarAProximaLínea()
    }
     VolverAlInicioDelRectángulo()
}
procedure  DibujarLíneaRojaYNegraDeTamaño5HaciaElEste(){
    /*PROPÓSITO: Poner una línea sólida de cinco celdas de ancho hacia el Este.
       PRECONDICIONES: Hay al menos cuatro celdas al Este de la celda actual y 
                       las celdas contenidas en la misma línea están vacias.
    */
    repeat(4){
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
    }
    PonerUnaNegraYUnaRoja()
    IrAlInicioDeLínea()
}
procedure IrAlInicioDeLínea(){
    /*PROPÓSITO: ir al inicio de la línea.
      PRECONDICIONES: debe existir al menos cuatro celdas al Sur.
    */
    IrAlBorde(Oeste)
}
procedure VolverAlInicioDelRectángulo(){
    /*PROPÓSITO: volver a la celda inicial del rectángulo.
      PRECONDICIONES: debe existir al menos dos celdas al Sur.*/
      repeat(6){
         Mover(Sur)    
      }
}
procedure PonerUnaNegraYUnaRoja(){
    /* definido en guia 2 ------ 
      
      PROPÓSITO: Pone una bolita Roja y Negra en la celda actual.
      PRECONDICIONES: la celda actual debe estar vacía.
    */ 
    Poner(Negro)
    Poner(Rojo)
}
procedure PasarAProximaCelda(){
    /* definido en guia 2 ------ 
      
    */
    Mover(Este)
}
procedure PasarAProximaLínea(){
    /* definido en guia 2 ----l
      
    */
    Mover(Norte)
}

// 6. Escribir un procedimiento PintarElTableroDeAzul() que, asumiendo que el tablero tiene 10
//celdas de largo y 7 celdas de alto, pinte absolutamente todo el tablero con bolitas azules, dejando
//exactamente una bolita azul en cada celda.
//a. ¿Cuál es la precondición del procedimiento?
// La misma que el procedimiento DibujarRectánguloRojoYNegroDe5x3() con la
//diferencia del largo y del alto.  
//b. ¿Se le ocurre otra estrategia para resolver el problema?
// Reutilizaria el estrategia DibujarRectánguloRojoYNegroDe5x3() realizando los cambios necesarios para que cumpla con el proposito
// de PintarElTableroDeAzul().

//Importante Recuerde que la estrategia de solución debe quedar clara a partir de la lectura del código.
//Use subtareas con nombres apropiados para dicho objetivo
procedure PintarElTableroDeAzul(){
    /*PROPÓSITO: pinta el tablero de azul.
      PRECONDICIONES: debe existir al menos 9 celdas sin bolitas azules al Este y al menos 6 celdas sin bolitas azules al Norte.
    */
    repeat(6){
        DibujarLíneaAzul()
        PasarAProximaLínea()
    }
    DibujarLíneaAzul()
    VolverAlInicioDelTablero()
}
procedure  DibujarLíneaAzul(){
    /*PROPÓSITO: dibuja una línea azul.
       PRECONDICIONES: debe existir al menos 9 celdas sin bolitas azules al Este.
    */
    repeat(9){
        PonerUnaAzul()  
        PasarAProximaCelda() //definido ejercicio anterior =) 
    }
    PonerUnaAzul()
    IrAlInicioDeLínea() // definido ejercicio anterior =)
}
procedure VolverAlInicioDelTablero(){
    /*PROPÓSITO: vuelve a la celda inicial del tablero.
      PRECONDICIONES: debe existir al menos seis celdas al Sur.
    */
    repeat(6){
        Mover(Sur)    
    }
}
procedure PonerUnaAzul(){
    /* definido en guia 2 ------ 
      
      PROPÓSITO: Pone una bolita Azul en la celda actual.
      PRECONDICIONES: la celda actual no debe  tener bolitas azules.
    */ 
    Poner(Azul)
}
---GUIA 3Y4 REPETICIÓN SIMPLE Y PARÁMETROS: ----------------------------------------------------------
// 1.Escribir un procedimiento Mover3VecesAl_(direcciónAMover) que dada una dirección
//direcciónAMover mueva el cabezal tres posiciones en dicha dirección.
//a. ¿Qué hay que hacer ahora para mover el cabezal tres veces al Norte?
//b. ¿Qué beneficios trae el uso de parámetros?
//c. ¿Cuántos procedimientos puedo ahorrarme haciendo un único procedimiento con un parámetro?
//¡Recordar! No olvidar escribir el contrato del procedimiento ANTES de realizar el código (y que los parámetros
//son parte del mismo); también discutir la precondición escrita con sus compañeros para 
//verificar que la misma es adecuada y correcta
//---EJERCICIO BIBLIOTECA-------------------
procedure Mover3VecesAl_(direcciónAMover){
  /* PROPÓSITO: mueve a partir de la celda actual tres posiciones en dirección direcciónAMover.
     PRECONDICIONES: debe existir al menos dos celdas lindantes al direcciónAMover.
     PARÁMETRO: 
              *direcciónAMover: Dirección - Describe la dirección hacia la cual se va a mover el cabezal.
  */  
  repeat(3){
    Mover(direcciónAMover)
  } 
}
//  Escribir un procedimiento Poner6DeColor_(colorAPoner) que dado un color colorAPoner
//ponga 6 bolitas del color dado.
procedure Poner6DeColor_(colorAPoner){
    /* PROPÓSITO: pone 6 bolitas de color colorAPones.
     PRECONDICIONES: la celda actual no debe tener bolitas de color colorAPoner.
     PARÁMETRO: 
              *colorAPoner: Color - es el color de las bolitas a poner.
    */
    repeat(6){
        Poner(Azul)
    }
}
----------------MÚLTIPLES PARÁMETROS Y PARÁMETROS COMO ARGUMENTOS----------------------------
---EJERCICIOS EXTRAS---<<<EL PLANETA DE NANO--<<<<------------------------
/*
program { 
    ComerBananas() 
}
*/
procedure ComerBananas(){
    /*
    Proposito: que el mono coma todas las bananas del tablero, el mismo queda encima del tablero.
    Precondicion: debe existir bananas, deben existir al menos 9 celdas lindantes al Este y 8 al Norte , un mono para comerlas. 
    */
    ComerFilaDe_Bananas(9)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(4)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(7)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(2)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(8)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(5)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(6)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(3)   
}
procedure ComerFilaDe_Bananas(numeroDeBananas){
    /*
    RTA DEL EJERCICIO-->
     ESTE ES EL PROCEDIMIENTO QUE HACEMOS PARA COMER CUALQUIER FILA YA QUE EL NUMERO DE BANANAS
      VARIA EN CADA FILA.
    Proposito: que el mono se coma una fila de Numeros"numeroDeBanana" de bananas .
    Precondicion: debe existir un mono en la celda actual y un Numero "numeroDeBananas" en direccion al Este.
    Parametro:
        *numeroDeBananas: NUmero. Indica el numero de bananas a comer en direccion al Este. 
    */
    repeat(numeroDeBananas){
        MoverANanoALaDerecha()
        ComerBanana()
    }
    VolverANanoAlBordeIzquierdo()
}
--VARIAS COSAS DE UNA SOLA VEZ-------------------------------------------------------------
/*
program {
  IrALaEsquina__(Sur, Oeste)
  SacarMuchasBolitas(17, Negro)
  MoverMuchasCeldas(3,Este)
  PonerMuchasBolitas(41,Rojo)
}
*/
procedure PonerMuchasBolitas__(cantidadAPoner, colorAPoner) {
  repeat(cantidadAPoner) {
    Poner(colorAPoner)
  }
}
procedure SacarMuchasBolitas__(cantidadASacar, colorASacar) {
  repeat(cantidadASacar) {
    Sacar(colorASacar)
  }
}
procedure MoverMuchasCeldas__(cantidadDeCelasAMover,direccion){
    repeat(cantidadDeCelasAMover){
        Mover(direccion)
    }
}

//2.Escribir un procedimiento Poner_Al_(colorAPoner, direcciónDondePoner) que dado un color
//colorAPoner y una dirección direcciónDondePoner, ponga una bolita del color dado en la celda
//vecina en la dirección dada, dejando el cabezal en dicha celda.
//a. ¿Cuántos casos distintos habría que considerar si no se usarán parámetros en este caso?
//b. ¿Cómo debería invocar al procedimiento para que ponga una bolita Azul en la celda al Norte?
//c. ¿Y sí quisiera una Azul y una Roja?
procedure Poner_Al_(colorAPoner, direcciónDondePoner){
   /* PROPÓSITO: pone una bolita de color colorAPoner en la celda vecina en la dirección  
                 direcciónDondePoner, deja el cabezal en dicha celda.
     PRECONDICIONES:debe existir al  menos una celda lindante en dirección direcciónDondePoner 
                    ademas la celda vecina debe estar vacia.
     PARÁMETROS: 
              *colorAPoner: Color - es el color de las bolitas a poner.
              *direcciónDondePoner:  Dirección - Describe la dirección hacia la cual se va a poner la bolita.
    */
    Mover(direcciónAMover) 
    Poner(colorAPoner)  
}
// 3.Generalizar el ejercicio del reloj analógico simplificado de la práctica anterior para que se pueda pasar
//el radio como parámetro. O sea, se le pide escribir un procedimiento llamado
//DibujarRelojAnalógicoSimplificadoDeRadio_(radio) que ponga los números del reloj
//como en el programa original, pero donde el radio recibido por parámetro indica la distancia al centro
//del reloj: mientras más grande es el radio, más alejados están los números del centro.
//Por ejemplo, el programa del ejercicio anterior podría obtenerse invocando al procedimiento con el
//comando DibujarRelojAnalógicoSimplificadoDeRadio_(2).
procedure DibujarRelojAnalógicoSimplificadoDeRadio_(radio){
    /* Propósito: dibuja un reloj analógico de radio dos.
       Precondición: debe existir al menos numero de celdas lindantes " radio" y deben estar vacias.
       Parametros:
                  * radio: Numero - Es un numero que describe la cantidad de celdas del radio del reloj analógico. 
    */
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(12,Norte,radio,Sur)
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(3,Este,radio,Oeste)
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(6,Sur,radio,Norte)
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(9,Oeste,radio,Este)
}
procedure DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(cantidadAPoner,direccionAMover,numeroDeRadio,direccionAVolver){
    /* Propósito: dibuja el numero "cantidadAPoner" de un reloj analógico hacia dirección "direcciónAMover" y vuelve hacia la dirección "direcciónAVolver".
       Precondición: en la celda actual no debe existir el numero de "cantidadAPoner" del color Rojo y debe existir al menos un numero "cantidadAMover" de celdas lindantes hacia dirección "direcciónAMover".
       Parametros:
                  * cantidadAPoner: Numero - es un numero que indica el numero de bolitas  a poner.
                  * direccionAMover: Direccion - describe la direccion a mover.
                  * numeroDeRadio: NUmero- indica el numero de celdas  de radio...???
                  * direccionAVolver: Direccion - describe la direccion a volver.
    */
        Mover_VecesAl_(numeroDeRadio, direccionAMover) //def ejercicio 10 (reemplazo a  MoverseAlEsteDelReloj() def en guia 2 )
        Poner_DeColor_(cantidadAPoner, Rojo) // def ejercicio 9 (fue reemplazodo Poner3BolitasRojas() definido en guia 2)
        Mover_VecesAl_(numeroDeRadio, direccionAVolver)
}
// 4.¿Se acuerdan de Nova? Es el nuevo compañero del equipo, que no tiene formación profesional, y su
//código está lleno de malas prácticas de programación. Esta vez, en su código se encontró un
//procedimiento que tiene el código hecho, pero no el contrato, y no está indentado.
//a. En primer lugar, se pide corregir los errores de Nova. No olvidar indicar en qué posición queda el
//cabezal, ni de establecer para qué son los parámetros. El código de Nova es el siguiente:
procedure Poner_ADistancia3Al_(color, dirección) {
    /* PROPÓSITO: pone una bolita de color "color" a dos celdas lindantes en dirección "dirección".
       PRECONDICIONES: debe existir al menos dos celdas lindantes hacia dirección "dirección" .
       PARÁMETROS: 
                  *color: Color - indica el color a poner.
                  *dirección: Dirección - describe la dirección de la distancia.  
    */
    Poner(color)
    Mover3VecesAl_(dirección) 
} // se corregio identacion
//b. En segundo lugar, se pide contestar la siguiente pregunta que realizó Nova: ¿Cuál es la relación
//entre el parámetro dirección de este procedimiento con el parámetro direcciónAMover de
//Mover3VecesAl_? 
// La relacion es que los dos procedimientos se mueven en la misma direccion.

// 6.Al continuar revisando código, encontramos otro procedimiento de Nova que carece de contrato y no
//sigue buenas prácticas de programación.
//a y c . Escribir el contrato faltante y corregir las malas prácticas:
procedure Pintar3Puntos_(colorPunto) {   
    /* PROPÓSITO: pinta  tres puntos  color "color" a dos  celdas lindantes en dirección "dirección" entre los mismo.
       PRECONDICIONES: debe existir al menos seis celdas lindantes hacia dirección "dirección" y deben estar vacias .
       PARÁMETROS: 
                  *colorPunto: Color - indica el color a poner.
    */
    repeat(2){
        Poner_ADistancia3Al_(colorPunto, Este) // def en ejercicio anterior
    }
    Poner(colorPunto)
              
}
//b. Ayudar a Nova a contestar la siguiente pregunta: ¿Hay alguna relación entre los parámetros de
//Poner_ADistancia3Al_ y Mover3VecesAl_?
//c. Dado que Nova no pensó en código general, basándose en el procedimiento corregido recién,
//generalizarlo para que, dado un color colorPunto, dibuje los puntos de ese color. El nuevo
//procedimiento debe llamarse Pintar3Puntos_.
// 5. Construir un procedimiento EscribirFechaConDía_Mes_Año_(día, mes, año), que permita
//representar cualquier fecha dados el día, mes y año (como números). La representación debe ser la
//misma utilizada en el ejercicio anterior donde se registró el Día de la Memoria (Azul para el día, Rojo
//para el mes y Verde para el año, en tres celdas hacia el Este).
//¡Recordar! Debe comenzarse por escribir el contrato; en este caso puede resultar útil escribir también una
//observación con la representación a utilizar.
procedure EscribirFechaConDía___(día, mes, año){
 /* Propósito: escribe una fecha del día "día", del mes "mes", del año "año", deja el cabezal al final de la fecha.
    Parámetros:
         *día: es un Número que indica del día del mes a escribir.   ???
         *mes: es un Número que indica el número de mes del año a escribir.  ???
         *año: es un Número que indica el número de año a escribir.
    Precondición: 
         *el espacio actual debe estar vacía.
         *debe existir al menos dos espacios vacíos lindantes al Este.
         *el "mes" debe estar entre los numeros 1 y 12
         *el "día" debe estar entre 1 y 30 en los "meses" igual 3, 4,6,9, 
    Observación:
         *llamamos espacio a una celda.
         * el color Azul representa los días.
         * el color Rojo representa los meses.
         * el color Verde representa el año.
*/
    PonerDía_(día)
    PasarAlSiguienteDato()
    PonerMes_(mes)
    PasarAlSiguienteDato()
    PonerAño_(año)
}
procedure PonerDía_(díaAPoner){
    /* Propósito: pone en el espacio actual el número del día "díaAPoner" dado.
        Parámetro:
         *díaAPoner: es un Número que indica el número  del día a poner
        Precondición: 
         *el espacio actual debe este vacía.
        Observación: llamamos espacio a una celda*/
    repeat(díaAPoner){
        Poner(Azul)
    }
}
procedure PonerMes_(mesAPoner){
     /* Propósito: pone en el espacio actual el número del mes "mesAPoner"
        Parámetro:
         *mesAPoner: es un Número que indica el número  del mes a poner
        Precondición: 
         *el espacio actual debe estar vacía.
        Observación: llamamos espacio a una celda*/
    repeat(mesAPoner){
        Poner(Rojo)
    }
}
procedure PonerAño_(añoAPoner){
    /* Propósito: pone en el espacio actual el número del año "añoAPoner".
        Parámetro:
         *añoAPoner: es un Número que indica el número del año a poner.
        Precondición:
         *el espacio actual debe estar vacía.
        Observación: llamamos espacio a una celda.*/
    repeat(añoAPoner){
        Poner(Verde)
    }
}
procedure  PasarAlSiguienteDato(){
     /* Propósito: pasa al siguiente dato.
        Precondición: debe existir al menos un espacio lindante al Este.
        Observación: llamamos espacio a una celda.*/
    Mover(Este)
}
//Escribir ReemplazarUnaDe_Por_(colorAReemplazar, colorPorElCualReemplazar), un
//procedimiento que dado un primer color colorAReemplazar y un segundo color
//colorPorElCualReemplazar, reemplaza una bolita del primer color por una del segundo color (En la
//celda actual).
procedure ReemplazarUnaDe_Por_(colorAReemplazar, colorPorElCualReemplazar){
    /* PROPÓSITO: reemplazar una bolita "colorAReemplazar" por una bolita "colorPorElCualReemplazar" .
       PRECONDICIONES: debe existir al menos una bolita "colorAReemplazar" en la celda actual.
       PARÁMETROS: 
                  *colorAReemplazar, : Color - indica el color a reemplazar.
                  *colorPorElCualReemplazar: Color -  indica el color por el cual se se va a reemplazar. 
    */
    Sacar(colorAReemplazar)
    Poner(colorPorElCualReemplazar)

} 
// 8. Utilizando el procedimiento Pintar3Puntos_ definido en el ejercicio anterior, construir el
//procedimiento PintarArcoIris() que ponga el tablero de la derecha cuando el tablero inicial es el
//de la izquierda. ¡A no ser como Nova, y empezar escribiendo el contrato
procedure PintarArcoIris(){
    /*PROPÓSITO: pinta un arco iris a partir de la celda actual.
       PRECONDICIONES: debe existir al menos ocho celdas lindantes hacia el Este y al Norte deben estar vacias .
    */
    Pintar3Puntos_(Negro) // definido en el punto anterior =)
    Mover(Este)           
    Pintar3Puntos_(Azul)
    Mover(Este)
    Pintar3Puntos_(Rojo)
    Mover(Este)
    Mover3VecesAl_(Oeste)
    Mover(Norte)
    Mover3VecesAl_(Este)
    Pintar3Puntos_(Verde)
    Mover3VecesAl_(Oeste)
    Mover(Sur)
}
// . Escribir un procedimiento Poner_DeColorRojo(cantidadAPoner) que dado un número
//cantidadAPoner, ponga tantas bolitas como se indica de color Rojo en la celda actual.
//a. ¿Cuántos casos posibles habría que considerar si no se usarán parámetros en este caso o el
//anterior?
procedure Poner_DeColorRojo(cantidadAPoner){
    /* PROPÓSITO: pone un número "cantidadAPoner" de bolitas color Rojo en la celda actual.
       PRECONDICIONES: la celda actual debe estar vacia.
       PARÁMETROS: 
                 *cantidadAPoner: Es un numero que indica la cantidad de bolitas de color Rojo 
                  a poner.
    */
    repeat(cantidadAPoner){
        Poner(Rojo)
    }
}
//9.c ------EJERCICIO BIBLIOTECA ------------------------------------------------------
//Escribir un procedimiento Poner_DeColor_(cantidadAPoner, colorAPoner) que
//dado un número cantidadAPoner y un color colorAPoner, ponga tantas bolitas como se indica del
//color dado de la celda actual.
procedure Poner_DeColor_(cantidadAPoner, colorAPoner){
    /* PROPÓSITO: pone un número "cantidadAPoner" de bolitas color "colorAPoner" en la celda actual.
       PRECONDICIONES: la celda actual debe estar vacia.
       PARÁMETROS:
                 *cantidadAPoner: Numero - Es un numero que indica la cantidad de bolitas a poner.
                 *colorAPoner: Color -  Es el color de las bolitas a poner.
    */
    repeat(cantidadAPoner){
        Poner(colorAPoner)
    }
} 
// 9.a  ---EJERCICIO BIBLIOTECA----------------------------------------------------------------
//Escribir Mover_VecesAl_(cantidadAMover, direcciónAMover), un
//procedimiento que dado un número cantidadAMover y una dirección direcciónAMover mueva el
//cabezal tantas veces como la dada en dicha dirección.  
procedure Mover_VecesAl_(cantidadAMover, direcciónAMover){
    /* PROPÓSITO: mueve un numero "cantidadAMover" en dirección "direcciónAMover".
       PRECONDICIONES: debe existir al menos numero "cantidadAMover" de celdas lindantes en dirección "direcciónAMover".
       PARÁMETROS:
                 *cantidadAMover: Numero - Es un numero que indica la cantidad de celdas a mover.
                 *direcciónAMover: Dirección -  describe la dirección a mover.
    */
    repeat(cantidadAMover){
        Mover(direcciónAMover)
    }
}
// 9.c  ---EJERCICIO BIBLIOTECA----------------------------------------------------------------
//Escribir un procedimiento Sacar_DeColor_(cantidadASacar, colorASacar) que
//dado un número cantidadASacar y un color colorASacar, saque tantas bolitas como se indica del
//color dado de la celda actual.
procedure Sacar_DeColor_(cantidadASacar, colorASacar){
    /* PROPÓSITO: saca un numero "cantidadASacar" de bolitas color "colorASacar" de la celda actual.
       PRECONDICIONES: debe existir al menos numero "cantidadASacar" de bolitas color "colorASacar" en la celda actual.
       PARÁMETROS:
                 *cantidadASacar: Numero - Es un numero que indica la cantidad de bolitas a sacar.
                 *colorASacar: Color -  es el color de bolitas a sacar.
    */
    repeat(cantidadASacar){
        Sacar(colorASacar)
    }
}
//10. -----BIBLIOTECA--------------------------------------------------------------------------
//Escribir el procedimiento IrAEsquina_Y_(primeraDirección,segundaDirección) que dadas dos 
//direcciones posiciona el cabezal en la esquina en dichas direcciones.
procedure IrAEsquina_Y_(primeraDirección, segundaDirección){
    /*PROPOSITO:posiciona el cabezal en la esquina dada por dos direcciones.
      PRECONDICION: debe existir al menos una celda en las  dos direcciones dadas.
      PARAMETROS: 
        *primeraDirección: es una Direccion que indica la direccion hacia donde se va a mover el cabezal por primera vez.
        *segundaDirección: es una Direccion que indica la direccion hacia donde se va a mover el cabezal por segunda vez.
    */
    Mover(primeraDirección)
    Mover(segundaDirección)
}
//13. El bosque, parte 2.
//Continuaremos representando el bosque que comenzamos en la práctica anterior. Esta vez queremos ser capaces de poner 
// o sacar múltiples elementos de una sola vez.
//Importante: para realizar este ejercicio se espera haya realizado la parte 1 de la Práctica 2, si aún no lo hizo, se
//recomienda volver y realizar el mismo previo a solucionar el ejercicio actual.
//a.
procedure Poner_Semillas(cantidadDeSemillasAPoner){
    /* PROPÓSITO: pone una cantidad "cantidadDeSemillasAPoner" de la parcela actual.
       PRECONDICIONES: no debe existir una cantidad "cantidadDeSemillasAPoner" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeSemillasAPoner: Numero - es un numero que indica las semillas a poner.
    */
    repeat(cantidadDeSemillasAPoner){
        PonerUnaSemilla()   // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    } 
}
//b.
procedure Sacar_Semillas(cantidadDeSemillasASacar){
    /* PROPÓSITO: saca una cantidad "cantidadDeSemillasASacar" de la parcela actual.
       PRECONDICIONES: debe existir una cantidad de "cantidadDeSemillasASacar" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeSemillasASacar: Numero - es un numero que indica las semillas a sacar.
    */
    repeat(cantidadDeSemillasASacar){
        SacarUnaSemilla()        // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//c.
procedure Poner_Árboles(cantidadDeÁrbolesAPoner){
    /* PROPÓSITO: pone una cantidad "cantidadDeÁrbolesAPoner" de la parcela actual.
       PRECONDICIONES: no debe existir una cantidad "cantidadDeÁrbolesAPoner" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeÁrbolesAPoner: Numero - es un numero que indica los arboles a poner.
    */
    repeat(cantidadDeÁrbolesAPoner){
        PonerUnÁrbol()            // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//d.
procedure Sacar_Árboles(cantidadDeÁrbolesASacar){
     /* PROPÓSITO: saca una cantidad "cantidadDeÁrbolesASacar" de la parcela actual.
       PRECONDICIONES: debe existir una cantidad de "cantidadDeSemillasASacar" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeÁrbolesASacar: Numero - es un numero que indica los arboles a sacar.
    */
    repeat(cantidadDeÁrbolesASacar){
        SacarUnÁrbol()               // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//e.
procedure Poner_Nutrientes(cantidadDeNutrientesAPoner){
    /* PROPÓSITO: pone una cantidad "cantidadDeNutrientesAPonerAPoner" de la parcela actual.
       PRECONDICIONES: no debe existir una cantidad "cantidadDeNutrientesAPoner" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeNutrientesAPoner: Numero - es un numero que indica los nutrientes a poner.
    */
    repeat(cantidadDeNutrientesAPoner){
        PonerUnNutriente()        // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//f.
procedure Sacar_Nutrientes(cantidadDeNutrientesASacar){
     /* PROPÓSITO: saca una cantidad "cantidadDeNutrientesASacar" de la parcela actual.
       PRECONDICIONES: debe existir una cantidad de "cantidadDeNutrientesASacar" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeNutrientesASacar: Numero - es un numero que indica los nutrientes a sacar.
    */
    repeat(cantidadDeNutrientesASacar){
        SacarUnNutriente()      // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//13.Listado de fechas
//Construir un programa que escriba un listado vertical con las siguientes fechas:
//● Inicio de la Reforma Universitaria.
//● Reglamentación del voto femenino en Argentina.
//● Fecha en la que ocurrieron los hechos conmemorados en el Día Internacional de los
//Trabajadores.
//● Creación del Ministerio de Ciencia y Tecnología argentino.
//● Primera celebración del Día de la Mujer.
//¿Es necesario pensar procedimientos para escribir cada una de las fechas o sirve algo de lo realizado
//con anterioridad?
//---------------------------------------------------------------------------------------------------------------------
procedure DibujarRelojAnalógicoDeColor_SimplificadoDeRadio_(color, radio){
    /* PROPÓSITO: dibujar un reloj analógico a partir de la celda actual.
       PRECONDICIONES: debe existir al menos numero de "radio" de celdas vacias lindantes en sus cuatro direcciónes.
                      También radio debe sel mayor o igual a 1.
       PARÁMETROS:
                 * radio: Numero - Es un numero que indica el radio del reloj analógico.
                 * color: Color - Es el color del reloj analógico.
    */
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(12, color,radio,Norte, Sur)
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(3, color,radio,Este,Oeste)
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(6, color,radio,Sur, Norte)
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(9, color,radio,Oeste, Este)
}
procedure DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(cantidadAPoner,colorAPoner,cantidadAMover,direcciónAMover,direcciónAVolver){
    /* Propósito: dibuja el numero "cantidadAPoner"  de  color "colorAPoner" de un reloj analógico de radio "radio" hacia dirección "direcciónAMover" y vuelve hacia la dirección "direcciónAVolver".
       Precondición: debe existir al menos un numero "cantidadAMover" de celdas lindantes en dirección "direcciónAMover" y deben estar vacias.
       Parametros:
                  * cantidadAPoner: Numero - es un numero que indica el numero a poner.
                  * cantidadAMover: Numero - es un numero que indica el numero a mover.
                  * colorAPoner: Color - es el color a poner
                  * direccionAMover: Direccion - describe la direccion a mover.
                  * direccionAVolver: Direccion - describe la direccion a volver.
    */
    Mover_VecesAl_(cantidadAMover, direcciónAMover)  //def ejercicio 10 (reemplazo a  MoverseAlEsteDelReloj() def en guia 2 )
    Poner_DeColor_(cantidadAPoner, colorAPoner ) // def ejercicio 9 (fue reemplazodo Poner3BolitasRojas() definido en guia 2)
    Mover_VecesAl_(cantidadAMover, direcciónAVolver)
}
// 16.EN PAPEL ¡Nova volvió a hacer de las suyas! Esta vez, el código que escribió no funciona y hay que
//corregirlo. Parece que uno de los problemas de corrección está en el alcance de los parámetros, pero
//no es el único. Aprovechar también para mejorar los nombres de los procedimientos, y también para
//generalizar el tamaño del cuadrado.
procedure DibujarCuadraditoDeLado_DeColor_(numeroDeLado, colorDeCuadrado) {
/*
PROPÓSITO: Dibuja un cuadrado sólido de largo numero "numeroDeLado" y de color "colorDeCuadrado".// es cofrecta el propo?????
PRECONDICIONES: debe existir al menos numero "numeroDeLado"  al Norte y  
                al Este a partir de la actual.Las mismas deben estar vacias.
PARAMETROS:
          *numeroDeLado: Numero - indica el largo del lado del cuadrado.
          *colorDelCuadrado: Color - es el color del cuadradito a dibujar
*/
    repeat(numeroDeLado){
        DibujarLínea_DeLargoDe_(numeroDeLado, colorDeCuadrado)
        Mover(Norte)
    }
    repeat(numeroDeLado){
            Mover(Sur)
    }
}
procedure DibujarLínea_DeLargoDe_(numero,colorDeLinea) {
/*
PROPÓSITO: Dibuja una línea de largo numero "numero" de color "colorDeLinea".
PARAMETROS:
           *colorDeLinea: Color - un color el cual se dibujar la linea.
           *numero: Numero - indica el numero del largo de la linea.
PRECONDICIONES: existe al menos 1 celda al Este de la actual
*/
    repeat(numero){
         Poner(colorDeLinea)
         Mover(Este)
    }
    IrAlBorde(Oeste)   
}
-GUIA5 --<<-EXPRESIONES Y TIPOS---<<------------------------------------
--<<<---LO QUE APREND---<<<<
//Son como las expresiones literales(numero,color,direccion,bool). Las expresiones primitivas 
//(nroBolitas(),nroBolitas(Negro),hayBolitas(), hayBolitas(Rojo),puedeMover(),puedeMover(Este)) 
// Describen informacion.
//Cuando llamo una funcion primitiva luego va los parentesis y las uso como una expresion
 --<<<<--EJERCICIOS INTRODUCTORIOS =)--<<<-----------------------------------------------------------
//El cabezal juega hacer mimo
program {
    PROPOSITO: pone tantas bolitas Rojas como numero de Azules existanen la celdda actual.
    PRECONDICION: debe existir al menos una bolita Azul en la celda actual.

repeat(nroBolitas(Azul)){   // =(  MAL PROCEDIMIENTO YA QUE MEZCLO NIVELES LO MAS ADECUADO 
                            //SERIA USAR LOS PROCEDIMIENTOS PARAMETRIZADO EN LAS BIBLIOTECA
    Poner(Rojo)
}
Poner_DeColor_(nroBolitas(Azul),Rojo) //  ok =)
}
// El mimo que suma
procedure ImitarNegrasYAzules(){
    /*--
    */
    Poner_DeColor_(nroBolitas(Azul) + nroBolitas(Negro),Rojo)
    
}
// La flecha enloquecio
//Aqui uso primero el operador luego la funcion que me da una direccion
program{
    MoverAlRatónA_(opuesto(dondeApuntaLaFlecha()))
}
//Laberinto.
procedure SalirDElLaberinto(){
    /*....
    */
    repeat(20){
        AvanzarUnPasoSiguiendoLaFecha()
    }
}
procedure AvanzarUnPasoSiguiendoLaFecha(){
    /*..
    */
    MoverAlRatónA_YSacarLaFlecha(dondeApuntaLaFlecha())
}
//--IMPORTANTE------------------
// LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA
//( PARA NO VER BOLITAS EN EL CODIGO).
//1.Escribir DibujarBanda_EnDiagonalNEDe_x_(color,alto,largo) que dibuja una banda diagonal
// ancha. Por ejemplo, en la figura se observa el resultado de ejecutar 
//DibujarBanda_EnDiagonalNEDe_x_(Negro, 3, 5)en un tablero de 5x7, comenzando en la esquina 
//SO del tablero.

HACER!!!!!

//2. Moviendo según me indican las bolitas
//Escribir el procedimiento Mover_SegúnColor_(dirección,color), que mueve el cabezal en la
//dirección dada tantas celdas como bolitas de color dado hay en la celda actual. Como ejemplos se
//ofrecen los resultados de evaluar el comando Mover_SegúnColor_(Este, Negro), en diferentes
//tableros iniciales.
procedure Mover_SegúnColor_(dirección,color){
    /*Propósito: mueve hacia dirección "dirección" según el color "color".
       Parámetros: 
        *color: Es un Número que indica las veces del movimiento del cabezal .
        *dirección: Es una Dirección que indica la dirección a mover. 
       Precondición: 
        *Deben existir al menos el número de celdas color "color" lindantes en dirección "dirección".*/
        repeat(nroBolitas (Negro)){
            Mover(Este)
    }
}
//4. El bosque, parte 3
//En este ejercicio continuaremos con nuestro bosque, esta vez colocando semillas y árboles en la celda
//lindante hacia alguna dirección, y dejando el cabezal en la celda inicial.
//a.
// LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA( PARA NO VER BOLITAS EN EL CODIGO).
procedure Poner_SemillasAl_(cantidadDeSemillas, direcciónAPoner){
     /*Propósito: pone una cantidad "cantidadDeSemillas" de semillas en la dirección "direcciónAPoner".
       Parámetros: 
        *cantidadDeSemillas: es un Número que indica la cantidad de semillas a poner.
        *direcciónAPoner: es una Dirección que indica la dirección donde se va a poner la cantidad de semillas.
       Precondición: debe existir al menos una parcela vacía en dirección "dirección".
       Observación: llamamos parcela a una celda.*/
        Mover(direcciónAPoner)
        repeat(cantidadDeSemillas){
            PonerUnaSemilla()         //def. guia 2 ejercicio 8.
    }
        Mover(opuesto(direcciónAPoner))
}
// deja el cabezal en la celda inicial
//b. 
procedure Sacar_ÁrbolesAl_(cantidadDeÁrboles, direcciónASacar){
    /*Propósito: saca una cantidad "cantidad" de árboles en la dirección "dirección".
      Parámetros: 
        *cantidadDeÁrboles: es un Número que indica la cantidad de árboles a sacar.
        *direcciónASacar: es una Dirección que indica la dirección donde se va a sacar la cantidad de árboles.
      Precondición: debe existir al menos una parcela vacía en dirección "dirección" 
                    debe existir cantidad "cantidadDeÁrboles" para sacar.
       Observación: llamamos parcela a una celda.
    */
        Mover(direcciónASacar)
        repeat(cantidadDeÁrboles){
            SacarUnÁrbol()             // Def. guia 2 ejercicio 8.
        }
        Mover(opuesto(direcciónASacar))
}
// deja el cabezal en la celda inicial
//c.
procedure Sacar_SemillasEnDiagonalAl_Y_(cantidadDeSemillas, primeraDirDiagonal, segundaDirDiagonal){
    /*Propósito: saca una cantidad "cantidadDeSemillas" de semillas en las diagonales dirección "primeraDirDiagonal" y
                 dirección "segundaDirDiagonal".
      Parámetros: 
        *cantidadDeSemillas: es un Número que indica la cantidad de semillas a sacar.
        *primeraDirDiagonal: es una Dirección que indica la dirección donde se va a sacar la primer  diagonal de semillas.
        *segundaDirDiagonal: es una Dirección que indica la dirección donde se va a sacar la segunda diagonal de semillas.
      Precondición: debe existir al menos una parcela con cantidad "cantidadDeSemillas" en dirección "primeraDirDiagonal" 
                    debe existir al menos una parcela con cantidad "cantidadDeSemillas" en dirección "segundaDirDiagonal"
       Observación: llamamos parcela a una celda.
    */
}
// deja el cabezal en la celda inicial
//d.
Sacar_ÁrbolesEnDiagonalHorariaAl_(cantidadDeÁrboles, direcciónDiagonal)
//la diagonal horaria de una dirección es aquella dada por la dirección y su dirección siguiente.
// Ej. la diagonal horaria de Norte es Norte-Este, la de Sur es Sur-Oeste.
// deja el cabezal en la celda inicial

//5. Aprendiendo a leer y escribir
//Hacer el procedimiento PasarPalabraActualAMayúsculas() que suponiendo que en la fila actual
//se codifica una palabra en minúsculas usando bolitas, ponga la misma palabra en mayúsculas en la fila al Norte.
//- Cada letra se representa con una cantidad diferente de bolitas negras, según un código numérico llamado ASCII.
//- En la celda más al Oeste de la fila actual se codifica la cantidad de letras de la palabra, usando bolitas rojas.
//- La primera letra de la palabra está en la celda lindante al Este de la que contiene la cantidad de letras.
//- En el código ASCII si las letras mayúsculas se codifican con un número N entonces la misma letra minúscula se 
//representa con N+32 (ej. la ‘a’ minúsculas se representa con el número 97 y la ‘A’ mayúsculas, con el 65).
//- El cabezal se encuentra en la celda más al Oeste de una fila donde hay una palabra representada.
//Importante: ¿Cómo comenzar la resolución? En cada procedimiento, ¿qué parte debe escribirse primero?
program {
    // LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA( PARA NO VER BOLITAS EN EL CODIGO).
    PasarPalabraActualAMayúsculas()
}
procedure PasarPalabraActualAMayúsculas() {
    /*
    proposito: pasa la palabra actual a mayúsculas a partir de la celda actual.
    precondicion:
        * debe haber al menos una bolita color Rojo en la celda actual.
        * debe haber tantas celdas vacias como  el numero de  bolitas Rojas lindantes al Este y
          lo mismo una al Norte mas una celda donde se representaria con bolita Rojas el 
          numero de letras que tiene la palabra.
    observaciones: cada letra se representa con una cantidad diferente de bolitas negras, 
                   según un código numérico llamado ASCII.
                 - En la celda más al Oeste de la fila actual se codifica la cantidad de letras de la palabra, usando bolitas rojas.
                 - La primera letra de la palabra está en la celda lindante al Este de la que contiene la cantidad de letras.
                 - En el código ASCII si las letras mayúsculas se codifican con un número N entonces la misma letra minúscula se 
                   representa con N+32 (ej. la ‘a’ minúsculas se representa con el número 97 y la ‘A’ mayúsculas, con el 65).
    */
    repeat (nroBolitas(Rojo)) {
        PasarASiguienteLetra()
        PonerLetraAMayúscula()
    }
    IrAlBorde(Oeste) // def en guia 3 =)
}
procedure PasarASiguienteLetra() {
    /*
    proposito: pasar a la siguiente letra.
    precondicion: debe haber al menos 1 celda hacia el este de la actual.
    */
    Mover(Este)
}
procedure PonerLetraAMayúscula() { 
    /*
    Aca generalizo la letra no importa el numero la pasa a mayuscula.
    Convierto en letra  el Número de bolitas Negras que representa ese número,
    comienzo a usar las expresiones en este caso nroBolitas  que es como poner numeros, 
    colores o direcciones

    proposito: pone la letra actual a mayúsculas.
    precondicion:
        * la celda actual debe contener una letra en minúsculas.
        * debe haber al menos 1 celda hacia el norte de la actual.
    */
    PonerLetra_AlNorteEnMayúscula(nroBolitas(Negro)) 
    // Argument:con lo que se representa cada letra que es el Numero de bolitas Negro
}
procedure PonerLetra_AlNorteEnMayúscula(numeroDeLetra) {
    /**Es el primer subtarea que tengo que hacer y pensar
    *Argument:es lo que representa cada numero de bolitas Negras o lo que generalizo en este caso la letra.
    Para convertirla tengo que moverme al norte y al numero de letra cualquiera sea la letra
     le resto 32 y ya la  pase a mayuscula.

    proposito: pone la letra "numeroDeLetra" actual en mayúsculas hacia el Norte a partir de la celda actual.
    parametros:
        * numeroDeletra; tipo Numero, describe el numero de la letra a poner
    precondicion: debe existir una letra en la celda actual y debe haber una celda vacia hacia el norte a partir de la actual.
    */
    Mover(Norte)
    Poner_DeColor_(numeroDeletra - 32, Negro) // ejercicio de biblioteca guia 4
    Mover(Sur)
}

//---BIBLIOTECA EJERCICIO ---------------------------------------------------------------------------------------------
//6. Sacando todas las de un color
//Escribir un procedimiento SacarTodasLasDeColor_(colorASacar), que quite de la
//celda actual todas las bolitas del color indicado por el parámetro.
//PISTA: Considerar utilizar el procedimiento Sacar_DeColor_, definido en la práctica anterior. ¿Qué argumentos 
//se le deberían pasar?
procedure SacarTodasLasDeColor_(colorASacar){
    /*Propósito: saca todas las bolitas de color "colorASacar" de la celda actual.
    Parametros: 
        *colorASacar: Es un color que describe  el color de las bolitas a sacar de la celda.
    Precondicion: Debe existir al menos la cantidad dada a sacar de bolitas "colorASacar" en la celda actual.*/
      Sacar_DeColor_Veces(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9.
}

//---EJERCICIO BIBLIOTECA--------------------------------------------------------------------------------------------
//7. ¿Y si vaciamos la celda?
//Escribir un procedimiento VaciarCelda() que quite de la celda actual todas las bolitas de todos los colores, 
//dejando la celda vacía.
procedure VaciarCelda(){
     /*Propósito: quite de la celda actual todas las bolitas de todos los colores.
       Precondicion: debe existir bolitas de todos los colores en la celda actual.
     */
        SacarTodasLasDeColor_(colorASacar)
        SacarTodasLasDeColor_(colorASacar)
        SacarTodasLasDeColor_(colorASacar)
        SacarTodasLasDeColor_(colorASacar)
}
//8. ¡A la batalla!, parte 1
//Suponiendo que se está programando un juego donde en las celdas del tablero se representan
//Soldados (los aliados con una bolita de color Negro y los enemigos con una bolita de color Rojo por
//cada soldado), escribir los siguientes procedimientos:
//a. EnviarAliadosParaDuplicarEnemigos(), que agrega soldados aliados en la celda actual
//en cantidad suficiente para que haya el doble de aliados que de soldados enemigos.
// LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA( PARA NO VER BOLITAS EN EL CODIGO).
procedure EnviarAliadosParaDuplicarEnemigos() {
    /*
    PROPOSITO: agrega el doble de soldados aliados que de enemigos en la celda actual.
    PRECONDICIONES: no tiene.
    OBSERVACIONES: 
        * los soldados aliados se representan con una bolita de color Negro. 
        * los soldados enemigos con una bolita de color Rojo.
    */
    Poner_DeColor_(nroBolitas(Rojo) * 2 , Negro)
}
//b. PelearLaBatalla(), que simula una batalla, suponiendo que hay suficiente cantidad de
//soldados aliados como para ganar la batalla. Durante una batalla, 2 soldados enemigos pelean
//contra 3 soldados aliados y todos mueren. Por ejemplo, si hay 6 enemigos y 10 aliados, mueren
//los 6 enemigos y 9 de los aliados; si hay 10 enemigos y 21 aliados, mueren los 10 enemigos y 15 soldados aliados.
//PISTA: ¿Qué cuenta hay que hacer para saber cuántos soldados aliados morirán?
procedure PelearLaBatalla() {
    /*
    PROPOSITO: simula una batallaen la celda actual???? .
    PRECONDICIONES: debe haber mayor cantidad de soldados aliados que enemigos.
    */
    Sacar_DeColor_((nroBolitas(Rojo) * 3) div 2, Negro) 
    SacarTodasLasDeColor_(Rojo) // def ejercicio anterior
}
//9. -----SOPORTE TECNICO------
/* REPRESENTACIÓN DEL DOMINIO
   - los virus se representan con bolitas Rojas, de 1 a 6 
   - una indicación de que la máquina de la celda actual no 
     tiene virus (indicación de OK) se representa con una 
     bolita Verde
   - el Hall del edificio en la celda 0,0 con la cantidad de 
     pisos representada por las bolitas Azules
   - el Hall del piso en la celda del borde Oeste de cada piso, 
     con la cantidad de máquinas del piso representada por las 
     bolitas Negras 
*/
program {
RepararEdificio()
}
procedure RepararEdificio(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del edificio. 
         El cabezal queda en el Hall del último piso 
         del edificio (el hall más al Norte)
     PRECONDICIONES: 
       * el cabezal debe estar en la hall del edificio
  */
  repeat(nroBolitas(Azul)){
    PasarAlProximoPiso()
    RepararPiso() 
  }
}
procedure PasarAlProximoPiso(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar el proximo piso a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Norte)
}
procedure RepararPiso(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del piso actual
         (sacando todos los Virus de las máquinas del piso)
     PRECONDICIONES: 
       * la celda actual es el Hall del piso
  */
  repeat(nroBolitas(Negro)){
    PasarAProximaMáquina()
    RepararMáquina() 
  }
  IrAlBorde(Oeste)
}
procedure PasarAProximaMáquina(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar la proxima maquina a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Este)
}
procedure RepararMáquina(){
  /* 
     PROPÓSITO: 
       * eliminar los virus de la celda actual y dejar 
         la marca de OK 
     PRECONDICIONES: 
       * en la celda actual hay una máquina con virus
         y sin marcas de OK
  */
  repeat(nroBolitas(Rojo)){
      Sacar(Rojo)
    }
  IndicarOk()
}
procedure IndicarOk() {
  /* 
     PROPÓSITO: 
       * indicar que la máquina de la celda actual no tiene 
         virus poniendo la indicación de OK
     PRECONDICIONES: 
       * la máquina de la celda actual no tiene virus ni 
         indicación de OK
  */
  Poner(Verde)
}
procedure SacarTodas_(colorASacar) {
  /*
     PROPÓSITO: 
       * sacar de la celda actual todas las bolitas 
         del color dado
     PRECONDICIONES: 
       * ninguna (es una operación total)
     PARÁMETROS:
       * colorASacar es un color, que indica el color 
          de las bolitas que se deben sacar
  */
  Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9
}
/* LO QUE APRENDI--------
 que es importante moverse despues de las repeticiones que use segun el nro de maquinas 
que tenga en el piso para chequear(nro de bolita Negro) lo mismo pasa en las de los pisos
que se represento con nro de bolitas Azules. <3
 
  Es mejor usar el Mover_VecesAl_(numero,direccion) o Poner_DeColor(numero,color), etc.
*/
------UNIDAD6-----<< ALTERNATIVA CONDICIONAL--<<--------------
--<<EJERCICIOS INTRODUCTRIOS---<<<------------------------------------
//Apagar la luz o prenderla
procedure SimularInterruptorDeLuz(){
    /*__
    */
    if(hayBolitas(Azul))then{
         Poner(Negro) Sacar(Azul)
    }
}
//NO me quiero caer
procedure DibujarLaVibora(){
    /*....
    */
    repeat(10){
        DefinirSegmentoDeViboraYAvanzar()
    }
}
procedure DefinirSegmentoDeViboraYAvanzar(){
    /*...
    */
    if(puedeMover(Este)){
        Poner(Verde) Mover(Este)
    }
    else{ 
        Poner(Verde) Mover(Norte)
    }
}
// Siempre el mejor!  
procedure CombatirGikachuVsGarmander(){
    /* nos enseña a usar la multialternativa.
    Proposito:
    Precondicion:
    */
    if(nroBolitas(Rojo) == nroBolitas(Negro)){
        ProcesarEmpate()
    }
    elseif (nroBolitas(Rojo) >= nroBolitas(Negro) ){
         SacarGikachu()  
    }
    else { 
        SacarGamander()
    }
}
procedure ProcesarEmpate(){
    /*
    Proposito:
    Precondicion:
    */
    SacarTodasLasDeColor_(Negro)
    SacarTodasLasDeColor_(Rojo)
}
procedure SacarGamander(){
    /*
    Proposito:
    Precondicion:
    */
    SacarTodas_(Rojo)
}
procedure SacarGikachu(){
    /*
    Proposito:
    Precondicion:
    */
    SacarTodas_(Negro)
}
//No, no y no. 
procedure CompletarLaFilaDePelotas(){
    /* 
     Nos enseña el uso de la negacion =)

        Proposito:
        Precondicion:
    */
        repeat(4){
            AgregarPelotaSiHaceFalta()
            IrALaSiguientePosicionAControlar()
        }
        AgregarPelotaSiHaceFalta()
}
procedure AgregarPelotaSiHaceFalta() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
        ...
    */
        if(not hayPelota())then{
             AgregarPelota()
        }
}
procedure IrALaSiguientePosicionAControlar() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
            * ....
    */
        Mover(Sur)   
}
------------ FUNCIONES SIMPLES---------------------------------------------------------------
-----EJERCICIOS INTRODUCTORIOS---------------------------------------------------------------
//La luz esta prendida vs hay bolitas.
procedure SimularInterruptorDeLuz(){
    if(laLuzEstaPrendida()) then{  //aqui cambio hayBolitas(Azul)por hayLuz() 
        ApagarLaLuz()
    } 
    else { 
        PrenderLaLuz()
    }
}
function laLuzEstaPrendida() {
    /*
        PROPÓSITO: Indica si esta prendida la luz en la celda actual.
        PRECONDICIONES: Ninguna. es una funcion total.
        RESULTADO:Booleano.Verdadero cuando hay luz en la celda actual,
                   Falso en el caso contrario.
    */
     return( (nroBolitas(Azul)) == 1)
}
procedure PrenderLaLuz() {
    Poner(Azul)
    Sacar(Negro)
}
procedure ApagarLaLuz(){
    Poner(Negro)
    Sacar(Azul)
}
// Y tambien...(Mantener el cantero.)
function hayFlor(){
    return ((hayBolitas(Rojo) == 2) && (hayBolitas(Verde) == 1))
}

procedure MantenerElCantero(){
    repeat(9){
        MantenerSeccionDelCantero()
        IrALaSiguienteSeccionDelCantero()
    }
    MantenerSeccionDelCantero()
}
procedure MantenerSeccionDelCantero(){
    if(not (hayFlor()))
     then { PantarFlor()
          }
}
procedure IrALaSiguienteSeccionDelCantero(){
    Mover(Este)
}
procedure PantarFlor(){
    repeat(2){
        Poner(Rojo)
    }
    Poner(Verde)
}
// Salir del laberinto comiendo el queso.
procedure ComerQuesoSiHay() {
    /*
     Lo que aprendi que ¿esta bien que explote  ????????????seeeeeeee =)
     Cada procedure (subtarea) soluciona una alternativa condicional(no anidar).
     Y que lo cuerpos de las repeticiones quizas invoco a las  subtareas con condicionales, 
     y con multitareas.
       
        PROPÓSITO:  ....
        PRECONDICIONES:
        
    */
    if(hayQueso()){
        ComerElQueso()
    }
}
procedure ComerQueso() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
    */
    Sacar(Verde)
}
procedure SaliDelLaberintoComiendoQueso() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
    */
    repeat(20){
        ComerElQuesoSiHay()
        AvanzarUnPasoSiguiendoLaFlecha()
    }    
}
procedure AvanzarUnPasoSiguiendoLaFecha(){
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
    */
    if(laFlechaApuntaAlNorte()){
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Norte) //primitiva
    }
    elseif (laFlechaApuntaAlEste()) {
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Este) //primitiva
    }
    elseif(laFlechaApuntaAlSur()){
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Sur) //primitiva
    }
    else{
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Oeste) //primitiva
     }
}
function laFlechaApuntaAlNorte() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 1))
}
function laFlechaApuntaAlEste() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 2))
}
function laFlechaApuntaAlSur() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 3))
}
function laFlechaApuntaAlOeste(){
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 4))
}
function hayQueso() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Verde)) == 1)
}

// Esta lista la cena
program{
    if(estaListaLaCena) then{
         AvisarQueVengan()
    }
    else{ 
        AvisarQueTodaviaFalta()
    }
}
function estáListaLaCena() {
    /*
        PROPÓSITO: indica si esta lista la cena en la celda actual.
        TIPO: Bool, verdadero cuando esta lista la cena en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return (estáElPlatoPrincipalEnLaMesa() 
            &&
            estáElPostreEnLaMesa()
            )
}
function estáElPostreEnLaMesa(){
    /*
        PROPÓSITO: indica si esta el postre en la celda actual.
        TIPO: Bool, verdadero cuando esta el postre  en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return(estáLafrutaenLaMesa()
            ||
            estáLaTortaEnLaMesa()
           )
}
function estáElPlatoPrincipalEnLaMesa(){
    /*
        PROPÓSITO: indica si esta el plato principal en la celda actual.
        TIPO: Bool, verdadero cuando esta el plato principal en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return( estáElBifeConEnsalada()
            ||
            estáElGobCombo()
          )
}
function estáElBifeConEnsalada(){
    /*
        PROPÓSITO: indica si esta el bife con ensalada o el Gobcombo en la celda actual.
        TIPO: Bool, verdadero cuando esta el bifecon ensalada o Gobcombo  en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return ( estáElBifeEnLaMesa()
            &&
            estáLaEnsaladaEnLaMesa()
           )
}
function estáElGobCombo(){
    /*
        PROPÓSITO: indica si esta el Gobcombo en la celda actual.
        TIPO: Bool, verdadero cuando esta Gobcombo  en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return( estáLaHamburguesaEnLaMesa()
           &&
           estánLasPapasFritasEnLaMesa()
          )
}
/*2. Definir funciones totales que sean verdaderas (describan al valor de verdad
Verdadero) para cada uno de los siguientes casos. Recordar que es conveniente
utilizar funciones para expresar subtareas, de forma que las expresiones utilizadas
no queden imposibles de entender. Recordar también que antes de escribir el código
de una operación, debe escribirse el contrato de la misma (nombre, parámetros,
propósito y precondiciones).
a. Cuando la celda actual tiene más de 5 bolitas en total.
b. Cuando la celda actual tiene al menos 5 bolitas en total.
c. Cuando la celda actual tiene al menos 5 bolitas en total y el borde se
   encuentra justo al Este de la misma.
d. Cuando la celda actual tiene una celda lindante al Norte o al Este.
e. Cuando la celda actual tiene bolitas de todos los colores.
f. Cuando en la celda actual faltan bolitas de al menos un color (dar una
   solución sin usar la funciónes.  
a.*/ 
function mayorACinco(){   // FEA EXPRESION y no se si soluciona el problem =( porque si sumo el total de volita da false =(!!!????
    /*
     Proposito: indicar si hay mas de cinco bolitas en la celda actual.
     Precondicion:ninguna, es una funcion total.
     Tipo: Booleano
    */
    return((nroBolitas(Azul) > 5) || (nroBolitas(Negro) > 5) || (nroBolitas(Rojo) > 5) || (nroBolitas(Rojo) > 5)  )
}
//b.
function menosDeCinco() {
    /*
        PROPÓSITO:indica cuando la celda actual tiene al menos 5 bolitas en total.
        TIPO: Booleano.
        PRECONDICIONES:ninguna es una funcion total.
    */
    
   
}
//c.
function menosDeCincoYEstoyAlBorde() {  // puedo parametrizar la dire
    /*
        PROPÓSITO: indica cuando la celda actual tiene al menos 5 bolitas en total y el borde se
                   encuentra justo al Este de la misma.
        TIPO: Booleano.
        PRECONDICIONES: ninguna es una funcion total.
            
    */
    return( menosDeCinco() && not(puedeMover(Este)))  
}
//d.
function hayCeldasLindantes() {
    /*
        PROPÓSITO: indica cuando la celda actual tiene una celda lindante al Norte o al Este.
        TIPO: Booleano
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(puedeMover(Norte) || puedeMover(Este))
}
//e. 
function hayDeTodosLosColores() {
    /*
        PROPÓSITO: indica cuando la celda actual tiene bolitas de todos los colores.  
        TIPO: Booleano
        PRECONDICIONES: ninguna, es una funcion total.??????
    */
    return(hayBolitasAzulYBolitasRojo() && hayBolitasVerdeYBolitasNegro())  
}
function hayBolitasAzulYBolitasRojo(){
     /*
        PROPÓSITO: indica si en la celda actual existen bolitas de color Azul y Rojo. 
        TIPO: Booleano.
        PRECONDICIONES: ninguna, es una funcion total.??????
    */
    return(hayBolitas(Azul) && hayBolitas(Rojo))
}
function hayBolitasVerdeYBolitasNegro(){
     /*
        PROPÓSITO: indica si en la celda actual existen bolitas de color Verde y Negro. 
        TIPO: Booleano.
        PRECONDICIONES: ninguna, es una funcion total.??????
    */
    return(hayBolitas(Verde) && hayBolitas(Negro))
}
f.function faltaAlMenosUnColor() {
    /*  dar una solución sin usar la funciónes
        PROPÓSITO: indica cuando en la celda actual faltan bolitas de al menos un color. 
        TIPO: Booleano
        PRECONDICIONES: ninguna es una funcion total. ??????
    */
 
   
}
3./*Escribir los siguientes procedimientos, recordando no mezclar niveles de abstracción
del problema, para lo cual puede ser necesario definir otros procedimientos y/o funciones.
a.SacarUnaFicha_SiSePuede(colorDeLaFicha) que, dado el colorDeLaFicha que debe sacarse,
saque una ficha siempre y cuando la misma esté en la celda. Si no hubiera fichas del color dado,
el procedimiento no hace nada. Si hubiera varias fichas, solo debe sacar una.
OBSERVACIÓN: cada ficha se representa con una bolita del color correspondiente.*/
procedure SacarUnaFicha_SiSePuede(colorDeLaFicha) {
    /*
        PROPÓSITO:  saca una ficha de color "colorDeLaFicha" siempre y cuando la misma esté en la celda. 
                    Si no hubiera fichas del color dado, el procedimiento no hace nada. 
                    Si hubiera varias fichas, solo debe sacar una.
        OBSERVACIÓN: cada ficha se representa con una bolita del color correspondiente.
        PARÁMETROS:
            * colorDeLaFicha: Color - describe el color de la ficha a sacar.
            
        PRECONDICIONES: ninguna ya que el ejercicio hablando de la condicion. 
    */
    if(hayFichaDeColor_(colorDeLaFicha)) then{
        SacarFicha_(colorDeLaFicha)
    }   
}
function hayFichaDeColor_(colorDeLaFicha) {
    /*
        PROPÓSITO: indica si hay ficha de color "colorDeLaFicha" en la celda actual.
        PARÁMETROS:
            * colorDeLaFicha: Color - describe el color de las fichas a sacar. 
        TIPO: Booleano, indica Verdadero si hay ficha de color "colorDeLaFicha" en la celda actual,
              Falso en caso contrario.
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(hayBolitas(colorDeLaFicha))
}
procedure SacarFicha_(colorDeLaFicha){
    /*
        PROPÓSITO: saca una ficha de color "colorDeLaFicha" de la celda actual.
        PARÁMETROS:
            * colorDeLaFicha: Color - describe el color de las fichas a sacar. 
        PRECONDICIONES: debe existir al menos una  ficha del color "colorDeLaFicha" en la celda actual.
    */
    Sacar(colorDeLaFicha)
}
b.DesempatarParaElLocal_Contra_(colorDelLocal,colorDelVisitante) que,
 dados los colores de dos jugadores, ponga una bolita del
colorDelLocal solamente en el caso en que la celda actual contiene la
misma cantidad de bolitas de ambos colores.
procedure DesempatarParaElLocal_Contra_(colorDelLocal,colorDelVisitante ) {
    /*
        PROPÓSITO: pone una bolita del colorDelLocal solamente en el caso en que la celda 
                  actual contiene la misma cantidad de bolitas de ambos colores.
        PARÁMETROS:
            * coloreDelLocal: Color - describe el color del jugador local.
            * colorDelVisitante: Color - describe el color del jugador visitante.
l        PRECONDICIONES: debe existir en la celda actual el mismo numero de
                         bolitas de los colores "colorDelLocal" y "colorDelVisitante."
    */
  
}
function hayEmpateEntre_Y_(colorDelLocal, colorDelVisitante) {
    /*
        PROPÓSITO: indica si hay un empate en la celda actual.
        PARÁMETROS:
            * colorDelLocal: Color- describe el color de los jugadores locales.
            * colorDelVisitante: Color- describe el color de los jugadores visitantes.
        TIPO: Booleano
        PRECONDICIONES: ninguna es una funcion total.
    */
    
}
c.ExpandirBacteriaDeLaColonia(), que siempre que en la celda actual haya
un cultivo de bacterias y haya suficientes nutrientes,agregue
exactamente una bacteria más y consuma nutrientes, a razón de dos
nutrientes por bacteria expandida; si no hay bacterias o no hay suficientes
nutrientes, no hace nada. Las bacterias se representan con bolitas Verdes y
los nutrientes con bolitas Rojas.
procedure ExpandirBacteriaDeLaColonia() {
    /*
        PROPÓSITO: expande un cultivo de bacterias en la celda actual.
        PRECONDICIONES:en la celda actual siempre debe existir un cultivo de bacterias y 
                       debe existir suficientes nutrientes.
        OBSERVACIÓN:  El cultivo de bacterias se representan con bolitas Verdes y los nutrientes con 
                     bolitas Rojas
    */
}

d.PonerFlecha_AlNorteSiCorresponde(colorDeLaFlecha), que dado
un color para representar flechas, ponga una flecha al Norte si existe espacio
para moverse en esa dirección. Las flechas al Norte serán representadas con
una bolita del color dado.
procedure PonerFlecha_AlNorteSiCorresponde(colorDeLaFlecha) {
    /*
        PROPÓSITO: pone una flecha color "colorDeLaFlecha " en la celda lindante al Norte, 
                  si existe espacio para moverse en esa dirección.
        PARÁMETROS: 
            colorDeLaFlecha :Color - describe el color de la representación de la flecha.
        PRECONDICIONES: debe existir una celda sin flecha lindante al Norte a partir de la 
                         celda actual no debe existir flecha en la celda actual.
        OBSERVACIÓN: Las flechas al Norte serán representadas con una bolita del color dado.
    */
    

4.Escribir los siguientes procedimientos:
a.PudrirManzana(), que en el caso de que en la celda actual haya al menos
una manzana en buen estado y un gusano, pudre una manzana retirando un
gusano.
OBSERVACIONES: las manzanas en buen estado se representan con bolitas
de color Rojo, las manzanas podridas con bolitas de color Negro, y los
gusanos con bolitas de color Verde.
SUGERENCIA: primero dar el contrato de la siguiente subtarea y utilizarlo en
la resolución. Reemplazar_Y_Por_(primerColorAReemplazar, segundoColorAReemplazar, colorAAgregar)
b. Completar el código de Reemplazar_Y_Por_.
c. PudrirHasta_Manzanas(cantidadAPudrir),
que pudrehasta un máximo de manzanas dada por la cantidad. Puede que se pudran menos
manzanas si no se dan las condiciones necesarias (no hay suficientes
manzanas en buen estado, o suficientes gusanos, por ejemplo).
// b.
procedure Reemplazar_Y_Por_(primerColorAReemplazar, segundoColorAReemplazar, colorAAgregar) {
    /*
        PROPÓSITO: reemplaza los colores "primerColorAReemplazar" y "segundoColorAReemplazar" por 
                   el color "colorAAgregar"  en la celda actual.
        PARÁMETROS:
            * primerColorAReemplazar: Color - describe el primer color a reemplazar .
            * segundoColorAReemplazar: Color - describe el segundo color a reemplazar.
            * colorAAgregar: Color - describe el color por el que vamos a reemplazar los colores 
                             "primerColorAreemplazar" y "segundoColorAReemplazar".
        PRECONDICIONES: ninguna es una funcion total.
    */
    Poner( colorAAgregar)
    Sacar(primerColorAReemplazar)
    Sacar(segundoColorAReemplazar)
}
// a.
procedure PudrirManzana() {
    /*
        PROPÓSITO: en el caso de que en la celda actual haya al menos una manzana en buen estado y un gusano, 
                   pudre a la misma retirando un gusano.
        PRECONDICIONES: en la celda actual debe haber al menos  una manzana en buen estado 
                        y un gusano.
        OBSERVACIONES: las manzanas en buen estado se representan con bolitas
                       de color Rojo, las manzanas podridas con bolitas de color Negro, y los
                       gusanos con bolitas de color Verde.
    */
    if(hayManzanaEnBuenEstado && hayGusano) then{
        Reemplazar_Y_Por_(Rojo,Verde, Negro)
    }
}
function hayManzanaEnBuenEstado() {
    /*
        PROPÓSITO: indica si hay una manzana en buen estado en la celda actual.
        TIPO: Booleano, Verdad si hay manzana en buen estado en la celda actual,
              Falso en caso contrario.
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(hayBolitas(Rojo))
}
function hayGusano() {
    /*
        PROPÓSITO: indica si hay un gusano en la celda actual.
        TIPO: Booleano, Verdadero cuando hay un gusano en la celda actual,
              Falso en caso contrario.
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(hayBolitas(Verde))   
}
c. PudrirHasta_Manzanas(cantidadAPudrir), que pudre hasta un
máximo de manzanas dada por la cantidad. Puede que se pudran menos
manzanas si no se dan las condiciones necesarias (no hay suficientes
manzanas en buen estado, o suficientes gusanos.).
procedure PudrirHasta_Manzanas(cantidadAPudrir){ // va un BOOM ????
    /*
        PROPÓSITO: pudre hasta un máximo de manzanas dada por la cantidad "cantidadAPudrir".
                    Se puede pudrir menos manzanas si las condiciones necesarios no se dan.
        PARÁMETROS:
            * cantidadAPudrir: Número - describe el numero de manzanas a pudrir.
        PRECONDICIONES: que en la celda actual debe existir  al menos manzanas como numeros de gusanos.
        Observación:Puede que se pudran menos manzanas si no se dan las condiciones necesarias
         (no hay suficientes manzanas en buen estado, o suficientes gusanos, por ejemplo).
    */
    repeat(cantidadAPudrir){
        PudrirManzana()
    }
}
// ----OPCION 2 SIN USAR EL REEMPLAZAR---
  if( hayManzanaEnBuenEstado() && hayGusano()) then{
        Sacar_DeColor_(cantidadAPudrir, Verde)
        Sacar_DeColor_(cantidadAPudrir, Rojo)
        Poner_DeColor_(cantidadAPudrir, Negro)
    }
}
5. BIBLIOTECA
 La combinación de parámetros y expresiones booleanas es interesante.
a.Escribir un procedimiento Poner_Si_(color, condición) que dado un
color y un valor de verdad llamado condición, ponga en la celda actual
una bolita del color dado si el valor de verdad de la condición es verdadero,
y no lo ponga si no.
procedure Poner_Si_(color, condición)() {
  /*
    PROPÓSITO: pone bolitas de color  "color" en la celda actual soloamente si se comple la condicion.
    PRECONDICIONES:  ninguna es una funcion total
    PARÁMETROS:
      *color: Color- describe el color "color" de la bolitas a poner  si la condicion es Verdad en la celda actual.
      *condición: Booleano- indica  la  condición que tiene que cumplirse para poner una bolita.
  */
  if(condición) then {
    Poner(color)
  }
}
EJEMPLO: Poner_Si_(Rojo, nroBolitas(Rojo)==0) solamente pone
una bolita roja cuando no hay ninguna roja en la celda actual.

b.Escribir los procedimientos Sacar_Si_(color,condición) y
Mover_Si_(dirección,condición) que actúan de forma similar a Poner_Si_.
procedure Sacar_Si_(color,condición) {
  /*
    PROPÓSITO: saca solamente si existe bolitas color "color".
    PARÁMETROS:
     *color: Color- describe el color "color" de la bolitas a sacar  si la condicion es Verdad.
     *condición: Booleano- indica la  condición que tiene que cumplirse para sacar una al menos una bolita.
    PRECONDICIONES: ninguna es una funcion total.
  */
  if(condición) then {
    Sacar(color)
  } 
}
procedure Mover_Si_(dirección,condición) {
  /*
    PROPÓSITO: mueve en direccion "direccion" solamente si cumple la condicion "condicion".
    PARÁMETROS:
      * color: Dirección - describe la direccion a mover a partir de la celda actual.
      * condición: Booleano - indica  la condición  que tiene que cumplirse para mover.
    PRECONDICIONES: ninguna es una funcion total.
  */
  if(condición) then {
    Mover(dirección)
  } 
}
c.Reescribir el procedimiento DesempatarParaElLocal__. hecho antes,
pero utilizando el procedimento Poner_Si_.
procedure DesempatarParaElLocal__(colorDelLocal,colorDelVisitante ) {
   /* PROPÓSITO: pone una bolita del colorDelLocal solamente en el caso en que la celda 
                  actual contiene la misma cantidad de bolitas de ambos colores.
        PARÁMETROS:
            * coloreDelLocal: Color - describe el color del jugador local.
            * colorDelVisitante: Color - describe el color del jugador visitante.
l        PRECONDICIONES: ninguna ya que llama a una subtarea que en realidad es un condicional
                         que si no se cumple la condicion la subtarea no hace nada .^^.
					 ademas absorve la precondiocion de Poner_Si_(color,numero)
                        
    */
    Poner_Si_(colorDelLocal,(nroBolitas(colorDelLocal) == 
                             nroBolitas(colorDelVisitante))
              )
}

d. ¿Puede reescribirse el procedimiento Reemplazar_Y_Por_ hecho antes, pero reutilizando únicamente los procedimientos Poner_Si_ y Sacar_Si_? Si la respuesta es afirmativa, dar el código correspondiente. elSi no, justificar por qué no sería posible.
procedure Reemplazar_Y_Por_(primerColorAReemplazar, segundoColorAReemplazar, colorAAgregar) {
    /*  
        PROPÓSITO: reemplaza los colores "primerColorAReemplazar" y "segundoColorAReemplazar" por 
                   el color "colorAAgregar"  en la celda actual.
        PARÁMETROS:
            * primerColorAReemplazar: Color - describe el primer color a reemplazar .
            * segundoColorAReemplazar: Color - describe el segundo color a reemplazar.
            * colorAAgregar: Color - describe el color por el que vamos a reemplazar los colores 
                             "primerColorAreemplazar" y "segundoColorAReemplazar".
        PRECONDICIONES: ninguna es una funcion total.
    */
    Poner_Si_(colorAAgregar, hayBolitas(segundoColorAReemplazar))
    Sacar_Si_(primerColorAReemplazar,hayBolitas(colorAAgregar))
    Sacar_Si_(segundoColorAReemplazar,hayBolitas(colorAAgregar))  
}
e. ¿Que beneficios trae tener los procedimientos Sacar_Si_ y Poner_Si_
contra utilizar if en cada caso?
El beneficio de los procedimientos es que no anidamos repeticiones y ademas 
comunica de forma clara nuestra estrategia ademas de  ayudar a la hora de realizar alguna correcion.

6. El bosque, parte 4 
En este ejercicio continuaremos expandiendo el dominio del bosque. Escribir los
siguientes procedimientos. Considerar la reutilización de los procedimientos hechos
en las partes anteriores y la definición de nuevas funciones necesarias para no tener
que depender de la representación dada.
a. GerminarSemilla(), que transforma una semilla en un árbol en la celda
actual. La germinación consume tres unidades de nutrientes. Si en la celda
no hay semilla, o no hay suficientes nutrientes, no se hace nada.
procedure GerminarSemilla(){
    /*
    Propósito:transforma una semilla en un árbol en la parcela actual.
              La germinación consume tres unidades de nutrientes. 
              Si en la celda no hay semilla, o no hay suficientes nutrientes, no se hace nada.
    Precondición:ninguna .
    Observación: llamamos parcela a una celda.
    */
  
}

b. AlimentarÁrboles(), que hace que los árboles de la celda actual se
alimenten, consumiendo un nutriente cada uno. El único cambio que hay que
hacer es la eliminación de los nutrientes. Si hay menos nutrientes de lo que
se necesita, se consumen todos los que hay.
procedure AlimentarÁrboles(){
    /*  
    Propósito: alimentar los árboles de la parcela actual, se alimenta consumiento un nutriente
               cada árbol.Hay que eliminar  los nutrientes de la parcela que consumieron los árboles. 
               Si hay menos nutrientes de lo que se necesita, se consumen todos los que hay.
    Precondición:ninguna .
    Observación: llamamos parcela a una celda.
    */
    // la condicion:Si hay menos nutrientes de lo que se necesita, se consumen todos los que hay
}
c. ExplotarBomba(), que explota una bomba en la celda actual, eliminando
árboles. Al explotar, una bomba derriba 5 árboles en la celda actual y 3 en la
celda lindante al Norte. Si la celda actual está en el borde Norte, entonces
solo se eliminan los árboles de la celda actual. Atención que cuando haya
menos árboles de los que la bomba puede eliminar, entonces elimina los que
haya. La bomba se consume en el proceso, o sea, hay que eliminarla.
procedure ExplotarBomba() {
    /*
        PROPÓSITO: explota una bomba en la parcela actual eliminando árboles.
                   Al explotar, una bomba derriba 5 árboles en la parcela actual y 3 en la
                   parcela lindante al Norte. Si la parcela actual está en el borde Norte, entonces
                   solo se eliminan los árboles de la parcela actual. Atención que cuando haya
                   menos árboles de los que la bomba puede eliminar, entonces elimina los que
                   haya. La bomba se consume en el proceso, o sea, hay que eliminarla.
        PRECONDICIONES: debe existir una bomba en la celda actual.
        BSERVACIÓNES: llamamos parcela a una celda.
    */
     // consulta con Valeria.Tiene que ser como un cuento posta 
}

d. Polinizar(): los árboles en la celda actual polinizan la celda lindante en la
dirección Este, generando tantas semillas en esa celda como árboles haya
en la celda actual, menos 3. Por ejemplo, si en la celda actual hay 5 árboles,
se generan 2 semillas en la celda lindante al Este. Si en la celda actual hay
menos de 3 árboles, o no tiene lindante al Este, entonces no se hace nada.
procedure Polinizar() { 
    /*
        PROPÓSITO: polinizar la parcela lindante en la dirección Este, generando tantas 
                   semillas en esa parcela como árboles haya en la parcela  actual, menos 3
      
        PRECONDICIONES: ninguna.
        OBSERVACIÓNES: llamamos parcela a una celda.
    */
}

7.BIBLIOTECA Escribir las siguientes funciones, para agregarlas a la biblioteca.
a. esCeldaVacía(), que indica si la celda actual se encuentra vacía.
b. hayAlMenosUnaDeCada(), que indica si en la celda actual hay al menos
una bolita de cada color.
c. esCeldaConBolitas(), que indica si la celda actual tiene al menos una
bolita, de cualquier color.
function esCeldaVacía(){
    /* Proposito:  indica si la celda actual se encuentra vacía.
       Precondición: ninguna es una funcion total.
	  Tipo: Booleano.
       
    */
    return(not hayBolitas(Rojo) && not hayBolitas(Negro) && not hayBolitas(Azul) && not hayBolitas(Negro) )
}
function hayAlMenosUnaDeCada(){
    /* Proposito: indica si en la celda actual hay al menos una bolita de cada color.
	  Precondición: ninguna es una funcion total.
	  Tipo: Booleano.
    */
	return( hayBolitas(Rojo) &&  hayBolitas(Negro) &&  hayBolitas(Azul) &&  hayBolitas(Negro) )
}
function esCeldaConBolitas(){
    /*Proposito: indica si la celda actual tiene al menos una bolita, de cualquier color.
	 Precondición: ninguna es una funcion total.
	 Tipo: Booleano.
    */
	return( hayBolitas(Rojo) ||  hayBolitas(Negro) ||  hayBolitas(Azul) ||  hayBolitas(Negro) )
} 

9. Sobre el ejercicio “Soporte técnico” trabajado en la práctica anterior:
a. Modificar la solución propuesta para agregar funciones donde resulte
conveniente. ¿Qué ventajas se obtienen?
b.Modificar nuevamente la solución, teniendo en cuenta que ahora el
procedimiento RepararMáquina(), ya NO debe tener como precondición
que haya virus en la máquina actual, ya que podría haber tableros iniciales
donde algunas máquinas no se hubieran infectado, y no debe pasarse un
antivirus sobre una máquina que ya tiene la marca de Ok. Con este cambio,
¿el nombre del procedimiento debería seguir siendo el mismo?
-----SOPORTE TECNICO------
/* REPRESENTACIÓN DEL DOMINIO
   - los virus se representan con bolitas Rojas, de 1 a 6 
   - una indicación de que la máquina de la celda actual no 
     tiene virus (indicación de OK) se representa con una 
     bolita Verde
   - el Hall del edificio en la celda 0,0 con la cantidad de 
     pisos representada por las bolitas Azules
   - el Hall del piso en la celda del borde Oeste de cada piso, 
     con la cantidad de máquinas del piso representada por las 
     bolitas Negras 
*/
procedure RepararEdificioSiEsNecesario(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del edificio. 
         El cabezal queda en el Hall del último piso 
         del edificio (el hall más al Norte)
     PRECONDICIONES: ninguna
  */
  if( esElHall() && hayPisosParaReparar() ) then{
    repeat(nroBolitas(pisos())){
        PasarAlProximoPiso()
        RepararPisoSiEsNecesario()
    }   
  }
  else{
    RepararPisoSiEsNecesario()
  }
}
function esElHall(){
    /* 
     PROPÓSITO: indica si el cabezal esta en la celda 0,0.
     PRECONDICIONES: ninguna.
     TIPO: Booleano.
  */
  return (puedeMover(Norte) && puedeMover(Este))

}
function hayPisosParaReparar(){
    /* 
     PROPÓSITO: indica si hay pisos que necesiten reparacion.
     PRECONDICIONES: ninguna.
     TIPO: Booleano.
  */
  return (hayBolitas(pisos()))

}

function pisos(){
    /* 
     PROPÓSITO: describe el color con el que se representa los pisos de un edificio.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Azul)

}
procedure PasarAlProximoPiso(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar el proximo piso a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Norte)
}
procedure RepararPisoSiEsNecesario(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del piso actual
         (sacando todos los Virus de las máquinas del piso)
     PRECONDICIONES: 
       * la celda actual es el Hall del piso
  */
  if(esUnPisoConVirus()) then{
    repeat(nroBolitas(maquinaConVirus())){
        PasarAProximaMáquina()
        RepararMáquinaSiEsNecesario()
    }
    IrAlBorde(Oeste)
  }
}
function esUnPisoConVirus(){
    /* 
     PROPÓSITO: indica si un piso del edificio tiene algun virus.
     PRECONDICIONES: ninguna.
     TIPO: Booleano.
  */
  return (puedeMover(Este) && hayBolitas(maquinaConVirus()) )

}
function maquinaConVirus(){
    /* 
     PROPÓSITO: describe el color con el que se representa las maquinas con virus de un piso.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Negro)

}
procedure PasarAProximaMáquina(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar la proxima maquina a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Este)
}
procedure RepararMáquinaSiEsNecesario(){
  /* 
     PROPÓSITO: 
       * eliminar los virus de la celda actual y dejar 
         la marca de OK 
     PRECONDICIONES: 
       * en la celda actual hay una máquina con virus
         y sin marcas de OK
  */
  repeat(nroBolitas(virus())){
      Sacar(virus())
    }
  IndicarOk()
}
function virus(){
    /* 
     PROPÓSITO: describe el color con el que se representa los virus de una maquina.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Rojo)
}

procedure IndicarOk() {
  /* 
     PROPÓSITO: 
       * indicar que la máquina de la celda actual no tiene 
         virus poniendo la indicación de OK
     PRECONDICIONES: 
       * la máquina de la celda actual no tiene virus ni 
         indicación de OK
  */
  Poner(ok())
}
function ok(){
    /* 
     PROPÓSITO: describe el color con el que se representa  una maquina sin virus.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Verde)
}
/* LO QUE APRENDI--------
 Las funciones que agregue traen abstracciona al problema es suficiente con que retorne 
 solo el color???????????????'??!! <3
 Ya no necesitos SacarTodas_(colorASacar), ni Sacar_DeColor_(numero, color)!!!!!<3
 
*/

 10. ¡A la batalla!, parte 2
/* Escribir las siguientes funciones para el juego ¡A la batalla! de la práctica anterior,
donde en las celdas del tablero se representan Soldados (los aliados con una bolita
de color Negro y los enemigos con una bolita de color Rojo por cada soldado). */

/* a. colorAliado() y colorEnemigo() que describen el color de los aliados
y los enemigos, respectivamente. */
function colorAliado() {
    /*
    PROPOSITO: denota el color de los soldados aliados.
    RESULTADO: un Color.
    PRECONDICIONES: no tiene.
    */
    return (Negro)
}
function colorEnemigo() {
    /*
    PROPOSITO: denota el color de los soldados enemigos.
    RESULTADO: un Color.
    PRECONDICIONES: no tiene.
    */
    return (Rojo)
}
/* b. cantidadDeSoldadosDel_(colorDelEjército), que describe la
cantidad de soldados de la celda actual del ejército dado. */
function cantidadDeSoldadosDel_(colorDelEjército) {
    /*
    PROPOSITO: describe la cantidad de soldados del ejercito dado en la 
    celda actual.
    PARAMETROS:
        * colorDelEjército; un Color.
    RESULTADO: un Numero.
    PRECONDICIONES: no tiene.
    */
    
}
/* c. esCeldaIndefensa() que describe verdadero cuando no hay soldados
aliados en la celda actual. */
function esCeldaIndefensa() {
    /*
    PROPOSITO: indica si en la celda actual no hay soldados aliados.
    RESULTADO: un Booleano. Verdadero cuando en la celda actual no hayan
    soldados aliados. Falso en caso contrario.
    PRECONDICIONES: no tiene.
    */
   
}
/* d. estadoDeEmergencia() que describe verdadero solamente si existen más
de 100 soldados enemigos, y además la celda está indefensa. */
function estadoDeEmergencia() {
    /*
    PROPOSITO: indica si existen mas de 100 soldados enemigos y ademas la celda
    esta indefensa.
    RESULTADO: un Booleano. Verdadero cuando hayan mas de 100 soldados enemigos
    y la celda este indefensa. Falso en caso contrario.
    PRECONDICIONES: no tiene.
    */
    
}
/* e. haySuficientesAliadosARazónDe_PorCada_(cantidadDefensa,cantidadAtaque) 
que describe verdadero si hay por lo menos cantidadDefensa soldados aliados por cada 
cantidadAtaque soldados enemigos en la celda actual.
Pista: Piense en aplicar regla de tres simple donde:
cantidadDefensa de aliados --- cantidadAtaque de enemigos
X cantidad de aliados --- Y cantidad en celda enemigos */
function haySuficientesAliadosARazónDe_PorCada_(cantidadDefensa, cantidadAtaque) {
    /*
    PROPOSITO: indica si hay por lo menos **cantidadDefensa** soldados aliados por 
    cada **cantidadAtaque** soldados enemigos en la celda actual.
    PARAMETROS:
        * cantidadDefensa; un Numero, la cantidad de soldados aliados.
        * cantidadAtaque; un Numero, la cantidad de soldados enemigos.
    RESULTADO: un Booleano. 
    PRECONDICIONES: no tiene.
    */
   
}
/* f. aliadosNecesariosParaDefensaEficaz() que describe el número de
soldados aliados que faltan para defender la celda actual. Tener en cuenta
que en la celda actual puede ser que haya soldados, pero que es
precondición de esta función que no hay suficientes aliados. Recordemos
que 2 soldados enemigos pelean contra 3 soldados aliados y todos mueren */

function aliadosNecesariosParaDefensaEficaz() {
    /*
    PROPOSITO: describe el número de soldados aliados que faltan para defender
    la celda actual.
    RESULTADO: un Numero. 
    PRECONDICIONES: no deben haber suficientes aliados para defender la 
    celda actual.
    */
  // hacer una regla de tres simple ojo a lo que hay que tener en cuenta!!!!!!
    
  
}
/* 12)¿Vamos al banco? - Parte 1
En este ejercicio utilizaremos el tablero de Gobstones para representar cuentas
bancarias. Cada celda representará a una cuenta bancaria, y en cada una de ellas
puede haber dinero en distintas monedas, que representaremos con distintos
colores:
● bolitas negras para pesos argentinos.
● bolitas verdes para dólares estadounidenses.
● bolitas azules para euros.
● bolitas rojas para yuanes chinos.
Se pueden hacer tres operaciones: depósitos, extracciones y conversiones a divisa
extranjera. Las extracciones pueden hacerse en cualquier moneda, pero los
depósitos siempre serán en pesos.
En el caso en que se quiera depositar un monto en una moneda extranjera, se
aplicará automáticamente la conversión a pesos según el precio de venta dado en la
siguiente tabla:
Precios de venta
1 dólar -->80 pesos
1 euro -->90 pesos
1 yuan -->12 pesos
En cuanto a la conversión a divisa extranjera, el banco actualmente aplica las
siguientes tarifas para la compra de divisa:
Precios de compra
100 pesos -->1 dólar
115 pesos -->1 euro
17 pesos -->1 yuan
Realizar los siguientes procedimientos para poder manipular la cuenta:
c.Depositar_EnMoneda_ComoPesos(cantidadADepositar,moneda),
que dada una cantidad de dinero a depositar y un color que representa la
moneda en la que está representado ese monto, agrega a la cuenta la
cantidad de pesos equivalente a lo indicado para depositar. En este
procedimiento hay que aplicar la conversión indicada para el precio de venta.
Ej...
d. ExtraerHasta_EnMoneda_(cantidadAExtraer,moneda), que dada
una cantidad de dinero a extraer y un color que representa la moneda en la
que se va a extraer, remueve de la cuenta la cantidad que se indica. Si no
hubiera tanto dinero como el solicitado, se extrae todo lo que haya.
e.ConvertirHasta_PesosA_(pesosAConvertir,moneda), que dada
una cantidad de pesos a convertir y un color que representa la moneda en la
cual se quiere convertir, remueve los pesos de la cuenta y agrega la moneda
solicitada. Si en la cuenta hubiera menos pesos de lo solicitado, se convierte
todo lo que haya.
El último ejemplo es interesante: se piden convertir 100 pesos a dólares pero no hay
10 pesos en la cuenta, por lo que se va a intentar convertir el total de pesos que haya,
90. Con 90 pesos, no se llega a comprar ningún dólar, y como Gobstones solo trabaja
con números enteros, no es posible tener medio dólar, por lo que queda en cero
dólares.
f. RealizarCorridaCambiaria(), que dado un tablero de 1 única fila y 10
columnas, donde cada celda representa una cuenta bancaria, se realiza una
corrida cambiaria, donde en cada cuenta se cambia la totalidad de los pesos
a dólares.

13.¿Vamos al banco? - Parte 2
Continuaremos utilizando el mismo dominio del banco de la práctica anterior. Esta
vez, vamos a realizar funciones que nos permitan abstraernos de la representación
subyacente, así como simplificar cálculos en nuestras operaciones.
Se pide entonces que realice las siguientes funciones:
a. pesos() que describe el color con el que se representan los pesos en el
tablero, Negro.
b. dólares() que describe el color con el que se representan los dólares en el
tablero, Verde.
c. euros() que describe el color con el que se representan los euros en el
tablero, Azul.
d. yuanes() que describe el color con el que se representan los yuanes en el
tablero, Rojo.
e. ahorrosEn_(moneda) que dada una moneda, indica la cantidad de
unidades de esa moneda en la cuenta actual.
f. cuantosDolaresSePuedeComprarCon_Pesos(cantidadDePesos) que
indica la cantidad de dólares que se pueden comprar con una cantidad de
pesos dada.
g. cuantosEurosSePuedeComprarCon_Pesos(cantidadDePesos)
que indica la cantidad de euros que se pueden comprar con una cantidad de
pesos dada.
h. cuantosYuanesSePuedeComprarCon_Pesos(cantidadDePesos) que
indica la cantidad de yuanes que se pueden comprar con una cantidad de
pesos dada.
i. cuantosPesosSiVendo_Dólares(cantidadDeMonedaExtranjera)
que indica la cantidad de pesos a obtener si se venden (depositan) la
cantidad de dólares dada.
j. cuantosPesosSiVendo_Euros(cantidadDeMonedaExtranjera) que
indica la cantidad de pesos a obtener si se venden (depositan) la cantidad de
euros dada.
k. cuantosPesosSiVendo_Yuanes(cantidadDeMonedaExtranjera) que
indica la cantidad de pesos a obtener si se venden (depositan) la cantidad de
yuanes dada.
l.Vuelva a realizar los procedimientos de la práctica anterior, ahora utilizando
las funciones realizadas en los puntos anteriores.
Reflexionamos: ¿Cuánto esfuerzo conlleva cambiar la representación de Euros y Pesos, para
que ahora los primeros sean representados con bolitas negras y las segundas con azules.?
¿Cuántos lugares hubo que tocar? Sí la respuesta es más de 2, puede que no haya resuelto
bien los ejercicios.
*/
---REPECTICION CONDICIONAL----------------------
---EJERCICIOS INTRODUCTORIOS----------------
// Super Lucho 1.
procedure EncenderFilaDeLuces(){
    while (estáEnLaMeta()) {
        EncenderLuz()
        MoverALuchoAlEste()
    }    
}
// Super Lucho 2.
procedure EncenderLaFilaDeLuces(){
    /*...*/
    while(estáEnLaMeta()){ // funcion primitiva
        EncenderLaLuzSiHay()
    }
}
procedure EncenderLaLuzSiHay(){
    if(hayLuzApahada()) then{
        EncenderLuz() //procedure primitivo
        MoverALuchoAlEste() //procedure primitivo
    }
}
//Laberinto con queso recargado 
procedure SalirDelLaberintoComiendoQueso(){
    while(estoyEnLaSalida()){
        AvanzarUnPasoSiguiendoLaFlecha()
        ComerElQuesoSiHay()
    }
}
procedure AvanzarUnPasoSiguiendoLaFlecha(){
    if(laFlechaApuntaAlNorte())then {
        SacarLaFlecha()
        MoverAlRatónAl_(Norte)
    } elseif(laFlechaApuntaAlEste()){
        SacarLaFlecha()
        MoverAlRatónAl_(Este)
    }elseif(laFlechaApuntaAlSur()){
        SacarLaFlecha()
        MoverAlRatónAl_(Sur)
    }else{
        SacarLaFlecha()
        MoverAlRatónAl_(Oeste)
    }
}
procedure ComerQuesoSiHay() {
    if(hayqueso())then{
        ComerElQueso()
    }
}
procedure ComerElQueso(){
    Sacar(Verde)
}
---GUIA REPETICION CONDICIONAL Y RECORRIDOS ----------------------------

1.Definir el procedimiento IrAlBorde_(dirección), que lleva al cabezal al borde
dado por el parámetro dirección, SIN utilizar el comando primitivo IrAlBorde.
Dado que el único otro comando primitivo que permite mover el cabezal es Mover,
debe repetirse su uso hasta que se haya cumplido el propósito. ¿Cuál es la
condición que indica que el propósito se cumplió?*/
procedure IrAlBorde_(dirección){
    /*
        PROPÓSITO: ir a la primera celda de un recorrido
        PARÁMETROS:
            * dirPrincipal: Direccion, escribe la direcciona moverse.
            * dirSecundaria: Direccion, escribe la direcciona moverse.
        PRECONDICIONES: las direcciones dadas no deben ser opuestas y tampoco pueden ser iguales.
    */
    while(puedeMover(dirección)){
        Mover(dirección)
    }
}
2.Volver a definir el procedimiento SacarTodasLasDeColor_(colorASacar), que
quita todas las bolitas del color dado por el parámetro color de la celda actual,
pero esta vez SIN utilizar la expresión primitiva nroBolitas.*/
procedure SacarTodasLasDeColor_(colorASacar){
    /*Propósito: saca todas las bolitas de color "colorASacar" de la celda actual.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar de la celda.
    Precondicion: niguna.
         
         Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9.
   */
   while(hayBolitas(colorASacar)){
    Sacar(colorASacar)
   }
}
3.Considerar el procedimiento VaciarFilaDe_(color), que debe quitar todas las
bolitas del color dado por el parámetro color de cada una de las celdas de la fila
actual . El cabezal puede empezar en cualquier celda de la fila, y también puede 1
terminar en cualquier celda de la fila (ya sea celda inicial o cualquier otra).*/
/*a.Definir el procedimiento, como siempre, comenzando por establecer el contrato, y 
luego recién el código.

b.¿La solución dada funciona si el cabezal se encuentra en medio de una fila?
Si no es así, corregir el programa para que funcione en este caso también.

c.Al recorrer la fila, ¿en qué dirección se movió el cabezal? ¿Podría haberse
movido en la dirección opuesta?

d.A partir de la respuesta anterior, ¿de cuántas formas posibles se puede
realizar el recorrido de una fila?*/
procedure VaciarFilaDe_(color){
    /*Propósito: quitar todas las bolitas del color "color" de cada una de las celdas
      de la fila actual . El cabezal puede empezar en cualquier celda de la fila,y 
     también puede terminar en cualquier celda de la fila ya sea celda inicial o cualquier 
     otra.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar de la fila.
    Precondicion: ninguna.

     //  Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9, resolucion anterior.
   
    */
    IrAlBorde_(Oeste) //como es un recorrido por  puedefilas  ser Este tambien.
    while(puedeMover(opuesto(Oeste))){ //condiciona la repe
        SacarTodasLasDeColor_(color) // def en el punto anterior,tiene un whilw lo puwdo usar
        Mover(opuesto(Oeste))                                   // o estoy anidando whiles?????   
    }
    SacarTodasLasDeColor_(color)
}
4.En cada uno de los casos siguientes, definir de la forma indicada el procedimiento
VaciarTableroDe_(color), que quite todas las bolitas del color dado por el
parámetro color de cada una de las celdas del tablero. El cabezal puede empezar
en cualquier celda del tablero, y también puede terminar en cualquier celda del
tablero (ya sea la celda inicial o cualquier otra).

a.Estructurar el procedimiento como un recorrido sobre las filas . ¿Qué
2 subtareas van a precisarse en este caso? ¿Es necesario volver a definirlas o
se pueden encontrar en esta práctica?
procedure VaciarTableroDe_(color){
    /*Propósito: quitar todas las bolitas del color "color"  a partir de la celda actual . 
     El cabezal puede empezar en cualquier celda de la fila, y también puede terminar en cualquier celda 
     de la fila ya sea celda inicial o cualquier otra ya que es un recorrido por filas.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar del tablero.
    Precondicion: ninguna.
    Obsrvecion: es un recorrido por filas.
    */
   IrAlInicioDelTableroAl_YAl_(Este, Norte)
   while(hayProximoElementoAl_YAl_(Este,Norte)){
    VaciarFilaDe_(color)
    PasarAProximoElementoAl_Y_(Este, Norte)
   }
   VaciarFilaDe_(color)
}
procedure IrAlInicioDelTableroAl_YAl_(primerDireccion, segundaDireccion){
    /*
        Propósito: ir al inicio del tablero a partir de la celda actual.
        Precondicion:ninguna.
        Parametros: 
            *primerDireccion: Direccion, describe  la primer direccion a moverse.
            *segundaDireccion: Direccion, describe  la segunda direccion a moverse.
        COMO RECORRO POR FILAS PRIMERDIRECCION=ESTE Y SEGUNDADIRECCION= NORTE
    */
    IrAlBorde(opuesto(primerDireccion))
    IrAlBorde(opuesto(segundaDireccion))
}
function hayProximoElementoAl_YAl_(primerDireccion,segundaDireccion){
    /*
    Proposito: indica si esta en el final del recorrido.
    Precondicion: ninguna
    Tipo: Booleano.
    */
    return (puedeMover(primerDireccion) || puedeMover(segundaDireccion))

}
procedure PasarAProximoElementoAl_ Y_(primerDireccion, segundaDireccion){
    /*Proposito: pasar a la proxima fila a procesar.
     Precondicion: ninguna.
    
    while(finalDelRecorrido()){//Norte
        IrAlBorde(opuesto(Este))
        Mover(Norte)
    ESTO NO HACE NADA POR ESO TENGO QUE USAR UNIF???!!!!!!!OJO
    */
    if(puedeMover(primerDireccion)) then{
        Mover(primerDireccion)   
    }
    else{
        Mover(segundaDireccion)
        IrAlBorde(primerDireccion)
    }
}
b.Estructurar el procedimiento como un recorrido sobre las celdas del tablero.
Las subtareas necesarias serán diferentes, y puede ser que sea necesario
definir alguna que aún no está disponible en esta práctica.
procedure VaciarTableroDe_(color){
    /*Propósito: quitar todas las bolitas del color "color"  de un tablero a partir de la columna actual . 
     El cabezal puede empezar en cualquier celda de la columna, y también puede terminar en cualquier celda 
     de la columna ya sea celda inicial o cualquier otra ya que es un recorrido por columnas.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar del tablero.
    Precondicion: ninguna.
    */
   IrAlInicioDelTableroAl_YAl_(Este, Norte)
   while( hayProximoElementoAl_YAl_(Este,Norte)){
        VaciarColumnaDe_(color)// solo cambio esto del codigo, que ademas  solo le cambio las direcciones 
    PasarAProximoElementoAl_Y(Este, Norte)
   }
   VaciarColumnaDe_(color)
}
procedure VaciarColumnaDe_(color){
    /*Propósito: quitar todas las bolitas del color "color" de cada una de las celdas
      de la columna actual . El cabezal puede empezar en cualquier celda de la fila,y 
     también puede terminar en cualquier celda de la fila ya sea celda inicial o cualquier 
     otra.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar de la fila.
    Precondicion: ninguna.

     //  Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9, resolucion anterior.
   
    */
    IrAlBorde_(Sur) //como es un recorrido por columna puede ser Norte tambien 
    while(puedeMover(opuesto(Sur))){ //condiciona la repe
        SacarTodasLasDeColor_(color) // def en el punto anterior,tiene un whilw lo puwdo usar
        Mover(opuesto(Sur))                                   // o estoy anidando whiles?????   
    }
    SacarTodasLasDeColor_(color)
}
c.Reflexionar sobre las diferencias de los recorridos dados en los puntos a. y b.
¿Qué subtareas son más complejas en cada caso?
*Pasar a proximo fila requiere de un condicional, como no sabemos las cantidad de bolitas de cada 
celda que vamos a vacias ya que no queremos que esten representadas lo podemos resolver con una
repeticion condicional.

¿Podrían considerarse otros recorridos que no fueran sobre celdas o filas? 
*No consideriaria otros recorridos que no fueran por filas( hacia diferentes direcciones) o por
 celdas.

5.Considerar los recorridos por filas y por celdas del tablero realizados en el ejercicio
anterior, y en cada uno, las posibles direcciones en las que se realiza el
procesamiento.

a.En el caso del recorrido por filas, ¿cuántas posibilidades hay para recorrer
todas las filas (suponiendo que ya está hecho el procedimiento para procesar
una fila)? ¿Qué dato es el que cambia en cada caso?
*Cambia la direccion de inicio ya que podemos recorrer la ila de Oeste a Este  o de Este a Oeste.

b.En el caso del recorrido por celdas, ¿cuántas posibilidades hay para recorrer
todas las celdas?
*Cambia la direccion de inicio ya que podemos recorrer la ila de Sur  a Norte  o de Norte a Sur.

c.Volver a definir los recorridos por filas y por celdas del ejercicio anterior, pero
con diferentes direcciónes de recorrido.

6.Escribir el procedimiento VaciarFilaDe_HaciaEl_(color, dirección), que
generalice el recorrido de la fila, recibiendo la dirección de movimiento como
parámetro. ¿Cuáles son los valores posibles para el parámetro dirección? ¿Por
qué no puede ser cualquiera, si lo que se desea es recorrer una fila?
procedure VaciarFilaDe_HaciaEl_(color, dirección) {
    /*   //???????????????????????
        Procedimiento:vaciar la fila "color" hacia la "dirección".
                      El cabezal puede empezar en cualquier celda de la fila,y también puede 
                      terminar en cualquier celda de la fila ya sea celda inicial o cualquier 
                      otra.
        Parametros: 
        *dirección: Dirección, que describe la dirección hacia donde inicia el recorrido de la fila.
        *color: Color, es un color que describe el color de las bolitas a sacar.
        Precondicion: ninguna.
    */
    IrAlInicioDelRecorridoAl_(dirección) //como es un recorrido por columna puede ser Norte tambien 
    while(puedeMover(opuesto(dirección))){ //condiciona la repe
        SacarTodasLasDeColor_(color) // def en el punto anterior,tiene un whilw lo puwdo usar o estoy anidando whiles?????  
        Sacar_DeColor_(nroBolitas(color), color) // o mejor uso este????
        Mover(opuesto(dirección))                                    
    }
    SacarTodasLasDeColor_(color)
    Sacar_DeColor_(nroBolitas(color), color)    
}
7.BIBLIOTECA Escribir los procedimientos necesarios para generalizar la noción de
recorrido por celdas de un tablero, para que las direcciónes de recorrido no estén
fijas. En particular, definir (como siempre, comenzando por los contratos):

a.IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*   
        PROPÓSITO: ir a la primera celda de un recorrido
        PARÁMETROS:
            * dirPrincipal:Dirección, escribe la direcciona moverse.
            * dirSecundaria: Direccion, escribe la direcciona moverse.
        PRECONDICIONES: las direcciones dadas no deben ser opuestas y tampoco pueden ser iguales.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}
//b.haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPÓSITO: indica si hay una celda en las direcciones por "dirPrincipal" y "dirSecundaria". 
        PARÁMETROS:
            * dirprincipal: Direccion, describe la direccion a mover.
            * dirSecundaria: Direccion, describe la direccion a mover.
        PRECONDICIONES: las direcciones dadas no deben ser opuestas y tampoco pueden ser iguales.
        TIPO: Booleano.
    */
    return( puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}
//c.IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)  {
    /*
        PROPÓSITO: ir a la siguiente celda dada por las direcciones "dirPrincipal" y "dirSecundaria".
        PARÁMETROS:
            * dirPrincipal: Direccion - describe la direccion a mover.
            * dirSecundaria: Direccion - describe la direccion a mover.
        PRECONDICIONES: ninguna.
    */
    if(puedeMover(dirPrincipal))then{
        Mover(dirPrincipal)
    }
    else{
        Mover(dirSecundaria)
        IrAlBorde(opuesto(dirPrincipal))
    }
}
Al escribir las precondiciones, tener en cuenta que las direcciones no pueden ser
cualesquiera, sino que deben estar relacionadas… ¿Cuál es esa relación? ¿Cómo
expresarla?
Las direcciones dadas no deben ser contrarias y tampoco deben ser iguales.

8.EN PAPEL El caminante
Se puede modelar el paseo de un caminante por el tablero con las siguientes
consideraciones para la representación.

●El caminante está representado por una a cuatro bolitas azules. La dirección
de su paseo es Norte si es una bolita, Este si son dos, Sur si son tres y Oeste
si son cuatro.

●Las indicaciones de cambio de dirección se representan con bolitas verdes.
Si el caminante llega a una celda con una de estas indicaciones, debe
cambiar de dirección. La cantidad de bolitas verdes indica la nueva dirección,
con la misma representación de direcciones dadas para el caminante.

●El caminante deja una huella de bolitas negras a su paso, una por cada paso.

●La meta se representa con cualquier número de bolitas rojas. El paseo del
caminante termina si llega a la meta.

●La celda actual siempre se encuentra sobre el caminante.

●La única celda con bolitas azules es la del caminante.

●Todas las celdas tienen un máximo de 4 bolitas verdes.

●Las indicaciones llevan al caminante a la meta.

Como ayuda para guiar la división en subtareas, ya se realizó un análisis top-down
de la estrategia, y se eligieron ciertas subtareas. Se pide, entonces, implementar los
procedimientos y funciones que expresan dichas subtareas, que son los indicados a
continuación. Observar que en su gran mayoría, las tareas están presentadas en
forma top-down, por lo que es interesante mirarlas todas antes de empezar a
implementar, y definir todos los contratos antes de proceder a escribir el código de
cada una, ya que las de niveles más alto se pueden servir de las de niveles más
bajos. Además, puede tomarse la siguiente función como primitiva:
//function direcciónDelCódigo_(código)
/* PROPÓSITO: describir la dirección correspondiente al código dado
PRECONDICIONES: el código está entre 1 y 4
PARÁMETROS: código: Número. El número que codifica la dirección descripta
*/
Al escribir los contratos, no olvidar establecer las precondiciones necesarias (ya que
las mismas no siempre se explicitan en los enunciados).

a.caminante(), indicador(), huella() y meta(), que describen los
colores con los que se representa cada uno de los elementos nombrados.

b.LlevarAlCaminanteALaMeta() que, suponiendo que en el tablero está
representado un escenario válido para el caminante, lleva al caminante hasta
la meta.

c.estáEnLaMeta() que indica si el caminante está o no en la meta.

d.DarUnPaso() que realiza un paso en el paseo del caminante, de acuerdo a
las siguientes reglas:

i.Si el caminante ya llegó a destino, no hay nada que hacer.

ii.Si hay que cambiar la dirección, lo hace.

iii.Finalmente, se mueve en la dirección correspondiente.

No hay que olvidar que el caminante debe dejar una huella. En la Figura 1 se
ofrece un ejemplo del uso de DarUnPaso() en medio de la ejecución del
programa.

e.CambiarDeDirecciónSiHayIndicador() que cambia la dirección del
caminante cuando se encuentra con un indicador.
f.DejarHuella() que deja una huella en la celda actual.
g.MoverAlCaminanteAl_(dirección) que mueve al caminante un paso en
la dirección dada.

h.hayIndicadorDeCambioDeDirección() que describe verdadero cuando
en la celda actual hay un indicador de dirección.

i.direcciónIndicada() que describe la dirección en la que está mirando
el caminante.

j.Cambiar_ParaImitar_(colorACambiar,colorAImitar) que
cambia la cantidad de bolitas de colorACambiar según la cantidad de
bolitas de colorAImitar que haya en la celda actual.

k.Mover_Bolitas_Al_(cantidad,color,dirección) que “mueve”
(es decir, quita de una celda para llevar a la otra) la cantidad indicada de
bolitas de color a la celda lindante en la dirección dada, y deja el
cabezal en esa celda. Suponer que hay una celda lindante en esa dirección.

9. Distribución de mercadería
Se desea modelar el movimiento de mercadería en una sencilla red de depósitos,
que tiene un depósito central, más un depósito local para cada punto cardinal. Para
esto, se va a representar en el tablero un mapa muy simplificado.

● Tres bolitas negras marcan el depósito central,

● dos bolitas negras marcan un depósito local,

● una bolita negra marca el camino de central a local,

● cada bolita azul marca una unidad de mercadería.

Los depósitos locales forman una cruz, donde el centro es el depósito central. No se
sabe a qué distancia están los depósitos locales del depósito central. Este es un
ejemplo de modelo:
Escribir
a.esDepósitoCentral() y esDepósitoLocal() que indican si el cabezal
está, respectivamente, en el depósito central o en un depósito local.
function esDepósitoCentral(){
    /*
        Propósito: indican si el cabezal está en el depósito central.
        Precondición: ninguna.
        Tipo: Booleao.
    */
    return( nroBolitas(Negro) == 3)
}
function esDepósitoLocal(){
    /*
        Propósito: indican si el cabezal está en el depósito local.
        Precondición: ninguna.
        Tipo: Booleao.
    */
    return( nroBolitas(Negro) == 2)
}
function esCaminoADeposito(){
    /*
        Propósito: indican si el cabezal está en elcamino de un depósito a otro.
        Precondición: ninguna.
        Tipo: Booleao.
    */
    return( nroBolitas(Negro) == 1)
}
function numeroDeMercaderia(){
    /*
        Propósito: describe una unidad de mercaderia .
        Precondición: ninguna.
        Tipo: Numero, describe una unidad de mecaderia.
    */
    return( nroBolitas(Azul))
}
b.IrDeCentralAlLocal_(dirección), que mueve el cabezal del depósito
central al depósito local que está en la dirección dada, suponiendo que el
cabezal comience en el depósito central.
procedure IrDeCentralAlLocal_(dirección){
    /*
        Propósito: mueve el cabezal del depósito central al depósito local 
        que está en la "dirección" dada, el cabezal comienza el depósito central.
        Prencondición: debe haber un deposito en la direccion dada.
        Parametros:
         *dirección: Direccion, describe la direccion hacia donde se va a 
          mover el cabezal en el recorrido.
    */ 
    Mover(dirección) //  OJo si o si me tengo que mover para iniciar
    while(esCaminoADeposito()){ //condiciona la repe
        Mover(dirección) 
    }
}
c.IrDelLocal_ACentral(dirección), que mueve el cabezal al depósito
central, suponiendo que el cabezal está en el depósito local que está en la
dirección dada.
Aclaración: si se pide IrDelLocal_ACentral(Sur), quiere decir que el
cabezal está en el depósito Sur, por lo tanto, debe moverse hacia el Norte.
Antes de seguir, un ejemplo de uso de estos dos procedimientos. A partir del tablero
que se mostró, IrDeCentralAlLocal_(Sur) deja el cabezal en el depósito local
Sur, o sea:
A partir de este tablero, IrDelLocal_ACentral(Sur) “vuelve” al tablero inicial, o
sea, el cabezal va al depósito central.
procedure IrDelLocal_ACentral(dirección){
    /*
        Propósito: muever el cabezal al depósito central, suponiendo que el 
        cabezal está en el depósito local que está en la dirección dada. 
        Prencondición: ninguna.
        Parametros:
         *dirección: Direccion, describe la direccion hacia donde se va a 
          mover el cabezal en el recorrido.
    */
    Mover(opuesto(dirección)) //  OJo si o si me tengo que mover para iniciar
    while(esCaminoADeposito()){ //condiciona la repe y este cso procesa elemento
        Mover(opuesto(dirección) ) //pasa a prox elemento y procesa
    }
}
d.Llevar_MercaderíasAlLocal_(cantidad,dirección), que lleva la cantidad de mercadería indicada del depósito central al depósito local
que está en la dirección indicada. Si en el depósito central no hay suficiente
cantidad de mercadería, no se hace nada. Se puede suponer que el cabezal
está en el depósito central, y debe dejarse en el mismo lugar.
Por ejemplo a partir del tablero inicial dado como ejemplo,
Llevar_MercaderíasAlLocal_(3, Sur) tiene este efecto:
procedure Llevar_MercaderíasAlLocal_(cantidad,dirección) {
    /*
        PROPÓSITO: lleva la cantidad de mercadería indicada "cantidad" del depósito central al depósito local
        que está en la dirección indicada "dirección".
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia.
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna.
    */
    Preparar_SiHayMercaderiasParaElLocal_(cantidad, dirección)
    while(esCaminoADeposito()){ //condiciona la repe y este cso procesa elemento
        Mover(dirección)  //pasa a prox elemento y procesa
    }
    Recibir_MercaderiasYVolverAlCentral_(cantidad, dirección)
}
procedure Preparar_SiHayMercaderiasParaElLocal_(cantidad, dirección) {
    /*
        PROPÓSITO: mandar (quita del stock) si hay  una mayor o igual "cantidad" de unidades d mercaderia
        del deposito Central al inicio del camino al deposito Local, sino no hace nada.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia.
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    if(numeroDeMercaderia() >= 3) then{
        Sacar_DeColor_(3,Azul)
        Mover(dirección)
    }    
}
procedure Recibir_MercaderiasYVolverAlCentral_(cantidad, dirección) {
    /*
        PROPÓSITO: mandar (quita del stock) si hay  una mayor o igual "cantidad" de unidades d mercaderia
        del deposito Central al inicio del camino al deposito Local.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia. 
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    Poner_DeColor_(cantidad,Azul)
    IrDelLocal_ACentral(dirección)   
}    
e.Traer_MercaderíasDelLocal_(cantidad, dirección), que lleva la cantidad de mercadería 
indicada del depósito local en la dirección
indicada, al depósito central. Si en el depósito local indicado no hay suficiente
cantidad de mercadería, no se hace nada. Se puede suponer que el cabezal
está en el depósito central, y debe dejarse en el mismo lugar. Por ejemplo, a
partir del tablero inicial, Traer_MercaderíasDelLocal_(3, Sur) tiene
este efecto:
procedure Traer_MercaderíasDelLocal_(cantidad,dirección){
    /*

    */
    Recibir_MercaderiasDelLocal_(cantidad, dirección)
    while(esCaminoADeposito()){ //condiciona la repe y este cso procesa elemento
        Mover(opuesto(dirección) ) //pasa a prox elemento y procesa
    }
    Preparar_MercaderiasAlLocal_(cantidad, dirección)
}
procedure Preparar_MercaderiasAlLocal_(cantidad, dirección) {
    /*
        PROPÓSITO: del camino al deposito Local.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia.
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    if(esMercaderia() >= 3) then{
        Sacar_DeColor_(3,Azul)  
    }
    IrDelLocal_ACentral(dirección)        
}
procedure Recibir_MercaderiasDelLocal_(cantidad, dirección) {
    /*
        PROPÓSITO: mandar (quita del stock) si hay  una mayor o igual "cantidad" de unidades d mercaderia
        del deposito Central al inicio del camino al deposito Local.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia. 
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    Poner_DeColor_(cantidad,Azul)
    IrDelLocal_ACentral(dirección)
}
f.Mover_MercaderíasDelLocal_AlLocal_(cantidad,origen,destino), que mueve la cantidad
 indicada de mercadería del depósito local que está en dirección origen al que está en 
dirección destino. Si en el depósito origen no hay la cantidad de mercadería necesaria, 
no se hace nada.
Por ejemplo, a partir del tablero inicial, Mover_MercaderíasDelLocal_AlLocal_(3,Este,Sur) 
tiene este efecto:
procedure Mover_MercaderíasDelLocal_AlLocal_(cantidad,origen,destino) {
    /*
        PROPÓSITO: mover  la "cantidad" de mercaderia del deposito local que esta en "origen"
        al que esta en direccion "destino".Si en el depósito origen no hay la cantidad de mercadería necesaria, 
        no se hace nada.
        PARÁMETROS:
            * parámetro1: Numero - describe el numero de mercaderia a mover entre los depositos.
            * parámetro2: Direccion - describe la  primer direccion  a mover del deposito Local.
            * parámetro2: Direccion - describe la  segunda direccion  a mover del destino del  deposito Local.
        PRECONDICIONES: ninguna.
    */
    Traer_MercaderíasDelLocal_(cantidad,origen)
    Llevar_MercaderíasAlLocal_(cantidad,destino)
}
10.En este ejercicio el tablero tiene información sobre las apuestas de diferentes
jugadores en un casino, para un juego de extracción de números. En la mesa del
juego hay una cantidad de jugadores, cada uno identificado por un número. Cada
celda del tablero representa una apuesta, de la siguiente forma.
●Bolitas rojas: el número de jugador.
●Bolitas azules: el número apostado.
●Bolitas verdes: el monto apostado, donde cada bolita verde es un peso.

Puede haber varias apuestas del mismo apostador, a distintos números.
A modo de ejemplo, se muestra uno de los posibles tableros que modela la siguiente
situación:
●El jugador 1 apostó 19 pesos al 48.
●El jugador 2 apostó 22 pesos al 7 y 13 pesos al 13.
●El jugador 3 apostó 5 pesos al 15.
●Queda espacio para registrar dos apuestas más.
Escribir las siguientes operaciones. En cada caso, recordar escribir primero el
contrato, y expresar la estrategia usando subtareas (preferentemente con la
metodología top-down).

a.AgregarApuestaDe_Al_Para_(monto, nroApostado, nroJugador)
que agrega la apuesta indicada en alguna celda vacía, la cual debe existir.

b.PagarYCobrarAl_(nroQueSalió),que pague las apuestas que certaron, y retire el total 
del dinero de las que no acertaron (solamente el dinero).
Se paga 5 veces el monto de la apuesta; por ejemplo, para una
apuesta de 3 pesos se pagan 15, quedando 18 pesos en la celda.

c.RecogerPropinas(), que extrae un peso de cada celda donde haya al
menos 15 pesos.

d.SeVaElJugador_(nroJugador), que borra todas las celdas que registran
una apuesta del jugador indicado.

e.DuplicarApuestasAl_(nroApostado), que duplica el monto de las
apuestas al número indicado.

f.DuplicarApuestasDelJugador_(nroJugador), que duplica el monto
de las apuestas que hizo el jugador indicado.

g.CambiarNroApostadoDel_Al_(nroAnterior, nroNuevo), que
cambia todas las apuestas de nroAnterior para que pasen a apostar a
nroNuevo.

h. AumentarEn_LaApuestaDelJugador_Al_(monto,nroJugador,nroApostado), que agrega el 
monto indicado a la apuesta de este jugadoral número dado.

i.BuscarApuestaDelJugador_Al_(nroJugador, nroApostado), que
posiciona el cabezal en una celda que sea el registro de una apuesta del
jugador y número apostado indicados. Si no se ha registrado una apuesta
con estas características, el cabezal debe ubicarse en el extremo noreste.

--EJERCICION INTRODUCTORIOS VARIABLES Y FUNCIONES CON PROCESAMIENTO------



--GUIA VARIABLES ,RECORRIDOS DE ACUMULACION Y  FUNCIONES CON PROCESAMIENTO.
1.Escribir la función hayBolitas_EnElBorde_(color, dirección), que indica
si en la celda que se encuentra en el borde dado por la dirección, hay bolitas del
color indicado.
function hayBolitas_EnElBorde_(color, dirección) {
    /*
        PROPÓSITO: indica si en la celda que se encuentra en el borde dado por la dirección "direccion", 
        hay bolitas del color "color"
        Indica si hay bolitas en color dado en el borde dado
        PARÁMETROS:
            * parámetro1: tipo - descripción.
            * parámetro2: tipo - descripción.
        PRECONDICIONES: ninguna
        Tipo: Booleano.
    */
    IrAlBorde(dirección)
    return ((hayBolitas(color)))  
}
2.BIBLIOTECA Escribir la función tieneBolitas_Al_(color, dirección), que,
suponiendo que existe una celda lindante en la dirección dada, indica si la misma
tiene o no bolitas del color indicado
function tieneBolitas_Al_(color, dirección){
     /*
        PROPÓSITO: suponiendo que existe una celda lindante en la dirección "direccion", indica si en la celda que
         se encuentra en el borde dado por la dirección "direccion", hay bolitas del color "color"
        PARÁMETROS:
            * color: Color - describe el color de las bolitas que hay.
            * direccion: Direccion - describe la direccion hacia donde va a chequear  si hay bolitas 
        PRECONDICIONES: debe existir una celda en direccion "direccion"
        Tipo: Booleano.
    */
    Mover(dirección)
    return(hayBolitas(color))
}
3.BIBLIOTECA Escribir la función hayBolitas_Al_(color,dirección), que
indica si hay una celda lindante en la dirección indicada y la misma 
tiene bolitas del color dado.
function hayBolitas_Al_(color,dirección){
     /*
        PROPÓSITO: indica si en la celda que se encuentra en el borde dado por la dirección "direccion", hay bolitas del color "color"
        PARÁMETROS:
            * color: Color - describe el color de las bolitas que hay.
            * direccion: Direccion - describe la direccion hacia donde va a chequear  si hay bolitas 
        PRECONDICIONES: debe existir una celda en direccion "direccion"
        Tipo: Booleano.
    */
    return( puedeMover(dirección) && tieneBolitas_Al_(color, dirección))
}
4.Escribir las funciones máximoEntre_Y_(valor1, valor2),
mínimoEntre_Y_(valor1,valor2) que describen el valor más grande o más
chico, respectivamente, de los valores dados. ¿Qué herramienta hace falta? Si el
código resultante utiliza una función con procesamiento, ofrecer otra versión que no
utilice solamente funciones sin procesamiento.
function máximoEntre_Y_(valor1, valor2) {
    /*
    PROPOSITO: describe el valor mas grande de los dados.
    PARAMETROS:
        * valor1; un valor de cualquier tipo, representa el primer valor a verificar.
        * valor2; un valor de cualquier tipo, representa el segundo valor a verificar.
    RESULTADO: un valor del Tipo dado.
    PRECONDICIONES: 
        * los valores dados deben ser del mismo tipo.
    */
    return (
        choose valor1 when (valor1 >= valor2) //condicion,el valor1 es mas grande que valor2
               valor2 otherwise
    )
}

function mínimoEntre_Y_(valor1,valor2) {
    /*
    PROPOSITO: describe el valor mas chico de los valores dados.
    PARAMETROS:
        * valor1; un valor de cualquier tipo, representa el primer valor a verificar.
        * valor2; un valor de cualquier tipo, representa el segundo valor a verificar.
    RESULTADO:un valor del Tipo dado.
    PRECONDICIONES:
        * los valores dados deben ser del mismo tipo.
    */
    return (
        choose valor1 when (valor1 <= valor2)
               valor2 otherwise
    )
}
5. Escribir la función nroBolitas_EnLaFilaActual(color) que describa la
cantidad de bolitas del color dado en la fila actual.

a. Escribir la solución con un recorrido de la fila actual que utilice una variable
cantidadDeBolitasYaVistas cuyo propósito sea describir la cantidad
de bolitas del color correspondiente que se contaron en cada momento.
¿Cuántas se vieron antes de empezar a contar? ¿Cómo estar seguro que se
consideraron todas las celdas para contarlas?
function  nroBolitas_EnLaFilaActual(color){
     /*   
        PROPÓSITO: describe el numero de bolitas del color "color" de la fila actual.
        PARÁMETROS:
            * color: Color - describe el color de las bolitas a contar.
          
        PRECONDICIONES: ninguna
        Tipo: Numero, describe el numero total de bolitas "color" de la fila actual.
    */
    cantidadDeBolitasYaVistas := 0  // inicio el contdor
    while(puedeMover(Este)){
        Mover(Este)
        cantidadDeBolitasYaVistas := cantidadDeBolitasYaVistas + nroBolitas(color)
    }
    cantidadDeBolitasYaVistas := cantidadDeBolitasYaVistas + nroBolitas(color) // caso de borde
    return(cantidadDeBolitasYaVistas)
}
b. ¿En qué celda queda el cabezal al utilizar la función desde cualquier punto
del programa? ¿Por qué?

En la celda de inicio ya que el recorrido de busqueda del numero de  bolitas Rojo es imaginario  o sea que no se mueve de la celda de inicio
para buscar el numero de bolitas rojas.

6.Escribir las funciones nroFilas() y nroColumnas() que describan la cantidad de
filas y columnas del tablero. ¿Se podría conocer la cantidad de filas o columnas del
tablero sin que el cabezal se mueva realmente de la celda actual?
Si se puede con una funcion con procesamiento como la de la  resolucion.
¿Qué habría que usar si hubiese que hacerlo exclusivamente con procedimientos?
Subtareas???
function nroFilas(){  
    /*
        PROPÓSITO: describe el  numero de filas de un tablero.
          
        PRECONDICIONES: ninguna
        Tipo: Numero, describe el numero de filas de un tablero
    */
   numeroDeFilas := 0 // Inicio el procesamiento
    while(puedeMover(Este) && puedeMover(Norte)){ // condiciono la repe
        Mover(Norte) // mueve para que no de error el while 
        numeroDeFilas := numeroDeFilas + 1  // procesa elemento(cuenta la fila)
    }
    return(numeroDeFilas)
}
function nroColumnas(){  
    /*
        PROPÓSITO: describe el  numero de columnas de un tablero.
          
        PRECONDICIONES: ninguna
        Tipo: Numero, describe el numero de filas de un tablero
    */
    numeroDeColumnas := 0 // por que siempre va existir una fila.
   
    while(puedeMover(Norte) && puedeMover(Este)){
        Mover(Este)
        numeroDeColumnas := numeroDeColumnas + 1 
    }
    return(numeroDeColumnas)
}
7.Escribir la función distanciaAlBorde_(dirección), que describe la cantidad de
celdas que hay entre la celda actual y el borde indicado. Observación: si la celda
actual se encuentra en el borde, la distancia es 0.
function distanciaAlBorde_(dirección){
    /*
        PROPÓSITO: describe el  numero de celdas que hay entre la celda actual y el borde "dirección".
          
        PRECONDICIONES: ninguna
        Tipo: Direccio, describe la direccion hacia donde se va a medir la distancia. 
    */
    distanciaHaciaElBorde := 0 // inicio el procesamiento
    while(puedeMover(dirección)){  // condiciono la repe
        Mover(dirección)                                    // proceso elemento
        distanciaHaciaElBorde := distanciaHaciaElBorde + 1 // proceso elemnto
    }
    return(distanciaHaciaElBorde)
}
8. Escribir las funciones coordenadaX() y coordenadaY() que retornen la
coordenada columna y la coordenada fila de la celda actual, respectivamente.
Suponer que 0 es la coordenada de la primer fila y columna. ¿Es necesario escribir
un recorrido para estas funciones, o puede reutilizarse alguna otra función ya
hecha?
Se puede usar la funcion echa en el punto anterior ya que parametriza las direcciones de 
los bordes a los que me puedo dirigir.
function coordenadaX(){
     /*
        PROPÓSITO: describe el  numero de la coordenada X a partir de la celd actual.
          
        PRECONDICIONES: la celda de inicio es la coordenada de la primer fila y columna 0,0.
        Tipo: Numero, describe la coordenada X de un eje. 
    */
    return(distanciaAlBorde_(Este))
}
function coordenadaY(){
     /*
        PROPÓSITO: describe el  numero de celdas que hay entre la celda actual y el borde "dirección".
          
        PRECONDICIONES: ninguna
        Tipo: Direccio, describe la direccion hacia donde se va a medir la distancia. 
    */
    return(distanciaAlBorde_(Norte))
}
9. El bosque, parte 3

a.Escribir las funciones árbol(), semilla(), bomba(), nutriente() que
describen las representaciones de los elementos del ejercicios “El bosque”,
de las prácticas 4 y 5.
function semilla() {
    /*
    PROPOSITO: denota un el color de la semilla.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Rojo)
}
function arbol() {
    /*
    PROPOSITO: denota un el color del arbol.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Verde)
}
function bomba() {
    /*
    PROPOSITO: denota un el color de la bamba.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Negro)
}
function Nutriente() {
    /*
    PROPOSITO: denota un el color del nutriente.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Azul)
}
b.Escribir la función nroTotalDeÁrbolesEnElTerreno() que describa la
cantidad de árboles que hay en el bosque. Organizar el código como un
recorrido genérico sobre las parcelas instanciado para el sentido Sur-Oeste.
function  nroTotalDeÁrbolesEnElTerreno(){
     /*
    PROPOSITO: describe la cantidad total de árboles que hay en el bosque.
    RESULTADO: un Numero.
    PRECONDICIONES: las direcciones no pueden opuestas ni iguales.
    OBSERVACION: se realizará un recorrido genérico sobre las parcelas en 
    sentido Sur-Oeste.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte) //va al inicio del recorrido
    numeroDeArbolesYaContados := 0               // inicia el contador
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){ // si cumple cond, osea si hay siguiente celda para procesar para ver si hay arbol
        numeroDeArbolesYaContados := numeroDeArbolesYaContados + nroBolitas(arbol()) // procesa arbola cuenta las bolitas Verde porque el numero represntan los arboles
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)                            // pasa al prox arbol y aprte para que funcione el while
    }
    numeroDeArbolesYaContados := numeroDeArbolesYaContados + nroBolitas(arbol())   // OJOOOO  caso de borde 
    return(numeroDeArbolesYaContados )                       
}
10. Escribir una función nrovacias() que describa la cantidad de celdas vacias del
tablero. Estructurar el código como recorrido de celdas.
Con respecto al código:recordar que no es buena práctica anidar herramientas en el mismo
procedimiento o función. ¿Cómo hacer, entonces, para aumentar la cantidad de
vacias en cada momento, dado que la variable solo puede modificarse de forma local?
function nroVacias(){
     /*
    PROPOSITO: describe la cantidad de celdas vacias del tablero.
    RESULTADO: un Numero.
    PRECONDICIONES: las direcciones no pueden opuestas ni iguales.
    OBSERVACION: se realizará un recorrido genérico sobre las parcelas en 
    sentido Sur-Oeste.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte) // inicio el recorrido
    numeroDeCeldasVaciasYaVistas := 0              // inicio el contador
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){ //cond repe se mueve miestars hay celdas al este y al NOrte.
        numeroDeCeldasVaciasYaVistas :=  
            numeroDeCeldasVaciasYaVistas +  unoSi_CeroSino(esCeldaVacia()) // proceso celda esta vez con el COND EL CONTEO // funcion biblioteca
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    numeroDeCeldasVaciasYaVistas +  unoSi_CeroSino(esCeldaVacia())
    return(numeroDeCeldasVaciasYaVistas)
}
function unoSi_CeroSino(condicion) { // funcion de biblioteca
    /*
    PROPOSITO: describe un uno si hay una celda vacia, y un cero en 
    caso contrario.
    PARAMETROS:
        * condición; tipo Booleano, representa la condicion a evaluar.
    RESULTADO: un Numero.
    PRECONDICIONES: no tiene.
    */
    return (
        choose 1 when (esCeldaVacia()) // funcion Biblioteca
               0 otherwise
            )
}
Ayuda: considerar una función que devuelva la cantidad de celdas vacias que hay
considerando solamente la celda actual… (Observar que esa cantidad solamente
puede ser 1 o 0.)

11. Escribir una función colorMínimoConBolitas() que denote el color más chico
(en el orden Azul, Negro, Rojo, Verde) del cual hay bolitas en la celda actual.

a. Considerar primero el contrato. ¿Qué ocurre si en la celda actual no hay
bolitas de ningún color?
No funciona  ya que no hay bolitas de ningun color para evaluar la condicion entre los colores.

b. Escribir la solución organizada como un recorrido de búsqueda sobre los
colores que use una variable colorActual cuyo propósito sea denotar el
color que se está recorriendo.
function colorMínimoConBolitas(){
    /*
        Proposito: denote el color más chico de la celda actual.
        Precondicion: debe existir al menos una bolita de algun  color.
        Tipo: Color.
        Observacion: es un recorrido de busqueda sobre colores.

    */
    colorActual := minColor()  // inicio el recorrido buscando el color mini
    while(not hayBolitas(colorActual)){ // sino hay color minimo
        colorActual := siguiente(colorActual) // declaro al prox color que hay como mini
    }
    return(colorActual)
}

c. ¿La solución funciona si se agregan más colores a Gobstones? En caso
negativo, modificar la solución para que funcione con cualquier cantidad de
colores.
Funciona para cualquier color que elija.

Ayuda: considerar utilizar las expresiones primitivas minColor() y maxColor() que 
describen al color más chico y al color más grande posibles.

12. Nova enfrentó su primer revisión de pares de su código, y no le fue muy bien. Los
nombres de la mayoría de las funciones que escribió son letras sueltas, que no
aportan legibilidad, ¡y encima no escribió los contratos de ninguna de las funciones!
(El caradura puso los comentarios con puntitos. Se vé que vio en el código de
algunos colegas algo parecido, y no se dio cuenta que en realidad el editor permite
colapsar secciones y las muestra con puntitos. Por suerte indenta bien, porque si no,
sería mucho más catastrófico…)
El revisor estuvo escribiendo los propósitos para cada función, pero lo hizo en una
serie de post-its (los cuadraditos de papel sueltos) y se mezclaron todas.

a.Corresponder las siguientes propuestas de propósito hechas por el revisor,
con las funciones correspondientes.

A. Describir el color del cual hay más bolitas en la celda actual.

B. Describir la cantidad de bolitas de la que hay más entre las bolitas de
los colores dados.

C. Describir la cantidad de bolitas del color dado que tiene el tablero.

D. Describir la cantidad total de bolitas de todos los colores de la celda
actual.

E. Describir el color de entre los dados que tiene más bolitas en la celda
actual.

F.Describir cuál es la mayor cantidad de bolitas del color dado que tiene
alguna celda del tablero.

G. Describir el mayor de dos valores dados.


b.Una vez hecha la correspondencia, renombrar las funciones, parámetros (y
sus usos) de manera adecuada, para que el programa resulte legible.

15. Escribir un procedimiento IrANésimaVacía_(n) que posicione el cabezal en la
celda vacía número n que se encuentra en un recorrido del tablero por celdas en las
direcciones Este y Norte. Si no hay suficientes celdas vacías, deja el cabezal en la
esquina NorEste.
Por ejemplo, IrANésimaVacía_(1) posiciona el cabezal en la primer celda vacía,
IrANésimaVacía_(2) posiciona el cabezal en la segunda celda vacía, etc.
Organizar la solución como un recorrido de búsqueda por celdas que utilice una
variable celdasVacíasYaVistas, cuyo propósito sea denotar la cantidad de
celdas vacías que ya se recorrieron.
procedure IrANésimaVacía_(n) {
    /*
        PROPÓSITO: posiciona el cabezal el en la celda numero "n".
        PARÁMETROS:
            * n: NUmero - describe el numero de  celda
        PRECONDICIONES: ninguna 
        Observacion: recorrido de 
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeCeldasVaciasVistas := 0
    while( haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && cantidadDeCeldasVaciasVistas /= n ){
        cantidadDeCeldasVaciasVistas := cantidadDeCeldasVaciasVistas + unoSiCeroSino(esCeldaVacía())// cuenta si esta vacia 
        MoverSiSonDistintas__(cantidadDeCeldasVaciasVistas, n)  // mueve solo si 
    }    
}
procedure MoverSiSonDistintas__(valor1, valor2){
    if(valor1 /= valor2){
            IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)    
     }
}
function unoSi_CeroSino(condicion){
    return(choose 1 when (condicion)
                  0 otherwise
          )
}
----opcion2--------------
procedure IrANésimaVacía_(n) {
    /*
        PROPÓSITO: posiciona el cabezal el en la celda numero "n".
        PARÁMETROS:
            * parámetro1: NUmero - describe el numero de  celda
        PRECONDICIONES: ninguna 
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeCeldasVaciasVistas := unoSi_CeroSino(esCeldaVacia())
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && cantidadDeCeldasVaciasVistas /= n ){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        cantidadDeCeldasVaciasVistas := cantidadDeCeldasVaciasVistas + unoSi_CeroSino(esCeldaVacia())
         MoverSi__SonDistintos(cantidadDeCeldasVaciasVistas,n)
    }    
}
procedure MoverSi__SonDistintos(valor1, valor2 ){
    if(valor1 /= valor2){
            IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)    
        }
}
function unoSi_CeroSino(condicion){
    return(choose 1 when (condicion)
                  0 otherwise
          )
}

16. La torre de control
En este ejercicio las columnas del tablero representan canales aéreos por los que
despegan y aterrizan aviones. Se considera que un canal está libre para aterrizar si
no hay avión en ninguna de las posiciones de ese el canal. Los aviones se
representan con tantas bolitas azules como el número de su vuelo, y con una bolita
Roja en la misma celda si está aterrizando o con una bolita Verde si está
despegando. El tablero representa a todo el aeropuerto; en cada celda hay a lo
sumo un avión. Implementar las siguientes operaciones:

a.La función cantidadDeCanalesLibres(), que devuelva la cantidad de
canales sin aviones.

b.La función cantidadDeAvionesDespegando(), que devuelva la cantidad
total de aviones que están despegando en todo el aeropuerto.

c.El procedimiento IrACanalLibreParaDespegar(), que deje el cabezal
en el primer canal libre más cercano al Sureste del aeropuerto.

d.La función cantidadDeAvionesTotales(), que devuelva la cantidad
total de aviones que están despegando/o aterrizando en todo el aeropuerto.

e.El procedimiento IrACanalLibreParaAterrizar(), que debe dejar al
cabezal en el primer canal libre más cercano al Noroeste del aeropuerto.

f.La función cantidadDeCanalesConColisiónInminente(), que devuelva la cantidad de carriles con posibles colisiones en todo el
aeropuerto. Se considera que hay una colisión posible si en el mismo carril hay un avión que está despegando debajo de un avión
que está aterrizando.

g.El procedimiento IrACanalConColisiónInminente(), que deje el cabezal en el primer Carril con una colisión inminente (desde el extremo
Suroeste del aeropuerto).

h. La función mayorNroDeVueloDespegando(), que retorne el número de vuelo más grande que esté despegando en el aeropuerto.

17. El casino, parte 2
En el marco del ejercicio del casino de la práctica 6, escribir las siguientes
operaciones. En cada caso, recordar escribir primero el contrato, y expresar la
estrategia usando subtareas (preferentemente con la metodología top-down).

a. estáElJugador_(nroJugador), que denota verdadero si el jugador indicado tiene registrada, al menos, una apuesta.

b. alguienJugóA_MasDe_(nroApostado, cantidadMínima), que denota verdadero si algún jugador apostó al número indicado por un monto mayor a
cantidadMínima.

---- GUIAS REGISTROS Y VARIANTES-------------------------------------------
1.Declarar un tipo variante llamado DíaDeLaSemana, que sirva para identificar los
días de la semana. Luego implementar las siguientes funciones (sin olvidar sus
contratos):
type DiaDeLaSemana is variant{
    /* Proposito: Modelar los dias de la semana.
    */
    case Lunes{}
    case Martes{}
    case Miercoles{}
    case Jueves{}
    case Viernes{}
    case Sabado{}
    case Domingo{}
}
a.díaSiguienteA_, que dado un día de la semana, devuelve el día siguiente.
function diaSiguienteA_(diaDeLaSemana){
    /*Proposito: describe el dia siguiente al "diaDelaSemana".
    Precondicion: ninguna.
    Parametro: 
        diaDeLaSemana: DiaDeLaSemana, representa el dia  para obtener el siguiente
    Tipo: DiaDeLaSemana.
    */
   return( choose Lunes when (diaDeLaSemana == Domingo )
                  Martes when(diaDeLaSemana == Lunes) 
                  Miercoles when(diaDelaSemana == Martes)
                  Jueves when (diadeLaSemana == Miercoles)
                  Viernes when (diaDeLaSemana == Jueves)
                  Sabado when (diaDeLaSemana == Viernes)
                  Domingo otherwise
         )                   
}
b.díaPrevioA_, que dado un día de la semana, devuelve el día previo.
function diaPrevioA_(diaDeLaSemana){
     /*Proposito: describe el dia previo al "diaDelaSemana".
    Precondicion: ninguna.
    Parametro: 
        diaDeLaSemana: DiaDeLaSemana, representa el dia  para obtener al previo.
    Tipo: DiaDeLaSemana.
    */
    return( choose Lunes when (diaDeLSemana == Martes )
                  Martes when(diaDeLaSemana == Miercoles) 
                  Miercoles when(diaDelaSemana == Jueves)
                  Jueves when (diadeLaSemana == Viernes)
                  Viernes when (diaDeLaSemana == Sabado)
                  Sabado when (diaDeLaSemana == Domingo)
                  Domingo otherwise
         )                   
}
c.es_DíaDeFinDeSemana, que indica si el día dado es uno del fin de semana.
function es_DiaDeFinDeSemana(diaDeLaSemana){
     /*Proposito: describe el dia "diaDelaSemana" es dia de fin de semana.
    Precondicion: ninguna.
    Parametro: 
        diaDeLaSemana: DiaDeLaSemana, representa el dia para obtener si es parte del finde semana.
    Tipo: DiaDeLaSemana.
    */
    return (( diaDeLaSemana == Sabado) &&  (diaDeLaSemana == Domingo))


}
2.Implementar las siguientes funciones utilizando el tipo Carta definido en la clase teórica

a.es_Figura, que dada una Carta, describa verdadero solo si es una figura.
Se dice que una carta española es una figura, porque sus dibujos
representan diferentes personajes. La carta con número 10 representa un
paje medieval, número 11 un caballero, número 12 el rey.
function es_Figura(carta){
    Proposito: indica si una "carta" es una figura.
    Precondicion: ninguna.
    Parametro:
    carta: Carta Española.
    Tipo: Booleano
    */
    return(nroCarta(carta) == 10 || nroCarta(carta) == 11 || nroCarta(carta) == 12)
// puedo definir las funciones es zota es caballo es rey

}

b.envidoCon_Y_, que dadas 2 cartas, describa el valor del envido. Tener en
cuenta la función realizada en clase teórica para el envido simple y
contemplar los nuevos casos. Cuando el envido tiene alguna figura, las
figuras no suman nada.

c.envidoCon_Y_mayorA_, que dadas 2 cartas y una cantidad, indique si
representa ese valor de envido o mayor

3.Implementar las siguientes funciones utilizando el tipo Celda.
type Celda is record{
    /*Proposito: modelar una celda del tablero.
    Inv Rep:  los numeros son mayores a cero.
    */
    field cantidadDeAzules // Numero. funcion observadora
    field cantidadDeRojos // Numero.
    field cantidadDeNegros // Numero.
    field cantidadDeVerdes // Numero.
}

a.celdaActual , que describa la celda actual.
function celdaActual(){
    /*Proposito: modelar una celda actual.
      Precondicion: ninguna.
      Tipo: Celda.
    */
    return (Celda ( cantidadDeAzules <- nroBolitas(Azul),
                    cantidadDeNegros <- nroBolitas(Negro),
                    cantidadDeVerdes <- nroBolitas(Verde),
                    cantidadDeRojos <-  nroBolitas(Rojo)
                  )
           )
}
b.cantidadDeAzulesEn_, que describe la cantidad de azules de la celda dada.
function cantidadDeAzulesEn_(celda){
      /*Proposito: modelar una cantidad de azules en la "celda".
      Precondicion: ninguna.
      Parametro: 
        celda: Celdas, representa la celda a evaluar las bolitas azules.
      Tipo: Numero.
    */
    return(cantidadDeAzules(celda) )
}
c.cantidadTotalDeBolitasEn_, que describe la cantidad total de bolitas
de los 4 colores de la celda dada.
function cantidadTotalDeBolitasEn_(celda){
     /*Proposito: modelar una cantidad total de bolitas en  "celda".
      Precondicion: ninguna.
      Tipo: Numero.
    */
    return( cantidadDeAzules(celda) +
            cantidadDeVerdes(celda) +
            cantidadDeRojos(celda) + 
            cantidadDeNegros(celda) 
          )
}
d.tiene_MásBolitasQue_, que dadas dos celdas, indica si la primera tiene más bolitas que la segunda.
function tiene_MasBolitasQue_(celda1, celda2){
    /*Proposito: indica si  la "celda1" tiene mas bolitas que la "celda2".
    Precondicion: ninguna.
    Parametros:
        *celda1: Celda, describe la primer celda comparar.
        *celda2: Celda, describe la segunda celda comparar.
    Tipo: Booleano.
    */
    return( cantidadTotalDeBolitasEn_(celda1)
            >
            cantidadTotalDeBolitasEn_(celda2)
            )
}
4. Declarar un tipo de registros llamado Cuenta que contenga el número de cuenta, el
tipo de cuenta (modelado por TipoDeCuenta), el nombre del cliente (representado
como un String), un tipo de moneda (modelado por Moneda) y un saldo
(representado como un número de centavos). Implementar las siguientes funciones:

type Cuenta is record {
    /*
        Proposito: Modelar una cuenta.
        INV Rep: 
            "nombre" no es vacio.
            "saldo" es mayor o igual a cero.
    */
    field numeroDeCuenta // Numero
    field tipoDeCuenta // TipiDeCuenta
    field nombreDelCliente // String 
    field tipoDeMoneda // Moneda
    field saldo // Numero 

}
type TipoDeCuenta is variant {
/* PROPÓSITO: modelar los diferentes tipos de cuenta que
ofrece el banco
*/
case CuentaCorriente {}
case CajaDeAhorro {}
case CuentaSueldo {}
}
type Moneda is variant {
/* PROPÓSITO: modelar los diferentes tipos de moneda con los
que trabaja el banco
*/
case Pesos {}
case Dolares {}
case Euros {}
case Reales {}
}

a.cuenta_ConSaldoActualizadoA_, que dada una cuenta y un nuevo
saldo describa la cuenta con el saldo actualizado.
function cuenta_ConSaldoActualizadoA_(cuenta, nuevoSaldo){
    /*
        Proposito: que dada una"cuenta" bancaria y un "nuevoSaldo" describe la cuenta con el saldo actualizado al dado.
        Precondicion: el saldo debe ser un numero positivo.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a actualizar
        *nuevoSaldo: Numero, representa el nuevo saldo a actualizar.
        Tipo: Cuenta.
    */
    
}
b.cuenta_ConTipoDeCuentaCambiadoA_, que dada una cuenta y un nuevo
tipo de cuenta bancaria describa la cuenta con el tipo cambiado al dado.
function cuenta_ConTipoDeCuentaCambiadoA_(cuenta, nuevoTipoDeCuenta){


c.Por disposición bancaria todas las cuentas bancarias de tipo Sueldo cuyo
saldo supera los $25.000 deben cambiar su tipo de cuenta bancaria a Caja
de Ahorro.
Implementar cuenta_ConTipoCambiadoSegúnDisposición, que dada
una cuenta bancaria describe la cuenta con el tipo que corresponda a cada
caso.
function cuenta_ConTipoCambiadoSegunDisposicion(cuenta){
/*
        Proposito: que dada una"cuenta" bancaria describe la cuenta con el tipo que corresponda a cada caso.
        Precondicion: ninguna.????
        Parametros:
        *cuenta: Cuenta, representa la cuenta a actualizar
        Tipo: Cuenta.
        Observacion:todas las cuentas bancarias de tipo Sueldo cuyo saldo supera los $25.000 deben cambiar 
                    su tipo de cuenta bancaria a Caja de Ahorro.
            
    */    

function nuevoTipoDeCuenta_SegunDisposicion(cuenta){  // AQUI AGRUPO A TIPO DE CUENTA:CAJA DE AHORRO A LAS QUE CUMPLEN CON LA CONDICION ANTERIOR SINO DEVUELVE EL TIPO DE CUENTA 
/* 
        Proposito: que dado un nuevo tipo de una"cuenta" bancaria describe el nuevo tipo de  cuenta segun la diposicion bancaria.
        Precondicion: ninguna.
        Parametros:
        *cuenta: TipoDeCuenta, representa la cuenta a actualizar
        Tipo: TipoDeCuenta.
        Observacion:todas las cuentas bancarias de tipo Sueldo cuyo saldo supera los $25.000 deben cambiar 
                    su tipo de cuenta bancaria a Caja de Ahorro.
            
    */    
    
}
function cumpleLaCondicion_(cuenta){  //AQUI CONDICIONO LAS CUENTAS QUE TIENE QUE SER MAYOR S 2500 Y TIENE QUE SER CAJA CUENTA SUELDO
    /*
        Proposito: indica si la cuenta  se cumple la diposicion bancaria  de su tipo de cuenta.
        Precondicion: ninguna.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        Tipo: Booleano.
        Observacion:todas las cuentas bancarias de tipo Sueldo cuyo saldo supera los $25.000 deben cambiar 
                    su tipo de cuenta bancaria a Caja de Ahorro.
            
    */
 
}

d.saldoEnPesosDe_, que dada una cuenta describe el saldo en pesos de la
misma. Asumir los valores cambiarios dados en la siguiente tabla .
function saldoEnPesosDe_(cuenta){
  /*
        Proposito:que dada una "cuenta" describe el saldo en pesos de la misma .
        Precondicion: ninguna.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        Tipo: Numero.    
    */  
 
e.númeroDeCuentaConMayorSaldoEntre_Y_, que dadas dos cuentas
bancarias describe el número de la cuenta que tiene mayor saldo entre
ambas. Tener en cuenta que las cuentas pueden estar expresadas en
diferentes monedas.
function numeroDeCuentaConMayorSaldoEntre_Y_(cuenta1, cuenta2){
      /*
        Proposito:que dada dos cuentas  "cuenta1" y "cuenta2"  describe el numero de la cuenta que tiene mayor saldo entre ambas.
        Precondicion: las cuenta deben ser expresadas en diferentes monedas.
        Parametros:
        *cuenta1: Cuenta, representa una de las cuenta a comparar.
        *cuenta2: Cuenta, representa una de las cuentas a comparar.
        Tipo: Cuenta.   
    */
   
}
f. cuenta_ActualizadaTrasExtracciónDeCajeroDe_, que dada una cuenta y un monto a
 extraer describa la cuenta con el saldo actualizado. ¿Es necesario establecer alguna una precondición?
function cuenta_ActualizadaTrasExtraccionDeCajeroDe_(cuenta, montoAExtraer){
       /*
        Proposito: que dada cuenta  "cuenta" y un "monto" a extraer  describe la cuenta con el saldo actualizado.
        Precondicion: el monto no debe ser mayor al saldo.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a actualizar.
        *monto: Numero, representa un monto a extraer.
        Tipo: Cuenta.   
    */
    return()
}

g.puedeExtraer_PorCajeroDeLaCuenta_, que dado un monto a extraer y
una cuenta indique si la extracción NO resultaría en un saldo negativo.
function puedeExtraer_PorCajeroDeLaCuenta_(montoAExtraer, cuenta){
      /*
        Proposito: que dado  un "monto" a extraer  y una "cuenta" indica si la extraccion No resultaria en un saldo negativo.
        Precondicion: el monto no debe ser mayor al saldo.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        *montoAExtraer: Numero, representa un monto a extraer.
        Tipo: Booleano.
    */

}

h.cuenta_ActualizadaTrasDepósitoEnCajeroDe_, que dada una
cuenta y un monto a depositar describa la cuenta con el saldo actualizado.
function cuenta_ActualizadaTrasDepositoEnCajeroDe_(cuenta, montoADepositar){
        /*
        Proposito: que dada una "cuenta" y un "montoADepositar" describa la cuenta con el saldo actualizado.
        Precondicion: ninguna.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        *montoADepositar: Numero, representa un monto a depositar.
        Tipo: Cuenta.
    */

}
------GUIA LISTAS-----
1.Escribir la función cantidadesDeRojasEnFilaActual que describe una Lista de
números cuyos elementos son las cantidades de bolitas rojas en cada una de las celdas
de la fila actual, leídas desde el Oeste hasta el Este.
function cantidadesDeRojasEnFilaActual(){
    /*
        Proposito: describe una lista de numeros cuyos elementos son las cantidades de bolitas rojas en la fila actual.
        Leídas desde el Oeste hasta el Este.
        Precondicion: ninguna.
        Tipo: [Numero]
    */
    listaDeNumerosConBolitasRojas := []
    IrAlBorde(Oeste)
    while(puedeMover(Este)){
      listaDeNumerosConBolitasRojas := snoc(listaDeNumerosConBolitasRojas,nroBolitas(Rojo)) //procesar 
      Mover(Este)  // 
    }
    return(snoc( listaDeNumerosConBolitasRojas, nroBolitas(Rojo)) )    
}
2.Escribir la función cantidadDeRojasADistancia2DelBordeOesteDe_ que dada
una lista de números que representa las cantidades de bolitas rojas de una fila
cualquiera, describa la cantidad de bolitas rojas que había en la celda a distancia 2 del
borde Oeste de la fila dada al momento de su lectura. Por ejemplo, dada la lista del
ejemplo anterior, debería describir el número 5.
function cantidadDeRojasADistancia2DelBordeOesteDe_(listaDeNumeros){
    /*Proposito: dada una "lista", describe la cantidad de bolitas rojas que habia en la celda a distancia 2 del borde Oeste de la fila dada al momento de su lectura
     Leídas desde el Oeste hasta el Este.
     Parametro: 
        *listasDeNumeros: Lista de numeros
    Tipo: Numero.
    */
    return(primero(sinLosDosPrimeros(listasDeNumeros))) // funcion biblioteca diapo
}
program{
   return(cantidadDeRojasADistancia2DelBordeOesteDe_(cantidadesDeRojasEnFilaActual()))
    
}
3.Escribir las funciones dadas a continuación, que reciben como parámetros una lista de
números que representa las cantidades de bolitas rojas de una fila cualquiera:

a.las3PrimerasDe_ConLaMismaCantidad, que indica si las primeras 3 celdas
al Oeste de la fila representada tenían la misma cantidad de bolitas rojas al
momento en que la fila fue leída.
function las3PrimerasDe_ConLaMismaCantidad(lista){
    /*
        PROPÓSITO:  indica si las primeras 3 celdas al Oeste de la fila representada
                tenían la misma cantidad de bolitas rojas al momento en que la
                fila fue leída
        PRECONDICONES:
        *la lista dada debe contar con al menos 3 elementos
        PARÁMETROS:
        *lista: [Número]
        TIPO: Bool
    */
    return((primero(lista) == segundo(lista)) && (primero(lista) == tercero(lista)))
}
program{
    return(las3PrimerasDe_ConLaMismaCantidad(cantidadesDeRojasEnFilaActual()))
    
}
b.las3PrimerasDe_ConDistintasCantidades que indica si en las primeras 3
celdas al Oeste hay diferente cantidad de bolitas de rojas (es decir, son todas
distintas).
funcion las3PrimerasDe_ConDistintasCantidades(lista) {
    /*
    PROPOSITO: indica si en las primeras 3 celdas al Oeste hay diferente cantidad de bolitas de rojas
    PRECONDICONES: 
        *la lista dada debe contar con al menos 3 elementos
    PARAMETROS:
        *lista: [Numero]
    TIPO: Booleano
    */
    return(not las3PrimerasDe_ConLaMismaCantidad(lista))
    return((primero(lista) /= segundo(lista) && (primero(lista) /= tercero(listas))))
}
program{
    return(las3PrimerasDe_ConDistintasCantidad(cantidadesDeRojasEnFilaActual()))    
}
c.hayAlgunaCantidadIgualEnLas3PrimerasDe_ que determine si en algún
caso hay la misma cantidad de bolitas de dos colores (por ejemplo, la primera y
la tercera celda tienen la misma cantidad de bolitas rojas, o la segunda y la
tercera, etc.).
function hayAlgunaCantidadIgualEnLas3PrimerasDe_(lista){
    /*
        PROPÓSITO:Indica si en algún caso hay la misma cantidad de bolitas de dos colores
        PRECONDICONES:
        *La lista dada debe contener al menos 3 numeros.
        PARAMETROS:
        *lista: [Número ]
        TIPO: Booleano.
    */
    return(choose   True when (primero(lista) == segundo(lista))
                    True when (primero(lista) == tercero(lista))
                    True when (segundo(lista) == tercero(lista))
                    False otherwise)
}
function hayAlgunaCantidadIgualEnLas3PrimerasDe_V2(lista){ // esta es la mejor version.
    /*
        PROPÓSITO:Indica si en algún caso hay la misma cantidad de bolitas de dos colores
        PRECONDICONES:
        *La lista dada debe contener al menos 3 numeros.
        PARAMETROS:
        *lista: [Número ]
    T   IPO: Booleano.
    */
    return( (primero(lista) == segundo(lista))  ||
            (primero(lista) == tercero(lista))  ||
            (segundo(lista) == tercero(lista)))
}
4.Escribir la función direccionesAlBorde que retorne la lista de direcciones en las que
el cabezal no se puede mover. En el siguiente tablero direccionesAlBorde describe
la lista [Sur, Oeste], ya que el cabezal en este caso no puede moverse ni al Sur, ni
al Oeste.

a.¿Cómo puede utilizarse direccionesAlBorde para determinar si el tablero
tiene una única celda?
function direccionesAlBorde(){
      /*
    PROPÓSITO: retorna la lista de direcciones en las que el cabezal no se puede mover.
    PRECONDICONES: ninguna
    TIPO: [Direcciones]
    */
    direccionesAObservar := minDir()
    listaDeDireccionesQueNoPuedeMover := []  
    while(direccionesAObservar /= maxDir()){
        listaDeDireccionesQueNoPuedeMover := listaDeDireccionesQueNoPuedeMover ++ noPuedeMoverseEn_(direccionesAObservar)
        direccionesAObservar := siguiente(direccionesAObservar)
    }
    return(listaDeDireccionesQueNoPuedeMover ++ noPuedeMoverseEn_(direccionesAObservar))
}
function noPuedeMoverseEn_(direccion){
    return(choose [direccion] when (not puedeMover(direccion))
                    [] otherwise)
}
5. Escribir la función es_Singular, que dada una Lista de elementos de cualquier tipo,
indique si la lista tiene exactamente un único elemento.
SUGERENCIA: pensar en combinación con qué otras operaciones puede aprovecharse
la expresión primitiva esVacía.
function es_Singular(listaDeElementos){   
    /*  Proposito: dada una "lista" de elementos de cualquier tipo, indique si la lista tiene exactamente un único elemento.
        Precondicion: ninguna.
        Parametro.
            *listaDeElementos: Lista de elementos
        Tipo: Booleano.
    */
    return(not esVacía(listaDeElementos) && esVacía(resto(listaDeElementos)))
}
6.Escribir las siguientes funciones que suponen dada una lista de Direcciones que
expresa una ruta. Tener en cuenta que el siguiente tramo de la ruta solamente se
compone de las primeras dos direcciones de la ruta si existen.

a.haySiguienteTramoEn_, función total que indique si la ruta tiene al menos un
tramo completo.
function haySiguienteTramoEn_(ruta){  // son solo las 2 primeras direcciones
    /*  Proposito: indica si la ruta tiene al menos un tramo completo.
        Precondicion: ninguna.
        Parametro:
        * ruta:Lista de Direcciones.
        Tipo: Booleano.
    */
    return(not esVacía(ruta) && y tengo que obtener las dos primeras direcciones creo???:|)

}
b.sigueUnaCurvaEn_, función total que indique si el tramo que sigue en la ruta
es una curva.
function sigueUnaCurvaEn_(ruta){
    /*  Proposito: indica si el tramo  que sigue en la "ruta" es una curva.
        Precondicion: ninguna.
        Parametro:
            *ruta: Lista de Direcciones.
        Tipo: Booleano.
    */
    return

}
c.sigueCurvaADerechaEn_, que, teniendo en cuenta que viene una curva,
indique si la curva que sigue en la ruta es hacia la derecha.
function sigueCurvaADerechaEn_(curva){
     /*  Proposito: teniendo en cuenta que viene una curva, indique si la curva que sigue en la ruta es hacia la derecha.
         Precondicion: ninguna.
         Parametro: 
            *curva: Lista de Direcciones
         Tipo: Booleano.
    */

}
d.sigueCurvaAIzquierdaEn_, que, teniendo en cuenta que viene una curva,
indique si la curva en la ruta es hacia la izquierda.
function sigueCurvaAIzquierdaEn_(curva){
      /*  Proposito: teniendo en cuenta que viene una curva, indique si la curva en la ruta es hacia la izquierda.
         Precondicion: ninguna.
         Parametro: 
            *curva: Lista de Direcciones.
         Tipo: Booleano.
    */

}
e.sigueRectaEn_, que indique si el tramo que sigue en la ruta es una recta.
function sigueRectaEn_(ruta){
       /*  Proposito: indique si el tramo que sigue en la ruta es una recta.
         Precondicion: ninguna.
         Parametro: 
            *ruta: Lista de Direcciones.
         Tipo: Booleano.
    */

}

9.Escribir las siguientes funciones que continúan utilizando listas de elementos de tipo
Carta. Si bien varias de las funciones están inspiradas en el juego del Truco, no es
necesario conocer las reglas para realizarlas. Solo debe saberse que las Figuras son las
cartas con números 10, 11 y 12, ya que se dibujan en las cartas reales utilizando las
figuras de una Sota (una especie de paje o escudero), un Caballo (usualmente con su
caballero) y un Rey; y además, que el valor de una carta es el número de la misma si no
es una figura, o cero si es una figura.

a.manoDe3CartasDe_, que dado un mazo, describa una mano de 3 cartas
tomadas del mismo
function manoDe3CartasDe_(mazo){
       /*  Proposito: dado un "mazo", describa una mano de 3 cartas tomadas del mismo.
           Precondicion: ninguna.
           Parametro: 
            *mazo: Lista de Carta, que representa un mazo de cartas Españolas.
           Tipo: [Carta]
    */
    return([ primero(mazo),
             segundo(mazo),
             tercero(mazo)])
}
b.tiene_Envido, que dada una mano de 3 cartas, indique si tiene exactamente 2
cartas del mismo Palo.
function tiene_Envido(manoDe3Cartas){
       /*  Proposito: dado un "manoDe3Cartas", indica si tiene exactamente 2 cartas del mismo Palo.
           Precondicion: ninguna.
           Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
           Tipo: Booleano.
        */
        return ( choose True when ( Palo(primero(manoDe3Cartas)) ==( Palo(segundo(manoDe3Catas))))
                        True when (Palo(primero(manoDe3Cartas)) == (Palo(tercero(manoDe3Cartas))))
                        True when (Palo(segundo(manoDe3Cartas)) == (Palo(tercero(manoDe3Cartas))))
                        False otherwise
               )
}
c.tiene_Flor, que dada una mano de 3 cartas, indique si las 3 cartas son del
mismo Palo.
function tiene_Flor(manoDe3Cartas){
     /*  Proposito: dado un "manoDe3Cartas", indica si las 3 cartas son del mismo Palo
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Booleano.
        */
        return( (Palo(primero(manoDe3Cartas)) == Palo(segundo(manoDe3Cartas))) == Palo(tercero(manoDe3Cartas)) )
}
d.puntajeDe_ParaFlor, que, dada una mano de 3 cartas, describe la suma de
los valores de las cartas más 30 en caso que tenga flor, o cero en caso contrario.
Recordar que el valor de las figuras es 0.
function puntajeDe_ParaFlor(manoDe3Cartas){
    /*  Proposito: dado un "manoDe3Cartas", describe la suma de los valores de las cartas más 30 en caso que tenga flor,
                    o cero en caso contrario.
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Numero.
        */
        return( choose puntajeDe_ConFlor(manoDe3Cartas) when tiene_Flor(manoDe3Cartas)
                       0 otherwise
              )
}
function puntajeDe_Flor(manoDe3Cartas){
    quiero hacer un recorriso de acumulacion de no figuras =)
    /*  Proposito:dada una "manoDe3Cartas" describir la suma de los valores de las cartas mas 30 en caso que no sean figuras
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Numero.
        Observacion: es un recorrido sobre cartas de acumulacion de  cartas no  figuras. ?????PUEDO MEJORAR NO??
        */
        cartaAObservar := [Numero(primero(manoDe3Cartas))]
        puntajeDeFlorVisto := []
        while (cartaAObservar /= Numero(tercero(manoDe3Cartas))){
            puntajeDeFlorVisto := puntajeDeFlorVisto ++ noEsFiguraLa_(manoDe3Cartas)
            cartaAObservar := [Numero(siguiente(manoDe3Cartas))] ???????
        }
        return( puntajeDeFlorVisto ++ noEsFiguraLa_(manoDe3Cartas) + 30)
}
function noEsFiguraLa_(manoDe3Cartas){
     /*  Proposito:dada una "manoDe3Cartas", describir la suma de los valores de las cartas mas 30 en caso que no sean figuras
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Numero.
    */
    return( choose Numero(primero(manoDe3Cartas)) when (Numero(primero(manoDe3Cartas)) =< 7 )
                   Numero(segundo(manoDe3Cartas)) when (Numero(segundo(manoDe3Cartas)) =< 7 )
                   Numero(tercero(manoDe3Cartas)) when (Numero(tercero(manoDe3Cartas)) =< 7 )
                                            0     otherwise
          )
}
e.puntajeDe_ParaEnvido, que, dada una mano de 3 cartas, describe cuánto se
suma para un envido. Este valor es: si tiene envido, la suma de los valores de
las cartas del mismo palo más 20; si tiene flor, la suma de las 2 cartas de mayor
valor más 20; y si no tiene ni envido ni flor, el valor de la carta de mayor valor.
Recordar que el valor de las figuras es 0.
--RECORRIDOS SOBRE LISTAS--------------------------------------
1.Construir el procedimiento PonerColores_EnLaCeldaActual, que dada una lista de
Colores, pone una bolita del color correspondiente por cada uno de los elementos de la misma.
Por ejemplo,
PonerColores_EnLaCeldaActual([Verde,Verde,Azul]) pone dos bolitas Verdes y una Azul en la celda actual.
procedure PonerColores_EnLaCeldaActual(listaDeColores){
    /*Proposito: dada una lista de Colores, pone una bolita del color correspondiente por cada uno de los
                 elementos de la misma en la celda actual.
      Precondicion: la celda debe estar vacia.
      Parametro: 
        *listaDeColores: [Color]
    */
    foreach color in listaDeColores{ // por  cada color de la lista 
        Poner(color)                 // va a poner un color en la celda.
    }
}
2. Construir el procedimiento RecorrerCamino_, que dada una lista de Direcciones
mueve el cabezal en la dirección indicada por cada elemento, en orden. Por ejemplo,
RecorrerCamino_([Este, Este, Norte, Este]) debe mover el cabezal primero
hacia el Este dos veces, luego hacia el Norte 1 vez y por último se mueve hacia el Este.
¿Cuál es la precondición de este procedimiento?
procedure RecorrerCamino_(listaDeDirecciones){
       /*Proposito:  dada una lista de Direcciones mueve el cabezal en la dirección indicada por cada elemento, en orden.
         Precondicion: debe haber al menos celdas lindantes  en direccion hacia "listaDeDirecciones".
                        debe ser dado un camino valido en el tablero actual."Charly"
         Parametro: 
            *listaDeDirecciones: [Direccion]
    */
    caminoARecorrer := listaDeDirecciones
    while(not esVacía(listaDeDirecciones)){
        Mover(primero(listaDeDireccionesQueNoPuedeMover))
        caminoARecorrer := resto(listaDeDirecciones)
    }
    // otra opcion de resolucion 
    foreach direccion in listaDeDirecciones{
        Mover(listaDeDirecciones)
    }    
}

3.Construir la función aparicionesDeColor_, que dado un color, colorBuscado,
describa una lista de números que indican para cada una de las celdas del tablero
recorridas en dirección principal Norte y dirección secundaria Oeste, la cantidad de
bolitas del color buscado en esa celda del tablero. Por ejemplo, para el siguiente
tablero, aparicionesDeColor_(Rojo) debería describir la lista[4,0,3,1,0,2,10,7]:
function aparicionesDeColor_(colorBuscado){
       /*Proposito: describe una lista de números que indican para cada una de las celdas del tablero
                    recorridas en dirección principal Norte y dirección secundaria Oeste, la cantidad de bolitas del color 
                    buscado dado por "colorBuscado" en esa celda del tablero.
         Precondicion: ninguna.
         Parametro: 
            *colorBuscado: Color.
        Tipo: [Numero]
        Observacion : es un recorrido de acumulacion 
    */
    aparicionesDeColores := [nroBolitas(colorBuscado)]
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Oeste)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)
        aparicionesDeColores := aparicionesDeColores ++ [nroBolitas(colorBuscado)]
    }
    return(aparicionesDeColores)
}

4.Construir el procedimiento Poner_Bolitas_EnElTablero, que dada una lista de
números y un color, recorre el tablero con dirección principal Norte y dirección
secundaria Oeste y pone en cada celda la cantidad de bolitas del color dado, según el
elemento en la posición correspondiente. Si hubiera menos números que celdas, en las
celdas restantes no se pondrán bolitas, y si hubiera más números que celdas, se
ignoran los números sobrantes.
Por ejemplo
Poner_Bolitas_EnElTablero([4,0,3,1,0,2,10,7],Rojo), si se
ejecuta en un tablero inicial vacío de 4 columnas y 2 filas, produce el tablero de la figura
del ejercicio anterior.

5.Construir la función coloresEnLaCeldaActual, que describa la lista de los colores
que aparecen en la celda actual. ¿Cuál es el número mínimo de elementos que tendrá
esta lista? ¿Y el máximo?

6.Construir la función aparicionesDelColor_EnElCamino_, que dado un color,
colorBuscado,
y una lista de Direcciones, direccionesDelCamino, describa la
lista con la cantidad de bolitas del color dado en las celdas recorridas, si las mismas se
recorren en el orden en que indica el camino dado, incluyendo la celda en que se
encuentra el cabezal antes de empezar y al finalizar el recorrido. ¿Cuál es la
precondición del procedimiento?

7.Construir la función longitudDe_, que dada una lista cualquiera, describa la cantidad
de elementos de la misma.
Por ejemplo, longitudDe_([Azul,Azul,Verde,Rojo]) describe 4.
function longitudDe_(lista){
    /*  Proposito: describa la cantidad de elementos de la "lista" dada.
        Precondicion: ninguna.
        Parametro: 
            *lista: [Elemento]
        Tipo: Numero.
        Observacion: es un recorrido de acumulacion ????
    */
    cantidadDeElementos := 0
    foreach elemento in lista{
        cantidadDeElementos := cantidadDeElementos + 1 
    }
    return(cantidadDeElementos)     
}

8.Construir las funciones
a.sumatoriaDe_, que dada una lista de Números, describa la suma de todos los
elementos de la misma.
Porejemplo,
sumatoriaDe_([1,10,15,7,9]) describe el número 42, porque 1+10+15+7+9 es igual a 42;

b.productoriaDe_, que dada una lista de Números, describa el producto de
todos los elementos de la misma.
Por ejemplo, productoriaDe_([1,5,7,9]) describe el número 315, porque
1*5*7*9 es igual a 315.

c.cantidadDeBolitas_DelTablero, que dado un color, indique la cantidad
total de bolitas de ese color que hay en el tablero. ¿Puede hacerse reutilizando
código ya hecho?
AYUDA: pensar en combinar algunas de las funciones hechas en ejercicios
anteriores con alguna de las de este.

9.Construir las funciones
a.repetición_VecesDe_, que dado un número y un elemento de cualquier tipo,
describa una lista con la cantidad indicada de repeticiones del elemento dado. Si
el número es menor o igual que cero, retorna la lista vacía.
Por ejemplo, repetición_VecesDe_(3,8) describe la lista [8,8,8], mientras que
repetición_VecesDe_(5,Verde)describe la lista [Verde,Verde,Verde,Verde,Verde].
function repeticion_DeVeces_(numero, elemento){
    /*
        Prop: describe una,lista con la cantidad "numero" de repeticiones del elemento "elemento". Si es menor o igual 
              a cero devuelve una lista vacia.
        Precond: ninguna
        Param: 
            numero: Numero
            elemento: elemento
        Tipo: [Elemento]
    */
    listaDeElementos := []
    repeat(numero){
        listaDeElementos :=  listaDeElementos ++ elemento
    }
    return(listaDeElementos)
}

b. laLista_Clonada_Veces, que dados una lista de elementos y un número,
describa la lista resultante de clonar la lista dada tantas veces como se indica.
Por ejemplo,
laLista_Clonada_Veces([Rojo,Azul,Verde], 3) retorna [Rojo,Azul,Verde,Rojo,Azul,Verde,Rojo,Azul,Verde]
function laLista_Clonada_Veces(listaDeElementos, numero){
      /*
        Prop: describe la lista resultante de clonar la lista "listaDeElementos tantas veces como indica "numero".
        Precond: ninguna
        Param: 
            numero: Numero
            listaDeElemento: [Elemento]
        Tipo: [Elemento]
    */
    return(repeticion_DeVeces_(numero, listaDeElementos))
}


c.losElementosDe_Clonados_Veces, que dados una lista de elementos y un
número, describa la lista que contenga los elementos dados en el orden de dicha
lista, pero repetidos la cantidad de veces indicada.
Por ejemplo,
losElementosDe_Clonados_Veces([Rojo,Azul,Verde],3) retorna [Rojo,Rojo,Rojo,Azul,Azul,Azul,Verde,Verde,Verde].

d.La solución anterior, ¿fue construida reutilizando repetición_VecesDe_? Si
no es así, resolverla nuevamente utilizando esa función.

10. Construir la función reversoDe_, que dada una lista, describa la lista que tiene los
mismos elementos que la dada, pero en orden reverso.
Por ejemplo,
reversoDe_([Negro,Azul,Azul,Verde,Rojo])
describe [Rojo,Verde,Azul,Azul,Negro].

11. Construir las funciones
a.direccionesOpuestasDe_, que dada una lista de direcciones, describa la
lista de direcciones en donde cada elemento es el opuesto al de la posición
original.
Por ejemplo,
direccionesOpuestasDe_([Oeste,Sur,Norte]) describe [Este,Norte,Sur].

b. siguientesDe_, que dada una lista de colores, describa la lista de colores en
donde cada elemento es el siguiente del original.
Por ejemplo,
siguientesDe_([Rojo,Azul,Verde,Azul,Azul]) describe [Verde,Negro,Azul,Negro,Negro].

12. Construir la función lista_HomologadaPorDebajoDe_A_, que dada una lista de
números, y dos números umbral y default, describa una lista de números que está
basada en la lista dada de la siguiente manera: aquellos números de la lista dada que
son mayores o iguales al umbral, permanecen igual, pero aquellos que son menores,
son reemplazados por el valor default.
Por ejemplo, lista_HomologadaPorDebajoDe_A_([3,7,8,5,1,3,2,4], 4, 2)
describe [2,7,8,5,2,2,2,4].
13. Construir las funciones
a.númerosParesDe_, que dada una lista de Números, describa
la lista de números pares que aparecen en la misma.
Por ejemplo, númerosParesDe_([3,4,5,2,5]) describe [4,2].

b. laLista_SinElElemento_, que dados una lista y un elemento, describa la
lista que resulta de quitar todas las apariciones del elemento dado que ocurren
en lista dada. ¿De qué tipo debe ser elemento?
Porejemplo,
laLista_SinElElemento_([Azul,Verde,Azul,Rojo], Azul) describe [Verde,Rojo].

14. Construir la función contiene_A_, que dada una lista y un elemento, indica si el
elemento está en la lista.
Por ejemplo, contiene_A_([21,3,42], 3) indica que es verdadero que la lista
contiene a 3, mientras que contiene([21,3,42], 5) indica que es falso que la lista contiene a 5.

15. Construir la función sinDuplicados_, que dada una lista, describa una lista que tenga
todos los elementos de la lista dada, pero donde no aparecen elementos repetidos,
pues las repeticiones que aparecen luego de la primera fueron eliminadas.
Por ejemplo,
sinDuplicados_([1,3,4,2,4,3,5]) describe a la lista [1,3,4,2,5]. Observar que no es lo mismo describir a la lista [1,2,4,3,5], que
podría ser un resultado válido, pero no es el solicitado (porque no se conservó el primero de cada uno).

16. Construir las funciones
a. intersecciónDe_Con_, que dadas dos listas que no contienen elementos
repetidos, describe la lista de todos los elementos que aparecen en ambas.
Por ejemplo:
intersecciónDe_Con_([1,3,4], [2,4,3,5]) describe [3,4].

b. uniónDe_Con_, que dadas dos listas que no contienen elementos repetidos,
describe una lista sin repetidos que contenga todos los elementos que aparecen
en alguna de las 2 listas.
Por ejemplo, uniónDe_Con_([1,3,4],[2,4,3,5]) describe [1,3,4,2,5].
¿De qué tipo es la primera lista? ¿Y la segunda? ¿Pueden ser de tipos diferentes?

17. Construir la función algunoDe_Entre_Y_, que, dada una lista de Números y dos
números desde y hasta, indica si la lista contiene algún elemento que se encuentre
entre los números desde y hasta, sin incluirlos. Es decir, si algún elemento k de la lista,
cumple desde < k < hasta.
Por ejemplo, algunoDe_Entre_Y_([7,3,1,25,16], 13, 18) indica que es verdadero que hay un
elemento entre 13 y 18 (el 16), mientras que algunoDe_Entre_Y_([7,3,1,25,16], 13, 16) indica que es falso que haya
algún elemento entre 13 y 16 (el 16 no es menor que 16).
¿La solución propuesta requirió el uso de variables que recuerdan valores booleanos?
Si fue así, considerar ofrecer una solución que NO utilice variables booleanas.
18. Construir la función lista_estáIncluidaEn_ que dadas 2 listas que no contienen
elementos repetidos, describe si la primer lista se encuentra contenida en la segunda
lista (o sea, todos los elementos de la primera aparecen en la segunda).
Por ejemplo,
las expresiones lista_estáIncluidaEn_([4,5],[5,3,4,6]) y lista_estáIncluidaEn_([4,5],[2,3,4,6,5])
indican que es verdadero que está incluida, mientras que lista_estáIncluidaEn_([4,5,8],[4,3,5,6]) indica
que es falso que esté incluida.

19. Construir la función estáOrdenada_ que, dada una lista de Números indica si está
ordenada de menor a mayor. Para que una lista esté ordenada, cada elemento debe ser
menor o igual al que le sigue.
Por ejemplo, la expresión estáOrdenada_([2,7,9,15]) indica verdadero, mientras
que la expresión estáOrdenada_([2,15,9,7]) indica falso.
¿La solución propuesta requirió el uso de variables que recuerdan valores diferentes a
la lista que todavía falta recorrer? Si fue así, considerar ofrecer una solución que NO
utilice variables además de la que se utiliza para recordar la lista a recorrer.

20. Construir la función posiciónDe_enLaQueAparece_ que dada una lista y un
elemento, describe la posición de la lista en la que aparece ese elemento por primera
vez. Se define la posición de un elemento como un número que representa la cantidad
de veces que debe usarse la función sinElPrimero para acceder a ese elemento.
¿Cuál es la precondición de la función? ¿Por qué no tendría sentido que esta función
sea total?
Por ejemplo, posiciónDe_enLaQueAparece_([4,8,15,16,42],8) describe al número 1, porque solo
se usa una vez sinElPrimero (para quitar el 4), posiciónDe_enLaQueAparece_([4,8,15,16,42],16)
describe 3, porque se deben usar 3 veces la función (para quitar el 4, el 8 y el 15), y
posiciónDe_enLaQueAparece_([4,8,15,16,23,42],4) describe 0, porque no hace falta usar sinElPrimero.

21. Construir la función sinLaPrimeraApariciónDe_en_ que dado un elemento y una
lista, describe la lista que se obtiene de eliminar una única vez el elemento, si es que
este aparece en la lista.
Por ejemplo, sinLaPrimeraApariciónDe_en_(8,[4,8,42,15,8,42]) describe [4,42,15,8,42] y
sinLaPrimerApariciónDe_en_(42,[4,8,42,15,8,42]) describe [4,8,15,8,42].

22. Construir las siguientes funciones:
a. mínimoElementoDe_, que dada una lista de Números, describe el elemento
más chico que se encuentra en la lista. ¿Cuál es la precondición de la función?
Por ejemplo, mínimoElementoDe_([13,21,3,9,45,3,7]) describe 3.

b. sinElMínimoElemento_, que dada una lista de Números, describe la lista que
se obtiene de eliminar una única vez el elemento más chico. ¿Cuál es la
precondición de la función?
Por ejemplo, sinElMínimoElemento_([13,21,3,9,45,3,7]) describe [13,21,9,45,3,7].

c. lista_ordenada, que dada una lista de Números, describe la lista con los
mismos elementos que la dada, pero ordenada de menor a mayor. ¿Se puede
elaborar una estrategia combinando los ejercicios anteriores?
Por ejemplo, lista_ordenada([13,21,3,9,45,17,8,3,7])
describe [3,3,7,8,9,13,17,21,45].

d. ¿Puede hacerse la función anterior con alguna otra estrategia diferente a esa,
que no sea simplemente utilizar la variante de funciones del ejercicio siguiente…? 
Este tema es un tema amplio que se tratará en detalle en la materia Estructuras de Datos.

23. Construir las siguientes funciones. ¿Cuáles son las precondiciones de estas funciones?

a. máximoElementoDe_, que dada una lista de Números, describe el elemento
más grande que se encuentra en la lista.
Por ejemplo, máximoElementoDe_([13,21,3,9,45,3,7]) describe 45.

b. sinElMáximoElemento_, que dada una lista de Números, describe la lista que
se obtiene de eliminar una única vez el elemento más grande.
Por ejemplo,
sinElMáximoElemento_([13,21,3,9,45,3,7]) describe [13,21,3,9,3,7].

24. Construir la función segmentoInicialDeLargo_de_ que, dado un número que
representa a una cantidad y una lista de cualquier tipo, describe la lista que se obtiene
de quedarse únicamente con esa cantidad de elementos de la lista comenzando por el
primero (sus primeros elementos), o todos, si no hay suficientes. ¿Cuál es la
precondición de esta función? ¿Qué nombre te parece adecuado en este caso para el
parámetro de tipo número? ¿Para qué tipos de lista funciona tu solución?
Por ejemplo, segmentoInicialDeLargo_de_(4,[4,8,15,16,99,42]) describe
[4,8,15,16], mientras que segmentoInicialDeLargo_de_(2,[4,8,15,42]) describe [4,8] y
segmentoInicialDeLargo_de_(7,[4,8,15,42]) describe [4,8,15,42].

25. Construir la función lista_AgrupadosDeA_, que dadas una lista de elementos
cualesquiera y un número que representa a una cantidad, describe la lista de listas que
agrupa los elementos de la lista dada en grupos, donde cada grupo tiene exactamente
la cantidad de elementos indicada, excepto el último grupo, que puede tener menos
elementos.
Por ejemplo, lista_AgrupadosDeA_([1,2,3,4,5,6,7,8,9,10,11],3) describe
a la lista [[1,2,3],[4,5,6],[7,8,9],[10,11]]. Observar que la la lista original
tiene 11 elementos, mientras que la lista resultante tiene 4.
Para realizarla, considerar utilizar la función del ejercicio anterior al pensar una
estrategia. ¿Qué otra subtarea haría falta para completar dicha estrategia?

26. Construir la función lista_Desagrupada, que dada una lista de listas, describe una
lista que contiene cada uno de los elementos de las listas internas de la lista dada.
Por ejemplo, lista_Desagrupada([[1,2,3],[4,5,6],[7,8,9]]) describe la
lista [1,2,3,4,5,6,7,8,9]. Observar que la lista argumento tiene 3 elementos,
mientras que la lista resultado tiene 9.

27. Construir la función laLista_SinLosPrimeros_, que dados una lista de elementos
de cualquier tipo y un número que representa a una cantidad, describe la lista que se
obtiene de quedarse con todos los elementos excepto el segmento inicial del largo
dado.
Por ejemplo, laLista_SinLosPrimeros_([4,8,15,23,42],4) describe [42],
laLista_SinLosPrimeros_([4,8,16,23,9,42],4) describe [9,42], y la
expresión laLista_SinLosPrimeros_([4,8,15,16,23,42],8) describe [].
ATENCIÓN:
según qué estrategia se haya utilizado al escribir la función lista_AgrupadosDeA_, 
es posible que ya se haya resuelto este ejercicio como
subtarea de aquél (quizás con otro nombre). En ese caso, ¿sería necesario volverlo a
escribir? ¿Puede reutilizarse lo hecho con anterioridad?

28. Construir la función sinInternos_, que dada una lista de Números, describa la lista
que se obtiene de quitar todos los elementos internos. Un elemento de una lista se dice
interno si es igual al anterior de la lista.
Por ejemplo, sinInternos_([1,1,2,2,2,3,1,2,2]) describe [1,2,3,1,2].
//--------GUIA 1 ----
//1) Escribir un programa que reemplace una bolita de color Roja con otra de color Verde 
//en la celda  actual. Pruebe su programa en la computadora, modificando el tablero 
//inicial de forma que el programa funcione satisfactoriamente
procedure ReemplazarBolita (){
 Poner(Verde)
 Sacar(Rojo)
}
//2)Escribir un programa que mueva una bolita de color Negro de la celda actual a la celda vecina 
//al Este, dejando el cabezal en la celda lindante al Este
procedure MoverBolitaAlEste (){
    Sacar(Negro)
    Mover(Este)
    Poner(Negro)
}
//3)Escribir un programa que ponga una bolita de color Azul en la celda vecina al Norte de la actual .
procedure PonerAlNorte(){
    Mover(Norte)
    Poner(Azul)
    Mover(Sur)
}
//4)Cuadrados verdes --> Escribir los siguientes programas:
//a. uno que ponga un cuadrado de tamaño 3 con bolitas de color verde, con centro en la celda.
//inicial (dejando el cabezal en dicha celda al finalizar)
//i. ¿Qué ocurre si el tablero ya tenı́a bolitas verdes? ¿Es esto un problema, o el efecto
//obtenido es acorde al propósito?
//ii. ¿Qué ocurriría si desde la celda inicial no hay espacio para colocar las bolitas
//necesarias para que se cumpla el propósito?
//b. uno que saque un cuadrado de tamaño 3 con bolitas de color verde (saca una bolita de cada
//celda), siendo la celda inicial el centro del cuadrado, dejando el cabezal en dicha celda al finalizar.
//i. ¿Qué sucede si no hay al menos una bolita verde en cada una de las celdas necesarias?
//¿Y si el tablero no tiene el tamaño adecuado?
procedure DibujarCuadradoDeTresVerde(){
    IniciarDibujo()
    DibujarColumnaDeTresVerde()
    PasarAProximaColumna()
    DibujarColumnaDeTresVerde()
    PasarAProximaColumna()
    DibujarColumnaDeTresVerde()
    FinalizarDibujo()
}
procedure IniciarDibujo(){
    Mover(Oeste)
}
procedure DibujarColumnaDeTresVerde(){
    /* Proposito:  dibujar un cuadrado de color verde de tres celdas de largo a partir 
                   del centro del mismo y finaliza en mismo lugar de inicio.
       Precondicion: debe existir al menos una direccion en cada direccion.
    */
    Poner(Verde)
    Mover(Norte)
    Poner(Verde)
    Mover(Sur)
    Mover(Sur)
    Poner(Verde)
    Mover(Norte)
}
procedure PasarAProximaColumna(){
    Mover(Este)
}
procedure FinalizarDibujo(){
    Mover(Oeste)
}
//9)a. Escribir un procedimiento DibujarRectánguloRojoYNegroDe5x3() cuyo contrato es el siguiente:
//PROPÓSITO: Poner un rectángulo sólido de 5 celdas de ancho y 3
//celdas de alto. Desde la celda actual hacia el Este y hacia el Norte.
//PRECONDICIONES:
//* Hay al menos 4 celdas al Este y 2 celdas al Norte de la celda
//actual.
//* Las celdas contenidas en el rectángulo de 5x3 desde la celda
//actual hacia el Este y hacia el Norte están vacias.
//------------TOP DOWN---------------------------------------------------------------------------------
procedure DibujarRectánguloRojoYNegroDe5x3(){
      /*PROPÓSITO: Poner un rectángulo sólido de 5 celdas de ancho y 3
                    celdas de alto. Desde la celda actual hacia el Este y hacia el Norte.
        PRECONDICIONES:
                * Hay al menos 4 celdas al Este y 2 celdas al Norte de la celda actual.
                * Las celdas contenidas en el rectángulo de 5x3 desde la celda actual hacia el Este 
                   y hacia el Norte están vacias.*/
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        PasarAProximaLínea()
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        PasarAProximaLínea()
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        VolverAlInicioDelRectángulo()
} 
procedure PasarAProximaLínea(){
     /*PROPÓSITO: Pasar a la proxima línea a dibujar .
       PRECONDICIONES: debe existir al menos una celda al Norte.*/
       Mover(Norte)
}
procedure  DibujarLíneaRojaYNegraDeTamaño5HaciaElEste(){
     /*PROPÓSITO: Poner una línea sólida de cinco celdas de ancho hacia el Este.
         PRECONDICIONES: Hay al menos cuatro celdas al Este de la celda actual y 
                         las celdas contenidas en la misma línea están vacias.*/
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
        PonerUnaNegraYUnaRoja()
        Mover4VecesAlOeste()
}
procedure VolverAlInicioDelRectángulo(){
    /*PROPÓSITO: volver a la celda inicial del rectángulo.
      PRECONDICIONES: debe existir al menos dos celdas al Sur.*/
      Mover(Sur)
      Mover(Sur)
}
procedure PonerUnaNegraYUnaRoja(){
       /*PROPÓSITO: Poner una bolita Roja y Negra en la celda actual.
         PRECONDICIONES: la celda actual debe estar vacía*/ 
         Poner(Negro)
         Poner(Rojo)
}
procedure Mover4VecesAlOeste(){
     Mover(Oeste)
     Mover(Oeste) 
     Mover(Oeste)
     Mover(Oeste)
}
procedure PasarAProximaCelda(){
      Mover(Este)
}
//10) Escribir un programa que ponga un “arco iris”, poniendo una bolita Azul en 
//la celda actual,una Negra en la celda siguiente al Este, una Roja en la siguiente 
//al Este, y una Verde en la siguiente al Este, dejando el cabezal en la celda inicial.
procedure PonerArcoIris(){
     /* Proposito:  poner un arco iris en direccion Este.
       Precondicion: debe existir al menos tres celdas lindantes al Este.*/
       Poner(Azul)
       Mover(Este)
       Poner(Negro)
       Mover(Este)
       Poner(Rojo)
       Mover(Este)
       Poner(Verde)
       IrAlBorde(Oeste)
}
//----BIBLITECA------------------------------------------------
// a.
procedure  PonerUnaDeCada(){   
    /*PROPÓSITO: Poner en la celda actual una bolita Roja , 
                 Negra, Verde, Azul.
         PRECONDICIONES: la celda actual debe estar vacía.
    */
         Poner(Rojo)
         Poner(Negro)
         Poner(Verde)
         Poner(Azul)
}
//-------------------------------------------------------------
// b.
procedure Mover3VecesAlOeste(){
    /*PROPÓSITO:Mover el cabezal al Oeste .
      PRECONDICIONES: debe existir al menos dos celdas 
                      lindantes al Oeste.
    */
      Mover(Oeste)
      Mover(Oeste)
      Mover(Oeste)
      }
// c.
 procedure DibujarLíneaMulticolorDeLargo4() {
    /*PROPÓSITO: Dibujar una línea multicolor .
      PRECONDICIONES: debe existir al menos tres celdas vacias 
                      lindantes al Este.
    */ 
      PonerUnaDeCada()
      PasarAProximaCelda()   // realizado en punto 2.
      PonerUnaDeCada()
      PasarAProximaCelda()
      PonerUnaDeCada()
      PasarAProximaCelda()
      PonerUnaDeCada()
      Mover3VecesAlOeste()
 } 
 procedure VolverAlinicioDelCuadrado(){
    /*PROPÓSITO: Vuelve al inicio del cuadrado.
      PRECONDICIONES: debe existir al menos 3 celdas lindasnte 
                      al sur.
    */
     Mover(Sur)
     Mover(Sur)
     Mover(Sur)
 }

 procedure DibujarCuadradoMulticolorDeLado4(){
     /*PROPÓSITO: Dibuja un cuadrado multicolor .
      PRECONDICIONES: debe existir al menos 4 celdas vacias lindantes al Norte y al Este.*/
     DibujarLíneaMulticolorDeLargo4()
     PasarAProximaLínea()         // realizado en punto2.
     DibujarLíneaMulticolorDeLargo4()
     PasarAProximaLínea()
     DibujarLíneaMulticolorDeLargo4()
     PasarAProximaLínea()
     DibujarLíneaMulticolorDeLargo4()
     VolverAlinicioDelCuadrado()
}
//11) Escriba un programa que saque del tablero un cuadrado multicolor de dos celdas de lado, 
//donde la celda actual representa el vértice inferior izquierdo del mismo.
//Recuerde escribir primero el contrato del programa, y luego el código.
//Considere las siguientes preguntas como guía para escribir su programa:
//a. ¿Qué hace el programa? (Determina el propósito del programa)
//b. ¿Cuándo funciona tal cual se espera? (Determina la precondición del programa)
//c. ¿Cómo lo hace? (Determina el código del programa)
procedure SacarCuadradoDeDosMulticolor(){
    /* Proposito: sacar un cuadrado multicolor de dos celdas de largo.
       Precondicion: debe existir al menos una celda al Norte y Este con al menos una
                     bolita de cada color en cada celda.*/
    SacarCeldaMulticolor()
    PasarAproximaCelda()
    SacarCeldaMulticolor()
    PasarASiguienteCelda()   
    SacarCeldaMulticolor()
    PasarAUltimaCelda()
    SacarCeldaMulticolor()
    VolverAlInicio()
}
procedure SacarCeldaMulticolor(){
      /* Proposito: sacar una bolita de cada color de la celda actual.
         Precondicion:debe existir al menos una bolita de cada color.*/
         Sacar(Verde)
         Sacar(Rojo)
         Sacar(Negro)
         Sacar(Azul)
}
procedure PasarAproximaCelda(){
    /* Proposito: pasar a la proxima celda.
       Precondicion: debe existir al menos una celda al Norte*/
       Mover(Norte)
}
procedure PasarASiguienteCelda(){
    /* Proposito: pasar a la proxima celda.
       Precondicion: debe existir al menos una celda al Este*/
       Mover(Este)
}
procedure PasarAUltimaCelda(){
    /* Proposito: pasar a la proxima celda.
       Precondicion: debe existir al menos una celda al Sur.*/
       Mover(Sur)
}
procedure VolverAlInicio(){
    /* Proposito: volver a la celda inicial a partir de lacelda actual.
       Precondicion: debe existir al menos una celda al Oeste*/
       Mover(Oeste)
}

program{
    PonerArcoIris()
}
//1)Escribir un programa que ponga sus iniciales en el tablero usando bolitas color Verde para los nombres
//y color Rojo para el apellido, dejando el cabezal en la celda inicial. Para escribir sus iniciales, se debe
//definir cómo se verán las letras en el tablero.
procedure PonerInicialesDemiNombre(){
    /*Proposito: poner iniciales de nombre en color verde e inicial de apellido en color rojo, en tamaño de 3 celdas.
      Precondicion: tener al menos 2 celdas al norte y 10 al este.
      */
      PonerMVerde()
      PasarASiguienteInicial()
      PonerFVerde()
      PasarApellido()
      PasarASiguienteInicial()
      PonerFRojo()
      VolverAlInicio()
}
procedure PonerMVerde() {
    /*Proposito: poner una letra M verde.
      Precondicion: tener al menos 2 celdas al norte y al este.*/
      PonerColumna3Verde()
      PonerUnionMVerde()
      PonerColumna3Verde()
       }
procedure PonerColumna3Verde(){
    /*Proposito: poner una columna de 3 celdas en color verde.
      Precondicion: tener al menos 2 celdas al norte. */
     Poner(Verde)
     Mover(Norte)
     Poner(Verde)
     Mover(Norte)
     Poner(Verde)
     Mover(Sur)
     Mover(Sur)
}
procedure PonerUnionMVerde(){
    /*Proposito: poner la union central que forma la letra M en color verde, el cabezal finaliza en la prox columna.
      Precondicion: tener al 2 una celda al este y una al norte.*/
      Mover(Este)
      Mover(Norte)
      Poner(Verde)
      Mover(Sur)
      Mover(Este)
}
procedure PasarASiguienteInicial(){
    /* Proposito: pone el cabezal en la siguiente inicial.
       Precondicion: Tener al menos una siguiente inicial.*/
        Mover(Este)
        Mover(Este)
}
procedure PonerFVerde(){
    /* Proposito: pone un letra F verde.
       Precondicion: tener al menos 2 celdas al este y 2 celdas al norte.*/
        PonerColumna3Verde()
        PonerLinea2Verde()
        PonerPuntoVerde()
}
procedure PonerLinea2Verde(){
    /* Proposito: poner una linea verde de 2 celdas.
       Precondicion: Tener al menos dos celda al este y dos al norte.*/
        Mover(Este)
        Mover(Norte)
        Mover(Norte)
        Poner(Verde)
        Mover(Este)
        Poner(Verde)
}
procedure PonerPuntoVerde(){
    /* Proposito: poner un punto verde.
       Precondicion: tener al menos una celda al sur y una al oeste. */
        Mover(Sur)
        Mover(Oeste)
        Poner(Verde)
}
procedure PasarApellido(){
    /* Proposito: pasar el cabezal a la inicial del apellido.
       Precondicion: tener al menos 2 celdas al este y una al sur.*/
        Mover(Este)
        Mover(Este)
        Mover(Sur)
}
procedure PonerFRojo(){
    /*Proposito: poner una F roja.
      Precondicion: tener al menos 2 celdas al este y 2 celdas al norte.*/
      PonerColumna3Rojo()
      PonerLinea2Rojo()
      PonerPuntoRojo()
}
procedure PonerColumna3Rojo(){
    /*Proposito: poner una columna de 3 celdas roja.
      Precondicion: tener al menos 2 celdas al norte.*/
      Poner(Rojo)
      Mover(Norte)
      Poner(Rojo)
      Mover(Norte)
      Poner(Rojo)
      Mover(Sur)
      Mover(Sur)
}
procedure PonerLinea2Rojo(){
    /* Proposito: poner una linea roja de 2 celdas.
       Precondicion: tener al menos 2 celdas al este y 2 celdas al norte. */
       Mover(Este)
       Mover(Este)
       Mover(Norte)
       Mover(Norte)
       Poner(Rojo)
       Mover(Oeste)
       Poner(Rojo)
}
procedure PonerPuntoRojo(){
    /*Proposito: poner un punto rojo.
      Precondicion: tener al menos una celda al sur.*/
    Mover(Sur)
    Poner(Rojo)
}
procedure VolverAlInicio(){
    /*Proposito: poner el inicial en el inicio del tablero.
      Precondicion: tener al menos 8 celdas al oeste y una sur. */
    Mover(Sur)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
    Mover(Oeste)
}
---GUIA 2 ----------------------------------------------------------------------------------
//1)Consztruir un procedimiento PonerGuardaDe5Azulejos(), que arme una “guarda” de 5 azulejos
//(como las que decoran las paredes). Cada azulejo está conformado por 1 bolita verde, 5 negras y 9
//rojas.
procedure PonerGuardaDe5Azulejos(){
    /*PROPÓSITO: poner una guarda decorativa de cinco azulejos de largo.
      PRECONDICIONES: debe existir al menos cuatro celdas vacias lindantes al Este.*/
      PonerAzulejo()
      PasarAProximaCelda() //  realizado en el punto 2.
      PonerAzulejo()
      PasarAProximaCelda()
      PonerAzulejo()
      PasarAProximaCelda()
      PonerAzulejo()
      PasarAProximaCelda()
      PonerAzulejo()
}
procedure PonerAzulejo(){
    /*PROPÓSITO: poner un azulejo decorativo en la celda actual.
      PRECONDICIONES: la celda actual debe estar vacía.*/
      PonerDiseñoRojo()
      PonerDiseñoNegro()
      PonerDiseñoVerde()
}
procedure PonerDiseñoVerde(){
    /*PROPÓSITO: poner en la celda actual el diseño verde del azulejo.
      PRECONDICIONES: la celda actual debe estar vacía.*/
      Poner(Verde)
}
procedure PonerDiseñoNegro(){
    /*PROPÓSITO: poner en la celda actual el diseño Negro del azulejo.
      PRECONDICION: no debe existir bolitas Negras.*/
      Poner(Negro)
      Poner(Negro)
      Poner(Negro)
      Poner(Negro)
      Poner(Negro)
}
procedure PonerDiseñoRojo(){
    /*PROPÓSITO: poner en la celda actual el diseño Rojo del azulejo.
      PRECONDICIONES: no debe existir bolitas Rojas .*/
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
      Poner(Rojo)
}
//5)Utilizando bolitas pueden representarse diversos elementos; un ejemplo de esto es la posibilidad de
//representar una fecha. Una fecha que los argentinos deberíamos recordar, para no repetirla jamás, es
//el 24 de marzo de 1976, hoy constituido como Día de la Memoria por la Verdad y la Justicia en Argentina.
//Hacer un procedimiento RegistrarElDíaDeLaMemoria() que
//● en la celda actual, ponga 24 bolitas Azules, que representan el día
//● en la celda lindante al Este de la actual, ponga 3 bolitas Rojas, que representan el mes, y
//● en la celda lindante al Este de la anterior, ponga 1976 bolitas Verdes, representando el año
//3)Hacer un procedimiento PonerGuardaEnL(), que arme una guarda en L de 2x2,
//dejando el cabezal en la posición inicial.
 procedure PonerGuardaEnL(){
     /*PROPÓSITO: poner una guarda decorativa en forma de L.
       PRECONDICIONES: debe existir al menos dos celdas vacias al Norte y al Este.*/
       PonerLadoVerticalDeGuarda()
       PosicionarLadoHorizontalDeGuarda()
       PonerLadoHorizontalDeGuarda()
 }
 procedure PonerLadoVerticalDeGuarda(){
     /*PROPÓSITO: poner en forma vertical una guarda decorativa a partir de la celda actual.
       PRECONDICIONES: debe existir al menos dos celdas vacias lindantes al Norte.*/
       PonerAzulejo()
       PasarAProximoAzulejo()
       PonerAzulejo()
       PasarAProximoAzulejo()
       PonerAzulejo()
       VolverAlLadoVertiocal()
 }
 procedure PosicionarLadoHorizontalDeGuarda(){
     /*PROPÓSITO: posicionar para poner el lado horizpontal de la guarda.
       PRECONDICIONES: debe existir una celd vacía lindate al Este.*/
       Mover(Este)
 }
 procedure PasarAProximoAzulejo(){
     /*PROPÓSITO: pasar al próximo azulejo.
       PRECONDICIONES: debe existir al menos una celda lindante al Norte.*/
       Mover(Norte)
 }
 procedure VolverAlLadoVertiocal(){
     /*PROPÓSITO: volver al inicio del lado vertical del azulejo a partir de la celda actual.
       PRECONDICIONES: debe existir al menos dos celdas al Sur.*/
       Mover(Sur)
       Mover(Sur)
 }
 procedure PonerLadoHorizontalDeGuarda(){
    /* PROPÓSITO: poner en forma horizontal una guarda decorativa a partir de la celda actual.
       PRECONDICIONES:debe existir al menos una celda lindante al Este.*/
       PonerAzulejo()
       PasarAProximaCelda()  //realizado en ejercicio2-
       PonerAzulejo()
       Mover2VecesAlOeste()  
 }
 procedure Mover2VecesAlOeste(){
      /*PROPÓSITO:Mover el cabezal al Oeste .
      PRECONDICIONES: debe existir al menos dos celdas lindantes al Oeste.*/
      Mover(Oeste)
      Mover(Oeste)
 }
/*4) Escribir un programa para cultivar tomates en todo un lote de 5x3. Los procedimientos
primitivos en este ejercicio son Sembrar y Regar con los siguientes contratos:  */
procedure Sembrar()
/* PROPÓSITO: Sembrar una semilla en la celda actual
PRECONDICIONES:
* la celda actual está vacía
*/
procedure Regar()
/* PROPÓSITO: Regar la celda actual
PRECONDICIONES:
* hay una semilla sembrada en la celda actual
*/
procedure CultivarTomatesEnLoteDe5X3 (){
    /* PROPÓSITO: cutivar tomates en  un lote.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y dos al Norte vacias.
       OBSERVACION: Llamamos a una parcela auna celda.
    */
    CultivarPrimerFilaDeTomate()
    PasarAProximaFila()
    CultivarSegundaFilaDeTomate()
    PasarAProximaFila()
    CultivarTercerFilaDeTomate()
}
procedure PasarAProximaFila(){
    /* PROPÓSITO: pasa a la proxima fila de parcelas.
       PRECONDICIONES:debe existir  al menos una parcela vacia  lindante al  Norte.
       OBSERVACION: Llamamos a una parcela a una celda.
    */
    Mover(Norte)
}
procedure CultivarPimerFilaDeTomate(){
    /* PROPÓSITO: cutivar tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    SembrarFila()
    RegarFila()
}
procedure CultivarSegundaFilaDeTomate(){
    /* PROPÓSITO: cutivar tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    SembrarFila()
    RegarFila()
}
procedure CultivarTercerFilaDeTomate(){
    /* PROPÓSITO: cutivar tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    SembrarFila()
    RegarFila()
}
procedure SembrarFila(){
    /* PROPÓSITO: siembra  tomates en  una fila.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben estar vacias.
       OBSERVACION: llamamos parcela a una celda.
    */
    Sembrar() Mover(Este) Sembrar() Mover(Este) 
    Sembrar() Mover(Este) Sembrar() Mover(Este) 
    Sembrar()
    IrAlBorde(Oeste)
}
procedure RegarFila(){
    /* PROPÓSITO: riega una fila de tomates recien sembrados.
       PRECONDICIONES:debe existir al menor cuatro parcelas al Este y deben tener un tomate sembrado.
       OBSERVACION: llamamos parcela a una celda.
    */
    Regar() Mover(Este) Regar() Mover(Este)
    Regar() Mover(Este) Regar() Mover(Este)
    Regar() 
    IrAlBorde(Oeste)
}
/*6)Escribir un programa que construya una pared de ladrillos de ocho ladrillos de alto por
cuatro ladrillos de ancho, para lo cual se provee una guía al final del enunciado. Una
pared de ladrillos está compuesta por hileras de ladrillos pegadas entre sí con cemento.
Las hileras se alternan entre hileras con 4 ladrillos enteros (hilera inferior), e hileras con
3 ladrillos enteros y 2 medios ladrillos en los bordes (hilera superior). Cada fila del
tablero puede llevar 2 hileras, una hilera inferior en la parte inferior de las celdas, y una
hilera superior arriba de esa. El tablero inicial estará vacío.

Los procedimientos primitivos en este ejercicio son PonerCemento, PonerLadrillo,
PonerMedioLadrilloEnElBordeOeste y PonerMedioLadrilloEnElBordeEste
con los siguientes contratos:*/
procedure PonerCemento()
/* PROPÓSITO: Poner cemento en la celda actual
PRECONDICIONES:
* o bien la celda actual está vacía,
* o bien la celda actual tiene un ladrillo entero en la
Parte inferior, sin cemento sobre él
*/
procedure PonerLadrillo()
/* PROPÓSITO: Poner un ladrillo en la celda actual
PRECONDICIONES:
* si no hay ladrillos en la celda actual, hay
cemento en la misma
* si hay un ladrillo entero en la celda actual, hay
cemento sobre el mismo, y existe una celda al Oeste
que ya contiene un ladrillo entero y medio ladrillo del
lado izquierdo
*/
procedure PonerMedioLadrilloEnElBordeOeste()
/* PROPÓSITO: Poner medio ladrillo en la celda actual
PRECONDICIONES:
* la celda actual está en el borde Oeste
* hay un ladrillo entero en la parte inferior de la
celda actual, y cemento sobre él
*/
procedure PonerMedioLadrilloEnElBordeEste()
/* PROPÓSITO: Poner medio ladrillo en la celda actual
PRECONDICIONES:
* la celda actual esté en el borde Este
* hay un ladrillo entero en la parte inferior de la
celda actual, cemento sobre él, y medio ladrillo del lado
izquierdo de la celda
*/
/*No olvidar seguir la metodología de trabajo top-down, y utilizar nombres adecuados para
las subtareas. Como guía para la utilización de tal metodología, se proponen los
siguientes ítems. Una ayuda: para poder utilizar adecuadamente los procedimientos
primitivos, deben analizarse con cuidado las precondiciones y determinar qué tareas
deben realizarse primero.
a.
Para construir una pared, deben construirse repetidamente hileras de ladrillos en
la parte inferior de cada celda de una fila, e hileras en la parte superior, teniendo
en cuenta las precondiciones de cada una de las operaciones.
b.
Los ladrillos de la hilera superior se colocan con un corrimiento respecto de los
de la hilera inferior. Observar con cuidado la precondición del procedimiento de
colocar ladrillos enteros y probar su funcionamiento en una hilera superior, luego
de cumplir sus precondiciones.
*/
procedure ConstruirPared(){ // IMPORT--<<< La construccion se hace hacia el Este por las precondiciones dadas.
    /*PROPÓSITO: contruir una pared de ladrillos a ´partir de la celda actual.
      PRECONDICIONES: debe existir al menor tres celdas vacias al Este y al Norte.
    */
    ConstruirHilera()
    ConstruirOtraHilera()
    PasarAProxiamHilera()
    ConstruirHilera()
    ConstruirOtraHilera()
    PasarAProxiamHilera()
    ConstruirHilera()
    ConstruirOtraHilera()
    PasarAProxiamHilera() 
    ConstruirHilera()
    ConstruirOtraHilera()
    IrAlBorde(Sur)
}
procedure PasarAProxiamHilera(){
    /*PROPÓSITO: pasa a la proxima hilera a construir.  .
      PRECONDICIONES: debe existir una celda lindante al lado Este.
    */
    Mover(Norte)
}

procedure ConstruirHilera(){
    /*PROPÓSITO:construir una hilera de ladrillos a partir de la celda actual .
      PRECONDICIONES: debe existir al menos tres celdas vacias y lindas al Norte.
    */
    PonerLacrillosYCemento()
    PasarAlProximoLadrillo()
    PonerLacrillosYCemento()
    PasarAlProximoLadrillo()
    PonerLacrillosYCemento()
    PasarAlProximoLadrillo()
    PonerLacrillosYCemento()
    IrAlBorde(Oeste)
}
procedure ConstruirOtraHilera(){  // IMPORT--<<aqui tiene que moverse al Este para poner el ladrillo entero.
    /*PROPÓSITO:construir otra  hilera de ladrillos posicionados de otra forma a partir de la celda actual .
      PRECONDICIONES: debe existir al menos tres celdas vacias y lindas al Norte.
    */
    PonerMedioLadrilloEnElBordeOeste()
    PasarAlProximoLadrillo()
    PonerLadrillo()
    PasarAlProximoLadrillo()
    PonerLadrillo()
    PasarAlProximoLadrillo()
    PonerLadrillo()
    PonerMedioLadrilloEnElBordeEste()
    IrAlBorde(Oeste)
}
procedure PonerLacrillosYCemento(){
    /*PROPÓSITO: Pone cemento y ladrillos en la celda actual .
      PRECONDICIONES: la celda actual debe estar vacia.
    */
    PonerCemento()
    PonerLadrillo()
    PonerCemento()  
}
procedure PasarAlProximoLadrillo(){
    /*PROPÓSITO: pasa al proximo ladrillo a partir de la celda actual .
      PRECONDICIONES: debe esxistir al menos una celda lindante al Norte.
    */
    Mover(Este)
}
//8) El bosque, parte 1
//En este ejercicio, se usará el tablero para representar un bosque. Cada celda representa a una parcela.
//Cada bolita verde representa un árbol. Cada bolita roja representa una semilla. Una bolita negra
//representa una bomba. Una bolita azul representa una unidad de nutrientes.
//Escribir los siguientes procedimientos de representación, que hacen lo que su nombre indica. Todos
//trabajan siempre sobre la celda actual.
//a
procedure PonerUnaSemilla(){
    /*PROPÓSITO: poner una semilla en la parcela actual.
      PRECONDICIONES:en  la parcela actual no debe existir semillas.*/
      Poner(Rojo)
}
//b
procedure PonerUnÁrbol(){
     /*PROPÓSITO: poner un árbol en la parcela actual.
      PRECONDICIONES: en  la parcela actual no debe existir arbol.*/
      Poner(Verde)
}
//c
procedure PonerUnaBomba(){
     /*PROPÓSITO: poner una bomba en la parcela actual.
      PRECONDICIONES:en  la parcela actual no debe existir bombas.*/
      Poner(Negro)
}
//d
procedure PonerUnNutriente(){
    /*PROPÓSITO: poner un nutriente en la parcela actual.
      PRECONDICIONES: en  la parcela actual no debe existir nutriente.*/
    Poner(Azul)
}
//e
procedure SacarUnaSemilla(){
    /*PROPÓSITO: sacar un nutriente de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos una semilla.*/
      Sacar(Rojo)
}
//f
procedure SacarUnÁrbol(){
    /*PROPÓSITO: sacar un árbol de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos una  arbol.*/
      Sacar(Verde)
}
//g
procedure SacarUnaBomba(){
    /*PROPÓSITO: sacar una bomba de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos una  bomba.*/
      Sacar(Negro)
}
//h
procedure SacarUnNutriente(){
     /*PROPÓSITO: sacar un nutriente de la parcela actual.
      PRECONDICIONES: en  la parcela actual  debe existir al menos un nutriente.*/
      Sacar(Azul)
}
//9)Dibujar un reloj analógico de agujas en un tablero cuadriculado puede ser un desafío. Una
//simplificación posible sería representar solamente algunos de los números que aparecen en el mismo:
//el 12 arriba, el 3 a la derecha, el 9 a la izquierda y el 6 abajo.
//Construir un procedimiento DibujarRelojAnalógicoSimplificado(), que ponga los números del reloj tal como se indicó, 
//alrededor del casillero actual. El tamaño del reloj será de 2 celdas de “radio” (suponiendo que miramos al reloj como un círculo)
procedure DibujarRelojAnalógicoSimplificado(){
    /* Propósito: dibujar un reloj analógico a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes en sus cuatro direcciónes. */
    Dibujar12()
    Dibujar03()
    Dibujar06()
    Dibujar09()
}
procedure  Dibujar03(){
     /* Propósito: dibujar las  03 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Este. */
    MoverseAlEsteDelReloj()
    Poner3BolitasRojas()
    MoverseAlOesteDelReloj()
}
procedure Dibujar06(){
     /* Propósito: dibujar las  06 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Sur. */
    MoverseAlSurDelReloj()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    MoverseAlNorteDelReloj()
}
procedure Dibujar09(){
     /* Propósito: dibujar las  09 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Oeste. */
    MoverseAlOesteDelReloj()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    MoverseAlEsteDelReloj()
}
procedure Dibujar12(){
     /* Propósito: dibujar las  12 hs a partir de la celda actual.
        Precondición: debe existir al menos dos  celdas vacias lindantes al Norte. */
    MoverseAlNorteDelReloj()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    Poner3BolitasRojas()
    MoverseAlSurDelReloj()
}
procedure  MoverseAlSurDelReloj(){
     /* Propósito: mueve al Sur del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Sur.*/
    Mover(Sur)
    Mover(Sur)
}
procedure MoverseAlNorteDelReloj(){
     /* Propósito: mueve al Norte del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Norte.*/
    Mover(Norte)    
    Mover(Norte)
}
procedure  MoverseAlOesteDelReloj(){
     /* Propósito: mueve al Oeste del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Oeste.*/
    Mover(Oeste)    
    Mover(Oeste)
}
procedure MoverseAlEsteDelReloj(){
      /* Propósito: mueve al Este del reloj a partir de la celda actual.
        Precondición: debe existir al menos una celda lindante al Este.*/
    Mover(Este)
    Mover(Este)
}
procedure Poner3BolitasRojas(){
     /* Propósito: pone tres bolitas Rojas en la celda actual.
        Precondición: la celda actual debe estar vacía. */
    Poner(Rojo)  
    Poner(Rojo)
    Poner(Rojo) 
}
//10) Comenzar por redactar el contrato y la precondición correspondientes.
//a. Luego aplicar la técnica de división en subtareas expresadas con procedimientos. Dado que no
//se trata de hacer el código de nuevo, se propone identificar partes de código que se repitan,
//darles un buen nombre y extraer esa parte de la estrategia en procedimientos auxiliares. Por
//supuesto, cada procedimiento auxiliar debe tener un nombre adecuado, y debe documentarse
//su propósito y precondición.
//b. ¿Puede apreciar las ventajas de contar con el contrato y de expresar la estrategia como parte
//del código en forma de procedimientos? Hay más de una forma de dividir en subtareas.
//Comparar la solución propuesta con la de otros compañeros, y discutir las ventajas y
//desventajas de la dada con las que resulten diferentes.
procedure  ConstruirEscaleraAzulDe4Escalones(){
  /*Propósito: contruye una escalera de 4 escalones y deja el cabezal al final de la misma.
    Precondición: debe existie al menos 4 celdas vacias o sin bolitas Azules??? lindantes al Este y 
                  3 celdas vacias o sin bolitas azules???al Norte
  */
  ConstruirEscalonYPasarAlProximo()
  ConstruirEscalonYPasarAlProximo()
  ConstruirEscalonYPasarAlProximo()
  ConstruirEscalon()
}
procedure ConstruirEscalonYPasarAlProximo(){
  /*Propósito: contruye un escalon y deja el cabezal listo para construir el proximo escalon.
    Precondición: debe existie al menos una celda vacia o sin bolitas Azules??? lindantes al Este y
     una celda vacia o sin bolitas Azules?? al Norte.
  */
  Poner(Azul) Mover(Este) Poner(Azul) Mover(Norte)
}
procedure ConstruirEscalon(){
/*Propósito: contruye un escalon y deja el cabezal al final del mismo.
    Precondición: debe existie al menos una celda vacia o sin bolitas Azules??? lindantes al Este.
*/
 Poner(Azul) Mover(Este) Poner(Azul)
}
/*program {
    ConstruirEscaleraAzulDe4Escalones()
}
*/
-------GUIA3Y4-REPETICIN SIMPLE----------------------------
// 1.Escribir un procedimiento Mover3VecesAlNorte() que mueva el 
//cabezal tres posiciones al Norte de la actual.
procedure Mover3VecesAlNorte(){
    /* Propósito:mueve el cabezal hacia el Norte tres veces .
        Precondición: debe existir al menos dos celdas al Norte a partir de la celda actual.
    */
    repeat(3){
        Mover(Norte)
    }
}
// 2.Escribir un procedimiento Mover3VecesAlEste() que mueva el cabezal tres posiciones al Este de la actual.
// a. ¿Qué similitudes encuentra entre este procedimiento y el anterior?
// Todo el procedimiento es igual excepto la direccion que le paso como argumento.
// b. ¿Qué cambiaría si quisiera hacer un procedimiento que mueva tres veces al Oeste, o tres al Sur?
// Solo el argumento ya que la unica diferencia es la direccion del mismo.
procedure Mover3VecesAlEste(){
    /* Propósito:mueve el cabezal hacia el Este tres veces .
        Precondición: debe existir al menos dos celdas al Este a partir de la celda actual.
    */
     repeat(3){
        Mover(Este)
    }
}
// 3. Escribir un procedimiento Poner6DeColorNegro() que ponga 6 bolitas de color Negro en la 
// celda actual.
procedure Poner6DeColorNegro(){
    /* Propósito:pone seis bolitas Negras en la celda actual.
       Precondición: en la celda actual no debe existir bolitas Negras.
    */
    repeat(6){
        Poner(Negro)
    }
}
// 4. Escribir un procedimiento Poner6DeColorVerde() que ponga 6 bolitas de color Verde en la
//celda actual.
procedure Poner6DeColorVerde(){
    /* Propósito:pone seis bolitas Verdes en la celda actual.
       Precondición: en la celda actual no debe existir bolitas Verdes.
    */
      repeat(6){
        Poner(Verde)
    }
}
------REPETICIÓN SIMPLE EN SUBTAREAS-------------------------------------------------------------------
// 5.  Escribir un procedimiento DibujarRectánguloRojoYNegroDe5x3() que dibuje un rectángulo
//sólido de 5 celdas de largo por 3 de alto, similar al realizado en “P2. 2. Por Arriba”, pero esta vez, utilice
//repetición para solucionar el problema.
procedure DibujarRectánguloRojoYNegroDe5x3(){
    /*PROPÓSITO: Poner un rectángulo sólido de 5 celdas de ancho y 3
                    celdas de alto. Desde la celda actual hacia el Este y hacia el Norte.
     PRECONDICIONES:
                * Hay al menos 4 celdas al Este y 2 celdas al Norte de la celda actual.
                * Las celdas contenidas en el rectángulo de 5x3 desde la celda actual hacia el Este 
                   y hacia el Norte están vacias.
    */
    repeat(3){
        DibujarLíneaRojaYNegraDeTamaño5HaciaElEste()
        PasarAProximaLínea()
    }
     VolverAlInicioDelRectángulo()
}
procedure  DibujarLíneaRojaYNegraDeTamaño5HaciaElEste(){
    /*PROPÓSITO: Poner una línea sólida de cinco celdas de ancho hacia el Este.
       PRECONDICIONES: Hay al menos cuatro celdas al Este de la celda actual y 
                       las celdas contenidas en la misma línea están vacias.
    */
    repeat(4){
        PonerUnaNegraYUnaRoja()
        PasarAProximaCelda()
    }
    PonerUnaNegraYUnaRoja()
    IrAlInicioDeLínea()
}
procedure IrAlInicioDeLínea(){
    /*PROPÓSITO: ir al inicio de la línea.
      PRECONDICIONES: debe existir al menos cuatro celdas al Sur.
    */
    IrAlBorde(Oeste)
}
procedure VolverAlInicioDelRectángulo(){
    /*PROPÓSITO: volver a la celda inicial del rectángulo.
      PRECONDICIONES: debe existir al menos dos celdas al Sur.*/
      repeat(6){
         Mover(Sur)    
      }
}
procedure PonerUnaNegraYUnaRoja(){
    /* definido en guia 2 ------ 
      
      PROPÓSITO: Pone una bolita Roja y Negra en la celda actual.
      PRECONDICIONES: la celda actual debe estar vacía.
    */ 
    Poner(Negro)
    Poner(Rojo)
}
procedure PasarAProximaCelda(){
    /* definido en guia 2 ------ 
      
    */
    Mover(Este)
}
procedure PasarAProximaLínea(){
    /* definido en guia 2 ----l
      
    */
    Mover(Norte)
}

// 6. Escribir un procedimiento PintarElTableroDeAzul() que, asumiendo que el tablero tiene 10
//celdas de largo y 7 celdas de alto, pinte absolutamente todo el tablero con bolitas azules, dejando
//exactamente una bolita azul en cada celda.
//a. ¿Cuál es la precondición del procedimiento?
// La misma que el procedimiento DibujarRectánguloRojoYNegroDe5x3() con la
//diferencia del largo y del alto.  
//b. ¿Se le ocurre otra estrategia para resolver el problema?
// Reutilizaria el estrategia DibujarRectánguloRojoYNegroDe5x3() realizando los cambios necesarios para que cumpla con el proposito
// de PintarElTableroDeAzul().

//Importante Recuerde que la estrategia de solución debe quedar clara a partir de la lectura del código.
//Use subtareas con nombres apropiados para dicho objetivo
procedure PintarElTableroDeAzul(){
    /*PROPÓSITO: pinta el tablero de azul.
      PRECONDICIONES: debe existir al menos 9 celdas sin bolitas azules al Este y al menos 6 celdas sin bolitas azules al Norte.
    */
    repeat(6){
        DibujarLíneaAzul()
        PasarAProximaLínea()
    }
    DibujarLíneaAzul()
    VolverAlInicioDelTablero()
}
procedure  DibujarLíneaAzul(){
    /*PROPÓSITO: dibuja una línea azul.
       PRECONDICIONES: debe existir al menos 9 celdas sin bolitas azules al Este.
    */
    repeat(9){
        PonerUnaAzul()  
        PasarAProximaCelda() //definido ejercicio anterior =) 
    }
    PonerUnaAzul()
    IrAlInicioDeLínea() // definido ejercicio anterior =)
}
procedure VolverAlInicioDelTablero(){
    /*PROPÓSITO: vuelve a la celda inicial del tablero.
      PRECONDICIONES: debe existir al menos seis celdas al Sur.
    */
    repeat(6){
        Mover(Sur)    
    }
}
procedure PonerUnaAzul(){
    /* definido en guia 2 ------ 
      
      PROPÓSITO: Pone una bolita Azul en la celda actual.
      PRECONDICIONES: la celda actual no debe  tener bolitas azules.
    */ 
    Poner(Azul)
}
---GUIA 3Y4 REPETICIÓN SIMPLE Y PARÁMETROS: ----------------------------------------------------------
// 1.Escribir un procedimiento Mover3VecesAl_(direcciónAMover) que dada una dirección
//direcciónAMover mueva el cabezal tres posiciones en dicha dirección.
//a. ¿Qué hay que hacer ahora para mover el cabezal tres veces al Norte?
//b. ¿Qué beneficios trae el uso de parámetros?
//c. ¿Cuántos procedimientos puedo ahorrarme haciendo un único procedimiento con un parámetro?
//¡Recordar! No olvidar escribir el contrato del procedimiento ANTES de realizar el código (y que los parámetros
//son parte del mismo); también discutir la precondición escrita con sus compañeros para 
//verificar que la misma es adecuada y correcta
//---EJERCICIO BIBLIOTECA-------------------
procedure Mover3VecesAl_(direcciónAMover){
  /* PROPÓSITO: mueve a partir de la celda actual tres posiciones en dirección direcciónAMover.
     PRECONDICIONES: debe existir al menos dos celdas lindantes al direcciónAMover.
     PARÁMETRO: 
              *direcciónAMover: Dirección - Describe la dirección hacia la cual se va a mover el cabezal.
  */  
  repeat(3){
    Mover(direcciónAMover)
  } 
}
//  Escribir un procedimiento Poner6DeColor_(colorAPoner) que dado un color colorAPoner
//ponga 6 bolitas del color dado.
procedure Poner6DeColor_(colorAPoner){
    /* PROPÓSITO: pone 6 bolitas de color colorAPones.
     PRECONDICIONES: la celda actual no debe tener bolitas de color colorAPoner.
     PARÁMETRO: 
              *colorAPoner: Color - es el color de las bolitas a poner.
    */
    repeat(6){
        Poner(Azul)
    }
}
----------------MÚLTIPLES PARÁMETROS Y PARÁMETROS COMO ARGUMENTOS----------------------------
---EJERCICIOS EXTRAS---<<<EL PLANETA DE NANO--<<<<------------------------
/*
program { 
    ComerBananas() 
}
*/
procedure ComerBananas(){
    /*
    Proposito: que el mono coma todas las bananas del tablero, el mismo queda encima del tablero.
    Precondicion: debe existir bananas, deben existir al menos 9 celdas lindantes al Este y 8 al Norte , un mono para comerlas. 
    */
    ComerFilaDe_Bananas(9)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(4)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(7)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(2)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(8)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(5)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(6)
    MoverANanoHaciaArriba()
    ComerFilaDe_Bananas(3)   
}
procedure ComerFilaDe_Bananas(numeroDeBananas){
    /*
    RTA DEL EJERCICIO-->
     ESTE ES EL PROCEDIMIENTO QUE HACEMOS PARA COMER CUALQUIER FILA YA QUE EL NUMERO DE BANANAS
      VARIA EN CADA FILA.
    Proposito: que el mono se coma una fila de Numeros"numeroDeBanana" de bananas .
    Precondicion: debe existir un mono en la celda actual y un Numero "numeroDeBananas" en direccion al Este.
    Parametro:
        *numeroDeBananas: NUmero. Indica el numero de bananas a comer en direccion al Este. 
    */
    repeat(numeroDeBananas){
        MoverANanoALaDerecha()
        ComerBanana()
    }
    VolverANanoAlBordeIzquierdo()
}
--VARIAS COSAS DE UNA SOLA VEZ-------------------------------------------------------------
/*
program {
  IrALaEsquina__(Sur, Oeste)
  SacarMuchasBolitas(17, Negro)
  MoverMuchasCeldas(3,Este)
  PonerMuchasBolitas(41,Rojo)
}
*/
procedure PonerMuchasBolitas__(cantidadAPoner, colorAPoner) {
  repeat(cantidadAPoner) {
    Poner(colorAPoner)
  }
}
procedure SacarMuchasBolitas__(cantidadASacar, colorASacar) {
  repeat(cantidadASacar) {
    Sacar(colorASacar)
  }
}
procedure MoverMuchasCeldas__(cantidadDeCelasAMover,direccion){
    repeat(cantidadDeCelasAMover){
        Mover(direccion)
    }
}

//2.Escribir un procedimiento Poner_Al_(colorAPoner, direcciónDondePoner) que dado un color
//colorAPoner y una dirección direcciónDondePoner, ponga una bolita del color dado en la celda
//vecina en la dirección dada, dejando el cabezal en dicha celda.
//a. ¿Cuántos casos distintos habría que considerar si no se usarán parámetros en este caso?
//b. ¿Cómo debería invocar al procedimiento para que ponga una bolita Azul en la celda al Norte?
//c. ¿Y sí quisiera una Azul y una Roja?
procedure Poner_Al_(colorAPoner, direcciónDondePoner){
   /* PROPÓSITO: pone una bolita de color colorAPoner en la celda vecina en la dirección  
                 direcciónDondePoner, deja el cabezal en dicha celda.
     PRECONDICIONES:debe existir al  menos una celda lindante en dirección direcciónDondePoner 
                    ademas la celda vecina debe estar vacia.
     PARÁMETROS: 
              *colorAPoner: Color - es el color de las bolitas a poner.
              *direcciónDondePoner:  Dirección - Describe la dirección hacia la cual se va a poner la bolita.
    */
    Mover(direcciónAMover) 
    Poner(colorAPoner)  
}
// 3.Generalizar el ejercicio del reloj analógico simplificado de la práctica anterior para que se pueda pasar
//el radio como parámetro. O sea, se le pide escribir un procedimiento llamado
//DibujarRelojAnalógicoSimplificadoDeRadio_(radio) que ponga los números del reloj
//como en el programa original, pero donde el radio recibido por parámetro indica la distancia al centro
//del reloj: mientras más grande es el radio, más alejados están los números del centro.
//Por ejemplo, el programa del ejercicio anterior podría obtenerse invocando al procedimiento con el
//comando DibujarRelojAnalógicoSimplificadoDeRadio_(2).
procedure DibujarRelojAnalógicoSimplificadoDeRadio_(radio){
    /* Propósito: dibuja un reloj analógico de radio dos.
       Precondición: debe existir al menos numero de celdas lindantes " radio" y deben estar vacias.
       Parametros:
                  * radio: Numero - Es un numero que describe la cantidad de celdas del radio del reloj analógico. 
    */
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(12,Norte,radio,Sur)
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(3,Este,radio,Oeste)
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(6,Sur,radio,Norte)
        DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(9,Oeste,radio,Este)
}
procedure DibujarElNumero_HaciaEl_ConRadio_YVolverAl_(cantidadAPoner,direccionAMover,numeroDeRadio,direccionAVolver){
    /* Propósito: dibuja el numero "cantidadAPoner" de un reloj analógico hacia dirección "direcciónAMover" y vuelve hacia la dirección "direcciónAVolver".
       Precondición: en la celda actual no debe existir el numero de "cantidadAPoner" del color Rojo y debe existir al menos un numero "cantidadAMover" de celdas lindantes hacia dirección "direcciónAMover".
       Parametros:
                  * cantidadAPoner: Numero - es un numero que indica el numero de bolitas  a poner.
                  * direccionAMover: Direccion - describe la direccion a mover.
                  * numeroDeRadio: NUmero- indica el numero de celdas  de radio...???
                  * direccionAVolver: Direccion - describe la direccion a volver.
    */
        Mover_VecesAl_(numeroDeRadio, direccionAMover) //def ejercicio 10 (reemplazo a  MoverseAlEsteDelReloj() def en guia 2 )
        Poner_DeColor_(cantidadAPoner, Rojo) // def ejercicio 9 (fue reemplazodo Poner3BolitasRojas() definido en guia 2)
        Mover_VecesAl_(numeroDeRadio, direccionAVolver)
}
// 4.¿Se acuerdan de Nova? Es el nuevo compañero del equipo, que no tiene formación profesional, y su
//código está lleno de malas prácticas de programación. Esta vez, en su código se encontró un
//procedimiento que tiene el código hecho, pero no el contrato, y no está indentado.
//a. En primer lugar, se pide corregir los errores de Nova. No olvidar indicar en qué posición queda el
//cabezal, ni de establecer para qué son los parámetros. El código de Nova es el siguiente:
procedure Poner_ADistancia3Al_(color, dirección) {
    /* PROPÓSITO: pone una bolita de color "color" a dos celdas lindantes en dirección "dirección".
       PRECONDICIONES: debe existir al menos dos celdas lindantes hacia dirección "dirección" .
       PARÁMETROS: 
                  *color: Color - indica el color a poner.
                  *dirección: Dirección - describe la dirección de la distancia.  
    */
    Poner(color)
    Mover3VecesAl_(dirección) 
} // se corregio identacion
//b. En segundo lugar, se pide contestar la siguiente pregunta que realizó Nova: ¿Cuál es la relación
//entre el parámetro dirección de este procedimiento con el parámetro direcciónAMover de
//Mover3VecesAl_? 
// La relacion es que los dos procedimientos se mueven en la misma direccion.

// 6.Al continuar revisando código, encontramos otro procedimiento de Nova que carece de contrato y no
//sigue buenas prácticas de programación.
//a y c . Escribir el contrato faltante y corregir las malas prácticas:
procedure Pintar3Puntos_(colorPunto) {   
    /* PROPÓSITO: pinta  tres puntos  color "color" a dos  celdas lindantes en dirección "dirección" entre los mismo.
       PRECONDICIONES: debe existir al menos seis celdas lindantes hacia dirección "dirección" y deben estar vacias .
       PARÁMETROS: 
                  *colorPunto: Color - indica el color a poner.
    */
    repeat(2){
        Poner_ADistancia3Al_(colorPunto, Este) // def en ejercicio anterior
    }
    Poner(colorPunto)
              
}
//b. Ayudar a Nova a contestar la siguiente pregunta: ¿Hay alguna relación entre los parámetros de
//Poner_ADistancia3Al_ y Mover3VecesAl_?
//c. Dado que Nova no pensó en código general, basándose en el procedimiento corregido recién,
//generalizarlo para que, dado un color colorPunto, dibuje los puntos de ese color. El nuevo
//procedimiento debe llamarse Pintar3Puntos_.
// 5. Construir un procedimiento EscribirFechaConDía_Mes_Año_(día, mes, año), que permita
//representar cualquier fecha dados el día, mes y año (como números). La representación debe ser la
//misma utilizada en el ejercicio anterior donde se registró el Día de la Memoria (Azul para el día, Rojo
//para el mes y Verde para el año, en tres celdas hacia el Este).
//¡Recordar! Debe comenzarse por escribir el contrato; en este caso puede resultar útil escribir también una
//observación con la representación a utilizar.
procedure EscribirFechaConDía___(día, mes, año){
 /* Propósito: escribe una fecha del día "día", del mes "mes", del año "año", deja el cabezal al final de la fecha.
    Parámetros:
         *día: es un Número que indica del día del mes a escribir.   ???
         *mes: es un Número que indica el número de mes del año a escribir.  ???
         *año: es un Número que indica el número de año a escribir.
    Precondición: 
         *el espacio actual debe estar vacía.
         *debe existir al menos dos espacios vacíos lindantes al Este.
         *el "mes" debe estar entre los numeros 1 y 12
         *el "día" debe estar entre 1 y 30 en los "meses" igual 3, 4,6,9, 
    Observación:
         *llamamos espacio a una celda.
         * el color Azul representa los días.
         * el color Rojo representa los meses.
         * el color Verde representa el año.
*/
    PonerDía_(día)
    PasarAlSiguienteDato()
    PonerMes_(mes)
    PasarAlSiguienteDato()
    PonerAño_(año)
}
procedure PonerDía_(díaAPoner){
    /* Propósito: pone en el espacio actual el número del día "díaAPoner" dado.
        Parámetro:
         *díaAPoner: es un Número que indica el número  del día a poner
        Precondición: 
         *el espacio actual debe este vacía.
        Observación: llamamos espacio a una celda*/
    repeat(díaAPoner){
        Poner(Azul)
    }
}
procedure PonerMes_(mesAPoner){
     /* Propósito: pone en el espacio actual el número del mes "mesAPoner"
        Parámetro:
         *mesAPoner: es un Número que indica el número  del mes a poner
        Precondición: 
         *el espacio actual debe estar vacía.
        Observación: llamamos espacio a una celda*/
    repeat(mesAPoner){
        Poner(Rojo)
    }
}
procedure PonerAño_(añoAPoner){
    /* Propósito: pone en el espacio actual el número del año "añoAPoner".
        Parámetro:
         *añoAPoner: es un Número que indica el número del año a poner.
        Precondición:
         *el espacio actual debe estar vacía.
        Observación: llamamos espacio a una celda.*/
    repeat(añoAPoner){
        Poner(Verde)
    }
}
procedure  PasarAlSiguienteDato(){
     /* Propósito: pasa al siguiente dato.
        Precondición: debe existir al menos un espacio lindante al Este.
        Observación: llamamos espacio a una celda.*/
    Mover(Este)
}
//Escribir ReemplazarUnaDe_Por_(colorAReemplazar, colorPorElCualReemplazar), un
//procedimiento que dado un primer color colorAReemplazar y un segundo color
//colorPorElCualReemplazar, reemplaza una bolita del primer color por una del segundo color (En la
//celda actual).
procedure ReemplazarUnaDe_Por_(colorAReemplazar, colorPorElCualReemplazar){
    /* PROPÓSITO: reemplazar una bolita "colorAReemplazar" por una bolita "colorPorElCualReemplazar" .
       PRECONDICIONES: debe existir al menos una bolita "colorAReemplazar" en la celda actual.
       PARÁMETROS: 
                  *colorAReemplazar, : Color - indica el color a reemplazar.
                  *colorPorElCualReemplazar: Color -  indica el color por el cual se se va a reemplazar. 
    */
    Sacar(colorAReemplazar)
    Poner(colorPorElCualReemplazar)

} 
// 8. Utilizando el procedimiento Pintar3Puntos_ definido en el ejercicio anterior, construir el
//procedimiento PintarArcoIris() que ponga el tablero de la derecha cuando el tablero inicial es el
//de la izquierda. ¡A no ser como Nova, y empezar escribiendo el contrato
procedure PintarArcoIris(){
    /*PROPÓSITO: pinta un arco iris a partir de la celda actual.
       PRECONDICIONES: debe existir al menos ocho celdas lindantes hacia el Este y al Norte deben estar vacias .
    */
    Pintar3Puntos_(Negro) // definido en el punto anterior =)
    Mover(Este)           
    Pintar3Puntos_(Azul)
    Mover(Este)
    Pintar3Puntos_(Rojo)
    Mover(Este)
    Mover3VecesAl_(Oeste)
    Mover(Norte)
    Mover3VecesAl_(Este)
    Pintar3Puntos_(Verde)
    Mover3VecesAl_(Oeste)
    Mover(Sur)
}
// . Escribir un procedimiento Poner_DeColorRojo(cantidadAPoner) que dado un número
//cantidadAPoner, ponga tantas bolitas como se indica de color Rojo en la celda actual.
//a. ¿Cuántos casos posibles habría que considerar si no se usarán parámetros en este caso o el
//anterior?
procedure Poner_DeColorRojo(cantidadAPoner){
    /* PROPÓSITO: pone un número "cantidadAPoner" de bolitas color Rojo en la celda actual.
       PRECONDICIONES: la celda actual debe estar vacia.
       PARÁMETROS: 
                 *cantidadAPoner: Es un numero que indica la cantidad de bolitas de color Rojo 
                  a poner.
    */
    repeat(cantidadAPoner){
        Poner(Rojo)
    }
}
//9.c ------EJERCICIO BIBLIOTECA ------------------------------------------------------
//Escribir un procedimiento Poner_DeColor_(cantidadAPoner, colorAPoner) que
//dado un número cantidadAPoner y un color colorAPoner, ponga tantas bolitas como se indica del
//color dado de la celda actual.
procedure Poner_DeColor_(cantidadAPoner, colorAPoner){
    /* PROPÓSITO: pone un número "cantidadAPoner" de bolitas color "colorAPoner" en la celda actual.
       PRECONDICIONES: la celda actual debe estar vacia.
       PARÁMETROS:
                 *cantidadAPoner: Numero - Es un numero que indica la cantidad de bolitas a poner.
                 *colorAPoner: Color -  Es el color de las bolitas a poner.
    */
    repeat(cantidadAPoner){
        Poner(colorAPoner)
    }
} 
// 9.a  ---EJERCICIO BIBLIOTECA----------------------------------------------------------------
//Escribir Mover_VecesAl_(cantidadAMover, direcciónAMover), un
//procedimiento que dado un número cantidadAMover y una dirección direcciónAMover mueva el
//cabezal tantas veces como la dada en dicha dirección.  
procedure Mover_VecesAl_(cantidadAMover, direcciónAMover){
    /* PROPÓSITO: mueve un numero "cantidadAMover" en dirección "direcciónAMover".
       PRECONDICIONES: debe existir al menos numero "cantidadAMover" de celdas lindantes en dirección "direcciónAMover".
       PARÁMETROS:
                 *cantidadAMover: Numero - Es un numero que indica la cantidad de celdas a mover.
                 *direcciónAMover: Dirección -  describe la dirección a mover.
    */
    repeat(cantidadAMover){
        Mover(direcciónAMover)
    }
}
// 9.c  ---EJERCICIO BIBLIOTECA----------------------------------------------------------------
//Escribir un procedimiento Sacar_DeColor_(cantidadASacar, colorASacar) que
//dado un número cantidadASacar y un color colorASacar, saque tantas bolitas como se indica del
//color dado de la celda actual.
procedure Sacar_DeColor_(cantidadASacar, colorASacar){
    /* PROPÓSITO: saca un numero "cantidadASacar" de bolitas color "colorASacar" de la celda actual.
       PRECONDICIONES: debe existir al menos numero "cantidadASacar" de bolitas color "colorASacar" en la celda actual.
       PARÁMETROS:
                 *cantidadASacar: Numero - Es un numero que indica la cantidad de bolitas a sacar.
                 *colorASacar: Color -  es el color de bolitas a sacar.
    */
    repeat(cantidadASacar){
        Sacar(colorASacar)
    }
}
//10. -----BIBLIOTECA--------------------------------------------------------------------------
//Escribir el procedimiento IrAEsquina_Y_(primeraDirección,segundaDirección) que dadas dos 
//direcciones posiciona el cabezal en la esquina en dichas direcciones.
procedure IrAEsquina_Y_(primeraDirección, segundaDirección){
    /*PROPOSITO:posiciona el cabezal en la esquina dada por dos direcciones.
      PRECONDICION: debe existir al menos una celda en las  dos direcciones dadas.
      PARAMETROS: 
        *primeraDirección: es una Direccion que indica la direccion hacia donde se va a mover el cabezal por primera vez.
        *segundaDirección: es una Direccion que indica la direccion hacia donde se va a mover el cabezal por segunda vez.
    */
    Mover(primeraDirección)
    Mover(segundaDirección)
}
//13. El bosque, parte 2.
//Continuaremos representando el bosque que comenzamos en la práctica anterior. Esta vez queremos ser capaces de poner 
// o sacar múltiples elementos de una sola vez.
//Importante: para realizar este ejercicio se espera haya realizado la parte 1 de la Práctica 2, si aún no lo hizo, se
//recomienda volver y realizar el mismo previo a solucionar el ejercicio actual.
//a.
procedure Poner_Semillas(cantidadDeSemillasAPoner){
    /* PROPÓSITO: pone una cantidad "cantidadDeSemillasAPoner" de la parcela actual.
       PRECONDICIONES: no debe existir una cantidad "cantidadDeSemillasAPoner" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeSemillasAPoner: Numero - es un numero que indica las semillas a poner.
    */
    repeat(cantidadDeSemillasAPoner){
        PonerUnaSemilla()   // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    } 
}
//b.
procedure Sacar_Semillas(cantidadDeSemillasASacar){
    /* PROPÓSITO: saca una cantidad "cantidadDeSemillasASacar" de la parcela actual.
       PRECONDICIONES: debe existir una cantidad de "cantidadDeSemillasASacar" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeSemillasASacar: Numero - es un numero que indica las semillas a sacar.
    */
    repeat(cantidadDeSemillasASacar){
        SacarUnaSemilla()        // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//c.
procedure Poner_Árboles(cantidadDeÁrbolesAPoner){
    /* PROPÓSITO: pone una cantidad "cantidadDeÁrbolesAPoner" de la parcela actual.
       PRECONDICIONES: no debe existir una cantidad "cantidadDeÁrbolesAPoner" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeÁrbolesAPoner: Numero - es un numero que indica los arboles a poner.
    */
    repeat(cantidadDeÁrbolesAPoner){
        PonerUnÁrbol()            // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//d.
procedure Sacar_Árboles(cantidadDeÁrbolesASacar){
     /* PROPÓSITO: saca una cantidad "cantidadDeÁrbolesASacar" de la parcela actual.
       PRECONDICIONES: debe existir una cantidad de "cantidadDeSemillasASacar" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeÁrbolesASacar: Numero - es un numero que indica los arboles a sacar.
    */
    repeat(cantidadDeÁrbolesASacar){
        SacarUnÁrbol()               // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//e.
procedure Poner_Nutrientes(cantidadDeNutrientesAPoner){
    /* PROPÓSITO: pone una cantidad "cantidadDeNutrientesAPonerAPoner" de la parcela actual.
       PRECONDICIONES: no debe existir una cantidad "cantidadDeNutrientesAPoner" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeNutrientesAPoner: Numero - es un numero que indica los nutrientes a poner.
    */
    repeat(cantidadDeNutrientesAPoner){
        PonerUnNutriente()        // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//f.
procedure Sacar_Nutrientes(cantidadDeNutrientesASacar){
     /* PROPÓSITO: saca una cantidad "cantidadDeNutrientesASacar" de la parcela actual.
       PRECONDICIONES: debe existir una cantidad de "cantidadDeNutrientesASacar" en la parcela actual.
       PARÁMETROS:
                 *cantidadDeNutrientesASacar: Numero - es un numero que indica los nutrientes a sacar.
    */
    repeat(cantidadDeNutrientesASacar){
        SacarUnNutriente()      // definido en ejercicio se espera haya realizado la parte 1 de la Práctica 2
    }
}
//13.Listado de fechas
//Construir un programa que escriba un listado vertical con las siguientes fechas:
//● Inicio de la Reforma Universitaria.
//● Reglamentación del voto femenino en Argentina.
//● Fecha en la que ocurrieron los hechos conmemorados en el Día Internacional de los
//Trabajadores.
//● Creación del Ministerio de Ciencia y Tecnología argentino.
//● Primera celebración del Día de la Mujer.
//¿Es necesario pensar procedimientos para escribir cada una de las fechas o sirve algo de lo realizado
//con anterioridad?
//---------------------------------------------------------------------------------------------------------------------
procedure DibujarRelojAnalógicoDeColor_SimplificadoDeRadio_(color, radio){
    /* PROPÓSITO: dibujar un reloj analógico a partir de la celda actual.
       PRECONDICIONES: debe existir al menos numero de "radio" de celdas vacias lindantes en sus cuatro direcciónes.
                      También radio debe sel mayor o igual a 1.
       PARÁMETROS:
                 * radio: Numero - Es un numero que indica el radio del reloj analógico.
                 * color: Color - Es el color del reloj analógico.
    */
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(12, color,radio,Norte, Sur)
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(3, color,radio,Este,Oeste)
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(6, color,radio,Sur, Norte)
        DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(9, color,radio,Oeste, Este)
}
procedure DibujarElNúmero_DeColor_DeRadio_HaciaEl_YVolverAl_(cantidadAPoner,colorAPoner,cantidadAMover,direcciónAMover,direcciónAVolver){
    /* Propósito: dibuja el numero "cantidadAPoner"  de  color "colorAPoner" de un reloj analógico de radio "radio" hacia dirección "direcciónAMover" y vuelve hacia la dirección "direcciónAVolver".
       Precondición: debe existir al menos un numero "cantidadAMover" de celdas lindantes en dirección "direcciónAMover" y deben estar vacias.
       Parametros:
                  * cantidadAPoner: Numero - es un numero que indica el numero a poner.
                  * cantidadAMover: Numero - es un numero que indica el numero a mover.
                  * colorAPoner: Color - es el color a poner
                  * direccionAMover: Direccion - describe la direccion a mover.
                  * direccionAVolver: Direccion - describe la direccion a volver.
    */
    Mover_VecesAl_(cantidadAMover, direcciónAMover)  //def ejercicio 10 (reemplazo a  MoverseAlEsteDelReloj() def en guia 2 )
    Poner_DeColor_(cantidadAPoner, colorAPoner ) // def ejercicio 9 (fue reemplazodo Poner3BolitasRojas() definido en guia 2)
    Mover_VecesAl_(cantidadAMover, direcciónAVolver)
}
// 16.EN PAPEL ¡Nova volvió a hacer de las suyas! Esta vez, el código que escribió no funciona y hay que
//corregirlo. Parece que uno de los problemas de corrección está en el alcance de los parámetros, pero
//no es el único. Aprovechar también para mejorar los nombres de los procedimientos, y también para
//generalizar el tamaño del cuadrado.
procedure DibujarCuadraditoDeLado_DeColor_(numeroDeLado, colorDeCuadrado) {
/*
PROPÓSITO: Dibuja un cuadrado sólido de largo numero "numeroDeLado" y de color "colorDeCuadrado".// es cofrecta el propo?????
PRECONDICIONES: debe existir al menos numero "numeroDeLado"  al Norte y  
                al Este a partir de la actual.Las mismas deben estar vacias.
PARAMETROS:
          *numeroDeLado: Numero - indica el largo del lado del cuadrado.
          *colorDelCuadrado: Color - es el color del cuadradito a dibujar
*/
    repeat(numeroDeLado){
        DibujarLínea_DeLargoDe_(numeroDeLado, colorDeCuadrado)
        Mover(Norte)
    }
    repeat(numeroDeLado){
            Mover(Sur)
    }
}
procedure DibujarLínea_DeLargoDe_(numero,colorDeLinea) {
/*
PROPÓSITO: Dibuja una línea de largo numero "numero" de color "colorDeLinea".
PARAMETROS:
           *colorDeLinea: Color - un color el cual se dibujar la linea.
           *numero: Numero - indica el numero del largo de la linea.
PRECONDICIONES: existe al menos 1 celda al Este de la actual
*/
    repeat(numero){
         Poner(colorDeLinea)
         Mover(Este)
    }
    IrAlBorde(Oeste)   
}
-GUIA5 --<<-EXPRESIONES Y TIPOS---<<------------------------------------
--<<<---LO QUE APREND---<<<<
//Son como las expresiones literales(numero,color,direccion,bool). Las expresiones primitivas 
//(nroBolitas(),nroBolitas(Negro),hayBolitas(), hayBolitas(Rojo),puedeMover(),puedeMover(Este)) 
// Describen informacion.
//Cuando llamo una funcion primitiva luego va los parentesis y las uso como una expresion
 --<<<<--EJERCICIOS INTRODUCTORIOS =)--<<<-----------------------------------------------------------
//El cabezal juega hacer mimo
program {
    PROPOSITO: pone tantas bolitas Rojas como numero de Azules existanen la celdda actual.
    PRECONDICION: debe existir al menos una bolita Azul en la celda actual.

repeat(nroBolitas(Azul)){   // =(  MAL PROCEDIMIENTO YA QUE MEZCLO NIVELES LO MAS ADECUADO 
                            //SERIA USAR LOS PROCEDIMIENTOS PARAMETRIZADO EN LAS BIBLIOTECA
    Poner(Rojo)
}
Poner_DeColor_(nroBolitas(Azul),Rojo) //  ok =)
}
// El mimo que suma
procedure ImitarNegrasYAzules(){
    /*--
    */
    Poner_DeColor_(nroBolitas(Azul) + nroBolitas(Negro),Rojo)
    
}
// La flecha enloquecio
//Aqui uso primero el operador luego la funcion que me da una direccion
program{
    MoverAlRatónA_(opuesto(dondeApuntaLaFlecha()))
}
//Laberinto.
procedure SalirDElLaberinto(){
    /*....
    */
    repeat(20){
        AvanzarUnPasoSiguiendoLaFecha()
    }
}
procedure AvanzarUnPasoSiguiendoLaFecha(){
    /*..
    */
    MoverAlRatónA_YSacarLaFlecha(dondeApuntaLaFlecha())
}
//--IMPORTANTE------------------
// LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA
//( PARA NO VER BOLITAS EN EL CODIGO).
//1.Escribir DibujarBanda_EnDiagonalNEDe_x_(color,alto,largo) que dibuja una banda diagonal
// ancha. Por ejemplo, en la figura se observa el resultado de ejecutar 
//DibujarBanda_EnDiagonalNEDe_x_(Negro, 3, 5)en un tablero de 5x7, comenzando en la esquina 
//SO del tablero.

HACER!!!!!

//2. Moviendo según me indican las bolitas
//Escribir el procedimiento Mover_SegúnColor_(dirección,color), que mueve el cabezal en la
//dirección dada tantas celdas como bolitas de color dado hay en la celda actual. Como ejemplos se
//ofrecen los resultados de evaluar el comando Mover_SegúnColor_(Este, Negro), en diferentes
//tableros iniciales.
procedure Mover_SegúnColor_(dirección,color){
    /*Propósito: mueve hacia dirección "dirección" según el color "color".
       Parámetros: 
        *color: Es un Número que indica las veces del movimiento del cabezal .
        *dirección: Es una Dirección que indica la dirección a mover. 
       Precondición: 
        *Deben existir al menos el número de celdas color "color" lindantes en dirección "dirección".*/
        repeat(nroBolitas (Negro)){
            Mover(Este)
    }
}
//4. El bosque, parte 3
//En este ejercicio continuaremos con nuestro bosque, esta vez colocando semillas y árboles en la celda
//lindante hacia alguna dirección, y dejando el cabezal en la celda inicial.
//a.
// LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA( PARA NO VER BOLITAS EN EL CODIGO).
procedure Poner_SemillasAl_(cantidadDeSemillas, direcciónAPoner){
     /*Propósito: pone una cantidad "cantidadDeSemillas" de semillas en la dirección "direcciónAPoner".
       Parámetros: 
        *cantidadDeSemillas: es un Número que indica la cantidad de semillas a poner.
        *direcciónAPoner: es una Dirección que indica la dirección donde se va a poner la cantidad de semillas.
       Precondición: debe existir al menos una parcela vacía en dirección "dirección".
       Observación: llamamos parcela a una celda.*/
        Mover(direcciónAPoner)
        repeat(cantidadDeSemillas){
            PonerUnaSemilla()         //def. guia 2 ejercicio 8.
    }
        Mover(opuesto(direcciónAPoner))
}
// deja el cabezal en la celda inicial
//b. 
procedure Sacar_ÁrbolesAl_(cantidadDeÁrboles, direcciónASacar){
    /*Propósito: saca una cantidad "cantidad" de árboles en la dirección "dirección".
      Parámetros: 
        *cantidadDeÁrboles: es un Número que indica la cantidad de árboles a sacar.
        *direcciónASacar: es una Dirección que indica la dirección donde se va a sacar la cantidad de árboles.
      Precondición: debe existir al menos una parcela vacía en dirección "dirección" 
                    debe existir cantidad "cantidadDeÁrboles" para sacar.
       Observación: llamamos parcela a una celda.
    */
        Mover(direcciónASacar)
        repeat(cantidadDeÁrboles){
            SacarUnÁrbol()             // Def. guia 2 ejercicio 8.
        }
        Mover(opuesto(direcciónASacar))
}
// deja el cabezal en la celda inicial
//c.
procedure Sacar_SemillasEnDiagonalAl_Y_(cantidadDeSemillas, primeraDirDiagonal, segundaDirDiagonal){
    /*Propósito: saca una cantidad "cantidadDeSemillas" de semillas en las diagonales dirección "primeraDirDiagonal" y
                 dirección "segundaDirDiagonal".
      Parámetros: 
        *cantidadDeSemillas: es un Número que indica la cantidad de semillas a sacar.
        *primeraDirDiagonal: es una Dirección que indica la dirección donde se va a sacar la primer  diagonal de semillas.
        *segundaDirDiagonal: es una Dirección que indica la dirección donde se va a sacar la segunda diagonal de semillas.
      Precondición: debe existir al menos una parcela con cantidad "cantidadDeSemillas" en dirección "primeraDirDiagonal" 
                    debe existir al menos una parcela con cantidad "cantidadDeSemillas" en dirección "segundaDirDiagonal"
       Observación: llamamos parcela a una celda.
    */
}
// deja el cabezal en la celda inicial
//d.
Sacar_ÁrbolesEnDiagonalHorariaAl_(cantidadDeÁrboles, direcciónDiagonal)
//la diagonal horaria de una dirección es aquella dada por la dirección y su dirección siguiente.
// Ej. la diagonal horaria de Norte es Norte-Este, la de Sur es Sur-Oeste.
// deja el cabezal en la celda inicial

//5. Aprendiendo a leer y escribir
//Hacer el procedimiento PasarPalabraActualAMayúsculas() que suponiendo que en la fila actual
//se codifica una palabra en minúsculas usando bolitas, ponga la misma palabra en mayúsculas en la fila al Norte.
//- Cada letra se representa con una cantidad diferente de bolitas negras, según un código numérico llamado ASCII.
//- En la celda más al Oeste de la fila actual se codifica la cantidad de letras de la palabra, usando bolitas rojas.
//- La primera letra de la palabra está en la celda lindante al Este de la que contiene la cantidad de letras.
//- En el código ASCII si las letras mayúsculas se codifican con un número N entonces la misma letra minúscula se 
//representa con N+32 (ej. la ‘a’ minúsculas se representa con el número 97 y la ‘A’ mayúsculas, con el 65).
//- El cabezal se encuentra en la celda más al Oeste de una fila donde hay una palabra representada.
//Importante: ¿Cómo comenzar la resolución? En cada procedimiento, ¿qué parte debe escribirse primero?
program {
    // LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA( PARA NO VER BOLITAS EN EL CODIGO).
    PasarPalabraActualAMayúsculas()
}
procedure PasarPalabraActualAMayúsculas() {
    /*
    proposito: pasa la palabra actual a mayúsculas a partir de la celda actual.
    precondicion:
        * debe haber al menos una bolita color Rojo en la celda actual.
        * debe haber tantas celdas vacias como  el numero de  bolitas Rojas lindantes al Este y
          lo mismo una al Norte mas una celda donde se representaria con bolita Rojas el 
          numero de letras que tiene la palabra.
    observaciones: cada letra se representa con una cantidad diferente de bolitas negras, 
                   según un código numérico llamado ASCII.
                 - En la celda más al Oeste de la fila actual se codifica la cantidad de letras de la palabra, usando bolitas rojas.
                 - La primera letra de la palabra está en la celda lindante al Este de la que contiene la cantidad de letras.
                 - En el código ASCII si las letras mayúsculas se codifican con un número N entonces la misma letra minúscula se 
                   representa con N+32 (ej. la ‘a’ minúsculas se representa con el número 97 y la ‘A’ mayúsculas, con el 65).
    */
    repeat (nroBolitas(Rojo)) {
        PasarASiguienteLetra()
        PonerLetraAMayúscula()
    }
    IrAlBorde(Oeste) // def en guia 3 =)
}
procedure PasarASiguienteLetra() {
    /*
    proposito: pasar a la siguiente letra.
    precondicion: debe haber al menos 1 celda hacia el este de la actual.
    */
    Mover(Este)
}
procedure PonerLetraAMayúscula() { 
    /*
    Aca generalizo la letra no importa el numero la pasa a mayuscula.
    Convierto en letra  el Número de bolitas Negras que representa ese número,
    comienzo a usar las expresiones en este caso nroBolitas  que es como poner numeros, 
    colores o direcciones

    proposito: pone la letra actual a mayúsculas.
    precondicion:
        * la celda actual debe contener una letra en minúsculas.
        * debe haber al menos 1 celda hacia el norte de la actual.
    */
    PonerLetra_AlNorteEnMayúscula(nroBolitas(Negro)) 
    // Argument:con lo que se representa cada letra que es el Numero de bolitas Negro
}
procedure PonerLetra_AlNorteEnMayúscula(numeroDeLetra) {
    /**Es el primer subtarea que tengo que hacer y pensar
    *Argument:es lo que representa cada numero de bolitas Negras o lo que generalizo en este caso la letra.
    Para convertirla tengo que moverme al norte y al numero de letra cualquiera sea la letra
     le resto 32 y ya la  pase a mayuscula.

    proposito: pone la letra "numeroDeLetra" actual en mayúsculas hacia el Norte a partir de la celda actual.
    parametros:
        * numeroDeletra; tipo Numero, describe el numero de la letra a poner
    precondicion: debe existir una letra en la celda actual y debe haber una celda vacia hacia el norte a partir de la actual.
    */
    Mover(Norte)
    Poner_DeColor_(numeroDeletra - 32, Negro) // ejercicio de biblioteca guia 4
    Mover(Sur)
}

//---BIBLIOTECA EJERCICIO ---------------------------------------------------------------------------------------------
//6. Sacando todas las de un color
//Escribir un procedimiento SacarTodasLasDeColor_(colorASacar), que quite de la
//celda actual todas las bolitas del color indicado por el parámetro.
//PISTA: Considerar utilizar el procedimiento Sacar_DeColor_, definido en la práctica anterior. ¿Qué argumentos 
//se le deberían pasar?
procedure SacarTodasLasDeColor_(colorASacar){
    /*Propósito: saca todas las bolitas de color "colorASacar" de la celda actual.
    Parametros: 
        *colorASacar: Es un color que describe  el color de las bolitas a sacar de la celda.
    Precondicion: Debe existir al menos la cantidad dada a sacar de bolitas "colorASacar" en la celda actual.*/
      Sacar_DeColor_Veces(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9.
}

//---EJERCICIO BIBLIOTECA--------------------------------------------------------------------------------------------
//7. ¿Y si vaciamos la celda?
//Escribir un procedimiento VaciarCelda() que quite de la celda actual todas las bolitas de todos los colores, 
//dejando la celda vacía.
procedure VaciarCelda(){
     /*Propósito: quite de la celda actual todas las bolitas de todos los colores.
       Precondicion: debe existir bolitas de todos los colores en la celda actual.
     */
        SacarTodasLasDeColor_(colorASacar)
        SacarTodasLasDeColor_(colorASacar)
        SacarTodasLasDeColor_(colorASacar)
        SacarTodasLasDeColor_(colorASacar)
}
//8. ¡A la batalla!, parte 1
//Suponiendo que se está programando un juego donde en las celdas del tablero se representan
//Soldados (los aliados con una bolita de color Negro y los enemigos con una bolita de color Rojo por
//cada soldado), escribir los siguientes procedimientos:
//a. EnviarAliadosParaDuplicarEnemigos(), que agrega soldados aliados en la celda actual
//en cantidad suficiente para que haya el doble de aliados que de soldados enemigos.
// LA ONDA SERIA AGREGAR EXPRESIONES QUE DEN ABSTRACCIONA AL PROBLEMA( PARA NO VER BOLITAS EN EL CODIGO).
procedure EnviarAliadosParaDuplicarEnemigos() {
    /*
    PROPOSITO: agrega el doble de soldados aliados que de enemigos en la celda actual.
    PRECONDICIONES: no tiene.
    OBSERVACIONES: 
        * los soldados aliados se representan con una bolita de color Negro. 
        * los soldados enemigos con una bolita de color Rojo.
    */
    Poner_DeColor_(nroBolitas(Rojo) * 2 , Negro)
}
//b. PelearLaBatalla(), que simula una batalla, suponiendo que hay suficiente cantidad de
//soldados aliados como para ganar la batalla. Durante una batalla, 2 soldados enemigos pelean
//contra 3 soldados aliados y todos mueren. Por ejemplo, si hay 6 enemigos y 10 aliados, mueren
//los 6 enemigos y 9 de los aliados; si hay 10 enemigos y 21 aliados, mueren los 10 enemigos y 15 soldados aliados.
//PISTA: ¿Qué cuenta hay que hacer para saber cuántos soldados aliados morirán?
procedure PelearLaBatalla() {
    /*
    PROPOSITO: simula una batallaen la celda actual???? .
    PRECONDICIONES: debe haber mayor cantidad de soldados aliados que enemigos.
    */
    Sacar_DeColor_((nroBolitas(Rojo) * 3) div 2, Negro) 
    SacarTodasLasDeColor_(Rojo) // def ejercicio anterior
}
//9. -----SOPORTE TECNICO------
/* REPRESENTACIÓN DEL DOMINIO
   - los virus se representan con bolitas Rojas, de 1 a 6 
   - una indicación de que la máquina de la celda actual no 
     tiene virus (indicación de OK) se representa con una 
     bolita Verde
   - el Hall del edificio en la celda 0,0 con la cantidad de 
     pisos representada por las bolitas Azules
   - el Hall del piso en la celda del borde Oeste de cada piso, 
     con la cantidad de máquinas del piso representada por las 
     bolitas Negras 
*/
program {
RepararEdificio()
}
procedure RepararEdificio(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del edificio. 
         El cabezal queda en el Hall del último piso 
         del edificio (el hall más al Norte)
     PRECONDICIONES: 
       * el cabezal debe estar en la hall del edificio
  */
  repeat(nroBolitas(Azul)){
    PasarAlProximoPiso()
    RepararPiso() 
  }
}
procedure PasarAlProximoPiso(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar el proximo piso a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Norte)
}
procedure RepararPiso(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del piso actual
         (sacando todos los Virus de las máquinas del piso)
     PRECONDICIONES: 
       * la celda actual es el Hall del piso
  */
  repeat(nroBolitas(Negro)){
    PasarAProximaMáquina()
    RepararMáquina() 
  }
  IrAlBorde(Oeste)
}
procedure PasarAProximaMáquina(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar la proxima maquina a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Este)
}
procedure RepararMáquina(){
  /* 
     PROPÓSITO: 
       * eliminar los virus de la celda actual y dejar 
         la marca de OK 
     PRECONDICIONES: 
       * en la celda actual hay una máquina con virus
         y sin marcas de OK
  */
  repeat(nroBolitas(Rojo)){
      Sacar(Rojo)
    }
  IndicarOk()
}
procedure IndicarOk() {
  /* 
     PROPÓSITO: 
       * indicar que la máquina de la celda actual no tiene 
         virus poniendo la indicación de OK
     PRECONDICIONES: 
       * la máquina de la celda actual no tiene virus ni 
         indicación de OK
  */
  Poner(Verde)
}
procedure SacarTodas_(colorASacar) {
  /*
     PROPÓSITO: 
       * sacar de la celda actual todas las bolitas 
         del color dado
     PRECONDICIONES: 
       * ninguna (es una operación total)
     PARÁMETROS:
       * colorASacar es un color, que indica el color 
          de las bolitas que se deben sacar
  */
  Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9
}
/* LO QUE APRENDI--------
 que es importante moverse despues de las repeticiones que use segun el nro de maquinas 
que tenga en el piso para chequear(nro de bolita Negro) lo mismo pasa en las de los pisos
que se represento con nro de bolitas Azules. <3
 
  Es mejor usar el Mover_VecesAl_(numero,direccion) o Poner_DeColor(numero,color), etc.
*/
------UNIDAD6-----<< ALTERNATIVA CONDICIONAL--<<--------------
--<<EJERCICIOS INTRODUCTRIOS---<<<------------------------------------
//Apagar la luz o prenderla
procedure SimularInterruptorDeLuz(){
    /*__
    */
    if(hayBolitas(Azul))then{
         Poner(Negro) Sacar(Azul)
    }
}
//NO me quiero caer
procedure DibujarLaVibora(){
    /*....
    */
    repeat(10){
        DefinirSegmentoDeViboraYAvanzar()
    }
}
procedure DefinirSegmentoDeViboraYAvanzar(){
    /*...
    */
    if(puedeMover(Este)){
        Poner(Verde) Mover(Este)
    }
    else{ 
        Poner(Verde) Mover(Norte)
    }
}
// Siempre el mejor!  
procedure CombatirGikachuVsGarmander(){
    /* nos enseña a usar la multialternativa.
    Proposito:
    Precondicion:
    */
    if(nroBolitas(Rojo) == nroBolitas(Negro)){
        ProcesarEmpate()
    }
    elseif (nroBolitas(Rojo) >= nroBolitas(Negro) ){
         SacarGikachu()  
    }
    else { 
        SacarGamander()
    }
}
procedure ProcesarEmpate(){
    /*
    Proposito:
    Precondicion:
    */
    SacarTodasLasDeColor_(Negro)
    SacarTodasLasDeColor_(Rojo)
}
procedure SacarGamander(){
    /*
    Proposito:
    Precondicion:
    */
    SacarTodas_(Rojo)
}
procedure SacarGikachu(){
    /*
    Proposito:
    Precondicion:
    */
    SacarTodas_(Negro)
}
//No, no y no. 
procedure CompletarLaFilaDePelotas(){
    /* 
     Nos enseña el uso de la negacion =)

        Proposito:
        Precondicion:
    */
        repeat(4){
            AgregarPelotaSiHaceFalta()
            IrALaSiguientePosicionAControlar()
        }
        AgregarPelotaSiHaceFalta()
}
procedure AgregarPelotaSiHaceFalta() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
        ...
    */
        if(not hayPelota())then{
             AgregarPelota()
        }
}
procedure IrALaSiguientePosicionAControlar() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
            * ....
    */
        Mover(Sur)   
}
------------ FUNCIONES SIMPLES---------------------------------------------------------------
-----EJERCICIOS INTRODUCTORIOS---------------------------------------------------------------
//La luz esta prendida vs hay bolitas.
procedure SimularInterruptorDeLuz(){
    if(laLuzEstaPrendida()) then{  //aqui cambio hayBolitas(Azul)por hayLuz() 
        ApagarLaLuz()
    } 
    else { 
        PrenderLaLuz()
    }
}
function laLuzEstaPrendida() {
    /*
        PROPÓSITO: Indica si esta prendida la luz en la celda actual.
        PRECONDICIONES: Ninguna. es una funcion total.
        RESULTADO:Booleano.Verdadero cuando hay luz en la celda actual,
                   Falso en el caso contrario.
    */
     return( (nroBolitas(Azul)) == 1)
}
procedure PrenderLaLuz() {
    Poner(Azul)
    Sacar(Negro)
}
procedure ApagarLaLuz(){
    Poner(Negro)
    Sacar(Azul)
}
// Y tambien...(Mantener el cantero.)
function hayFlor(){
    return ((hayBolitas(Rojo) == 2) && (hayBolitas(Verde) == 1))
}

procedure MantenerElCantero(){
    repeat(9){
        MantenerSeccionDelCantero()
        IrALaSiguienteSeccionDelCantero()
    }
    MantenerSeccionDelCantero()
}
procedure MantenerSeccionDelCantero(){
    if(not (hayFlor()))
     then { PantarFlor()
          }
}
procedure IrALaSiguienteSeccionDelCantero(){
    Mover(Este)
}
procedure PantarFlor(){
    repeat(2){
        Poner(Rojo)
    }
    Poner(Verde)
}
// Salir del laberinto comiendo el queso.
procedure ComerQuesoSiHay() {
    /*
     Lo que aprendi que ¿esta bien que explote  ????????????seeeeeeee =)
     Cada procedure (subtarea) soluciona una alternativa condicional(no anidar).
     Y que lo cuerpos de las repeticiones quizas invoco a las  subtareas con condicionales, 
     y con multitareas.
       
        PROPÓSITO:  ....
        PRECONDICIONES:
        
    */
    if(hayQueso()){
        ComerElQueso()
    }
}
procedure ComerQueso() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
    */
    Sacar(Verde)
}
procedure SaliDelLaberintoComiendoQueso() {
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
    */
    repeat(20){
        ComerElQuesoSiHay()
        AvanzarUnPasoSiguiendoLaFlecha()
    }    
}
procedure AvanzarUnPasoSiguiendoLaFecha(){
    /*
        PROPÓSITO:  ....
        PRECONDICIONES:
    */
    if(laFlechaApuntaAlNorte()){
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Norte) //primitiva
    }
    elseif (laFlechaApuntaAlEste()) {
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Este) //primitiva
    }
    elseif(laFlechaApuntaAlSur()){
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Sur) //primitiva
    }
    else{
        SacarLaFlecha() //primitiva
        MoverAlRatonAl_(Oeste) //primitiva
     }
}
function laFlechaApuntaAlNorte() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 1))
}
function laFlechaApuntaAlEste() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 2))
}
function laFlechaApuntaAlSur() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 3))
}
function laFlechaApuntaAlOeste(){
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Rojo) == 4))
}
function hayQueso() {
    /*
        PROPÓSITO:  ....
        TIPO: Tipo
        PRECONDICIONES:
    */
    
    return ((nroBolitas(Verde)) == 1)
}

// Esta lista la cena
program{
    if(estaListaLaCena) then{
         AvisarQueVengan()
    }
    else{ 
        AvisarQueTodaviaFalta()
    }
}
function estáListaLaCena() {
    /*
        PROPÓSITO: indica si esta lista la cena en la celda actual.
        TIPO: Bool, verdadero cuando esta lista la cena en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return (estáElPlatoPrincipalEnLaMesa() 
            &&
            estáElPostreEnLaMesa()
            )
}
function estáElPostreEnLaMesa(){
    /*
        PROPÓSITO: indica si esta el postre en la celda actual.
        TIPO: Bool, verdadero cuando esta el postre  en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return(estáLafrutaenLaMesa()
            ||
            estáLaTortaEnLaMesa()
           )
}
function estáElPlatoPrincipalEnLaMesa(){
    /*
        PROPÓSITO: indica si esta el plato principal en la celda actual.
        TIPO: Bool, verdadero cuando esta el plato principal en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return( estáElBifeConEnsalada()
            ||
            estáElGobCombo()
          )
}
function estáElBifeConEnsalada(){
    /*
        PROPÓSITO: indica si esta el bife con ensalada o el Gobcombo en la celda actual.
        TIPO: Bool, verdadero cuando esta el bifecon ensalada o Gobcombo  en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return ( estáElBifeEnLaMesa()
            &&
            estáLaEnsaladaEnLaMesa()
           )
}
function estáElGobCombo(){
    /*
        PROPÓSITO: indica si esta el Gobcombo en la celda actual.
        TIPO: Bool, verdadero cuando esta Gobcombo  en la celda actual, falso en caso contrario.
        PRECONDICIONES: NInguna es una funciona total.
    */
    return( estáLaHamburguesaEnLaMesa()
           &&
           estánLasPapasFritasEnLaMesa()
          )
}
/*2. Definir funciones totales que sean verdaderas (describan al valor de verdad
Verdadero) para cada uno de los siguientes casos. Recordar que es conveniente
utilizar funciones para expresar subtareas, de forma que las expresiones utilizadas
no queden imposibles de entender. Recordar también que antes de escribir el código
de una operación, debe escribirse el contrato de la misma (nombre, parámetros,
propósito y precondiciones).
a. Cuando la celda actual tiene más de 5 bolitas en total.
b. Cuando la celda actual tiene al menos 5 bolitas en total.
c. Cuando la celda actual tiene al menos 5 bolitas en total y el borde se
   encuentra justo al Este de la misma.
d. Cuando la celda actual tiene una celda lindante al Norte o al Este.
e. Cuando la celda actual tiene bolitas de todos los colores.
f. Cuando en la celda actual faltan bolitas de al menos un color (dar una
   solución sin usar la funciónes.  
a.*/ 
function mayorACinco(){   // FEA EXPRESION y no se si soluciona el problem =( porque si sumo el total de volita da false =(!!!????
    /*
     Proposito: indicar si hay mas de cinco bolitas en la celda actual.
     Precondicion:ninguna, es una funcion total.
     Tipo: Booleano
    */
    return((nroBolitas(Azul) > 5) || (nroBolitas(Negro) > 5) || (nroBolitas(Rojo) > 5) || (nroBolitas(Rojo) > 5)  )
}
//b.
function menosDeCinco() {
    /*
        PROPÓSITO:indica cuando la celda actual tiene al menos 5 bolitas en total.
        TIPO: Booleano.
        PRECONDICIONES:ninguna es una funcion total.
    */
    
   
}
//c.
function menosDeCincoYEstoyAlBorde() {  // puedo parametrizar la dire
    /*
        PROPÓSITO: indica cuando la celda actual tiene al menos 5 bolitas en total y el borde se
                   encuentra justo al Este de la misma.
        TIPO: Booleano.
        PRECONDICIONES: ninguna es una funcion total.
            
    */
    return( menosDeCinco() && not(puedeMover(Este)))  
}
//d.
function hayCeldasLindantes() {
    /*
        PROPÓSITO: indica cuando la celda actual tiene una celda lindante al Norte o al Este.
        TIPO: Booleano
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(puedeMover(Norte) || puedeMover(Este))
}
//e. 
function hayDeTodosLosColores() {
    /*
        PROPÓSITO: indica cuando la celda actual tiene bolitas de todos los colores.  
        TIPO: Booleano
        PRECONDICIONES: ninguna, es una funcion total.??????
    */
    return(hayBolitasAzulYBolitasRojo() && hayBolitasVerdeYBolitasNegro())  
}
function hayBolitasAzulYBolitasRojo(){
     /*
        PROPÓSITO: indica si en la celda actual existen bolitas de color Azul y Rojo. 
        TIPO: Booleano.
        PRECONDICIONES: ninguna, es una funcion total.??????
    */
    return(hayBolitas(Azul) && hayBolitas(Rojo))
}
function hayBolitasVerdeYBolitasNegro(){
     /*
        PROPÓSITO: indica si en la celda actual existen bolitas de color Verde y Negro. 
        TIPO: Booleano.
        PRECONDICIONES: ninguna, es una funcion total.??????
    */
    return(hayBolitas(Verde) && hayBolitas(Negro))
}
f.function faltaAlMenosUnColor() {
    /*  dar una solución sin usar la funciónes
        PROPÓSITO: indica cuando en la celda actual faltan bolitas de al menos un color. 
        TIPO: Booleano
        PRECONDICIONES: ninguna es una funcion total. ??????
    */
 
   
}
3./*Escribir los siguientes procedimientos, recordando no mezclar niveles de abstracción
del problema, para lo cual puede ser necesario definir otros procedimientos y/o funciones.
a.SacarUnaFicha_SiSePuede(colorDeLaFicha) que, dado el colorDeLaFicha que debe sacarse,
saque una ficha siempre y cuando la misma esté en la celda. Si no hubiera fichas del color dado,
el procedimiento no hace nada. Si hubiera varias fichas, solo debe sacar una.
OBSERVACIÓN: cada ficha se representa con una bolita del color correspondiente.*/
procedure SacarUnaFicha_SiSePuede(colorDeLaFicha) {
    /*
        PROPÓSITO:  saca una ficha de color "colorDeLaFicha" siempre y cuando la misma esté en la celda. 
                    Si no hubiera fichas del color dado, el procedimiento no hace nada. 
                    Si hubiera varias fichas, solo debe sacar una.
        OBSERVACIÓN: cada ficha se representa con una bolita del color correspondiente.
        PARÁMETROS:
            * colorDeLaFicha: Color - describe el color de la ficha a sacar.
            
        PRECONDICIONES: ninguna ya que el ejercicio hablando de la condicion. 
    */
    if(hayFichaDeColor_(colorDeLaFicha)) then{
        SacarFicha_(colorDeLaFicha)
    }   
}
function hayFichaDeColor_(colorDeLaFicha) {
    /*
        PROPÓSITO: indica si hay ficha de color "colorDeLaFicha" en la celda actual.
        PARÁMETROS:
            * colorDeLaFicha: Color - describe el color de las fichas a sacar. 
        TIPO: Booleano, indica Verdadero si hay ficha de color "colorDeLaFicha" en la celda actual,
              Falso en caso contrario.
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(hayBolitas(colorDeLaFicha))
}
procedure SacarFicha_(colorDeLaFicha){
    /*
        PROPÓSITO: saca una ficha de color "colorDeLaFicha" de la celda actual.
        PARÁMETROS:
            * colorDeLaFicha: Color - describe el color de las fichas a sacar. 
        PRECONDICIONES: debe existir al menos una  ficha del color "colorDeLaFicha" en la celda actual.
    */
    Sacar(colorDeLaFicha)
}
b.DesempatarParaElLocal_Contra_(colorDelLocal,colorDelVisitante) que,
 dados los colores de dos jugadores, ponga una bolita del
colorDelLocal solamente en el caso en que la celda actual contiene la
misma cantidad de bolitas de ambos colores.
procedure DesempatarParaElLocal_Contra_(colorDelLocal,colorDelVisitante ) {
    /*
        PROPÓSITO: pone una bolita del colorDelLocal solamente en el caso en que la celda 
                  actual contiene la misma cantidad de bolitas de ambos colores.
        PARÁMETROS:
            * coloreDelLocal: Color - describe el color del jugador local.
            * colorDelVisitante: Color - describe el color del jugador visitante.
l        PRECONDICIONES: debe existir en la celda actual el mismo numero de
                         bolitas de los colores "colorDelLocal" y "colorDelVisitante."
    */
  
}
function hayEmpateEntre_Y_(colorDelLocal, colorDelVisitante) {
    /*
        PROPÓSITO: indica si hay un empate en la celda actual.
        PARÁMETROS:
            * colorDelLocal: Color- describe el color de los jugadores locales.
            * colorDelVisitante: Color- describe el color de los jugadores visitantes.
        TIPO: Booleano
        PRECONDICIONES: ninguna es una funcion total.
    */
    
}
c.ExpandirBacteriaDeLaColonia(), que siempre que en la celda actual haya
un cultivo de bacterias y haya suficientes nutrientes,agregue
exactamente una bacteria más y consuma nutrientes, a razón de dos
nutrientes por bacteria expandida; si no hay bacterias o no hay suficientes
nutrientes, no hace nada. Las bacterias se representan con bolitas Verdes y
los nutrientes con bolitas Rojas.
procedure ExpandirBacteriaDeLaColonia() {
    /*
        PROPÓSITO: expande un cultivo de bacterias en la celda actual.
        PRECONDICIONES:en la celda actual siempre debe existir un cultivo de bacterias y 
                       debe existir suficientes nutrientes.
        OBSERVACIÓN:  El cultivo de bacterias se representan con bolitas Verdes y los nutrientes con 
                     bolitas Rojas
    */
}

d.PonerFlecha_AlNorteSiCorresponde(colorDeLaFlecha), que dado
un color para representar flechas, ponga una flecha al Norte si existe espacio
para moverse en esa dirección. Las flechas al Norte serán representadas con
una bolita del color dado.
procedure PonerFlecha_AlNorteSiCorresponde(colorDeLaFlecha) {
    /*
        PROPÓSITO: pone una flecha color "colorDeLaFlecha " en la celda lindante al Norte, 
                  si existe espacio para moverse en esa dirección.
        PARÁMETROS: 
            colorDeLaFlecha :Color - describe el color de la representación de la flecha.
        PRECONDICIONES: debe existir una celda sin flecha lindante al Norte a partir de la 
                         celda actual no debe existir flecha en la celda actual.
        OBSERVACIÓN: Las flechas al Norte serán representadas con una bolita del color dado.
    */
    

4.Escribir los siguientes procedimientos:
a.PudrirManzana(), que en el caso de que en la celda actual haya al menos
una manzana en buen estado y un gusano, pudre una manzana retirando un
gusano.
OBSERVACIONES: las manzanas en buen estado se representan con bolitas
de color Rojo, las manzanas podridas con bolitas de color Negro, y los
gusanos con bolitas de color Verde.
SUGERENCIA: primero dar el contrato de la siguiente subtarea y utilizarlo en
la resolución. Reemplazar_Y_Por_(primerColorAReemplazar, segundoColorAReemplazar, colorAAgregar)
b. Completar el código de Reemplazar_Y_Por_.
c. PudrirHasta_Manzanas(cantidadAPudrir),
que pudrehasta un máximo de manzanas dada por la cantidad. Puede que se pudran menos
manzanas si no se dan las condiciones necesarias (no hay suficientes
manzanas en buen estado, o suficientes gusanos, por ejemplo).
// b.
procedure Reemplazar_Y_Por_(primerColorAReemplazar, segundoColorAReemplazar, colorAAgregar) {
    /*
        PROPÓSITO: reemplaza los colores "primerColorAReemplazar" y "segundoColorAReemplazar" por 
                   el color "colorAAgregar"  en la celda actual.
        PARÁMETROS:
            * primerColorAReemplazar: Color - describe el primer color a reemplazar .
            * segundoColorAReemplazar: Color - describe el segundo color a reemplazar.
            * colorAAgregar: Color - describe el color por el que vamos a reemplazar los colores 
                             "primerColorAreemplazar" y "segundoColorAReemplazar".
        PRECONDICIONES: ninguna es una funcion total.
    */
    Poner( colorAAgregar)
    Sacar(primerColorAReemplazar)
    Sacar(segundoColorAReemplazar)
}
// a.
procedure PudrirManzana() {
    /*
        PROPÓSITO: en el caso de que en la celda actual haya al menos una manzana en buen estado y un gusano, 
                   pudre a la misma retirando un gusano.
        PRECONDICIONES: en la celda actual debe haber al menos  una manzana en buen estado 
                        y un gusano.
        OBSERVACIONES: las manzanas en buen estado se representan con bolitas
                       de color Rojo, las manzanas podridas con bolitas de color Negro, y los
                       gusanos con bolitas de color Verde.
    */
    if(hayManzanaEnBuenEstado && hayGusano) then{
        Reemplazar_Y_Por_(Rojo,Verde, Negro)
    }
}
function hayManzanaEnBuenEstado() {
    /*
        PROPÓSITO: indica si hay una manzana en buen estado en la celda actual.
        TIPO: Booleano, Verdad si hay manzana en buen estado en la celda actual,
              Falso en caso contrario.
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(hayBolitas(Rojo))
}
function hayGusano() {
    /*
        PROPÓSITO: indica si hay un gusano en la celda actual.
        TIPO: Booleano, Verdadero cuando hay un gusano en la celda actual,
              Falso en caso contrario.
        PRECONDICIONES: ninguna es una funcion total.
    */
    return(hayBolitas(Verde))   
}
c. PudrirHasta_Manzanas(cantidadAPudrir), que pudre hasta un
máximo de manzanas dada por la cantidad. Puede que se pudran menos
manzanas si no se dan las condiciones necesarias (no hay suficientes
manzanas en buen estado, o suficientes gusanos.).
procedure PudrirHasta_Manzanas(cantidadAPudrir){ // va un BOOM ????
    /*
        PROPÓSITO: pudre hasta un máximo de manzanas dada por la cantidad "cantidadAPudrir".
                    Se puede pudrir menos manzanas si las condiciones necesarios no se dan.
        PARÁMETROS:
            * cantidadAPudrir: Número - describe el numero de manzanas a pudrir.
        PRECONDICIONES: que en la celda actual debe existir  al menos manzanas como numeros de gusanos.
        Observación:Puede que se pudran menos manzanas si no se dan las condiciones necesarias
         (no hay suficientes manzanas en buen estado, o suficientes gusanos, por ejemplo).
    */
    repeat(cantidadAPudrir){
        PudrirManzana()
    }
}
// ----OPCION 2 SIN USAR EL REEMPLAZAR---
  if( hayManzanaEnBuenEstado() && hayGusano()) then{
        Sacar_DeColor_(cantidadAPudrir, Verde)
        Sacar_DeColor_(cantidadAPudrir, Rojo)
        Poner_DeColor_(cantidadAPudrir, Negro)
    }
}
5. BIBLIOTECA
 La combinación de parámetros y expresiones booleanas es interesante.
a.Escribir un procedimiento Poner_Si_(color, condición) que dado un
color y un valor de verdad llamado condición, ponga en la celda actual
una bolita del color dado si el valor de verdad de la condición es verdadero,
y no lo ponga si no.
procedure Poner_Si_(color, condición)() {
  /*
    PROPÓSITO: pone bolitas de color  "color" en la celda actual soloamente si se comple la condicion.
    PRECONDICIONES:  ninguna es una funcion total
    PARÁMETROS:
      *color: Color- describe el color "color" de la bolitas a poner  si la condicion es Verdad en la celda actual.
      *condición: Booleano- indica  la  condición que tiene que cumplirse para poner una bolita.
  */
  if(condición) then {
    Poner(color)
  }
}
EJEMPLO: Poner_Si_(Rojo, nroBolitas(Rojo)==0) solamente pone
una bolita roja cuando no hay ninguna roja en la celda actual.

b.Escribir los procedimientos Sacar_Si_(color,condición) y
Mover_Si_(dirección,condición) que actúan de forma similar a Poner_Si_.
procedure Sacar_Si_(color,condición) {
  /*
    PROPÓSITO: saca solamente si existe bolitas color "color".
    PARÁMETROS:
     *color: Color- describe el color "color" de la bolitas a sacar  si la condicion es Verdad.
     *condición: Booleano- indica la  condición que tiene que cumplirse para sacar una al menos una bolita.
    PRECONDICIONES: ninguna es una funcion total.
  */
  if(condición) then {
    Sacar(color)
  } 
}
procedure Mover_Si_(dirección,condición) {
  /*
    PROPÓSITO: mueve en direccion "direccion" solamente si cumple la condicion "condicion".
    PARÁMETROS:
      * color: Dirección - describe la direccion a mover a partir de la celda actual.
      * condición: Booleano - indica  la condición  que tiene que cumplirse para mover.
    PRECONDICIONES: ninguna es una funcion total.
  */
  if(condición) then {
    Mover(dirección)
  } 
}
c.Reescribir el procedimiento DesempatarParaElLocal__. hecho antes,
pero utilizando el procedimento Poner_Si_.
procedure DesempatarParaElLocal__(colorDelLocal,colorDelVisitante ) {
   /* PROPÓSITO: pone una bolita del colorDelLocal solamente en el caso en que la celda 
                  actual contiene la misma cantidad de bolitas de ambos colores.
        PARÁMETROS:
            * coloreDelLocal: Color - describe el color del jugador local.
            * colorDelVisitante: Color - describe el color del jugador visitante.
l        PRECONDICIONES: ninguna ya que llama a una subtarea que en realidad es un condicional
                         que si no se cumple la condicion la subtarea no hace nada .^^.
					 ademas absorve la precondiocion de Poner_Si_(color,numero)
                        
    */
    Poner_Si_(colorDelLocal,(nroBolitas(colorDelLocal) == 
                             nroBolitas(colorDelVisitante))
              )
}

d. ¿Puede reescribirse el procedimiento Reemplazar_Y_Por_ hecho antes, pero reutilizando únicamente los procedimientos Poner_Si_ y Sacar_Si_? Si la respuesta es afirmativa, dar el código correspondiente. elSi no, justificar por qué no sería posible.
procedure Reemplazar_Y_Por_(primerColorAReemplazar, segundoColorAReemplazar, colorAAgregar) {
    /*  
        PROPÓSITO: reemplaza los colores "primerColorAReemplazar" y "segundoColorAReemplazar" por 
                   el color "colorAAgregar"  en la celda actual.
        PARÁMETROS:
            * primerColorAReemplazar: Color - describe el primer color a reemplazar .
            * segundoColorAReemplazar: Color - describe el segundo color a reemplazar.
            * colorAAgregar: Color - describe el color por el que vamos a reemplazar los colores 
                             "primerColorAreemplazar" y "segundoColorAReemplazar".
        PRECONDICIONES: ninguna es una funcion total.
    */
    Poner_Si_(colorAAgregar, hayBolitas(segundoColorAReemplazar))
    Sacar_Si_(primerColorAReemplazar,hayBolitas(colorAAgregar))
    Sacar_Si_(segundoColorAReemplazar,hayBolitas(colorAAgregar))  
}
e. ¿Que beneficios trae tener los procedimientos Sacar_Si_ y Poner_Si_
contra utilizar if en cada caso?
El beneficio de los procedimientos es que no anidamos repeticiones y ademas 
comunica de forma clara nuestra estrategia ademas de  ayudar a la hora de realizar alguna correcion.

6. El bosque, parte 4 
En este ejercicio continuaremos expandiendo el dominio del bosque. Escribir los
siguientes procedimientos. Considerar la reutilización de los procedimientos hechos
en las partes anteriores y la definición de nuevas funciones necesarias para no tener
que depender de la representación dada.
a. GerminarSemilla(), que transforma una semilla en un árbol en la celda
actual. La germinación consume tres unidades de nutrientes. Si en la celda
no hay semilla, o no hay suficientes nutrientes, no se hace nada.
procedure GerminarSemilla(){
    /*
    Propósito:transforma una semilla en un árbol en la parcela actual.
              La germinación consume tres unidades de nutrientes. 
              Si en la celda no hay semilla, o no hay suficientes nutrientes, no se hace nada.
    Precondición:ninguna .
    Observación: llamamos parcela a una celda.
    */
  
}

b. AlimentarÁrboles(), que hace que los árboles de la celda actual se
alimenten, consumiendo un nutriente cada uno. El único cambio que hay que
hacer es la eliminación de los nutrientes. Si hay menos nutrientes de lo que
se necesita, se consumen todos los que hay.
procedure AlimentarÁrboles(){
    /*  
    Propósito: alimentar los árboles de la parcela actual, se alimenta consumiento un nutriente
               cada árbol.Hay que eliminar  los nutrientes de la parcela que consumieron los árboles. 
               Si hay menos nutrientes de lo que se necesita, se consumen todos los que hay.
    Precondición:ninguna .
    Observación: llamamos parcela a una celda.
    */
    // la condicion:Si hay menos nutrientes de lo que se necesita, se consumen todos los que hay
}
c. ExplotarBomba(), que explota una bomba en la celda actual, eliminando
árboles. Al explotar, una bomba derriba 5 árboles en la celda actual y 3 en la
celda lindante al Norte. Si la celda actual está en el borde Norte, entonces
solo se eliminan los árboles de la celda actual. Atención que cuando haya
menos árboles de los que la bomba puede eliminar, entonces elimina los que
haya. La bomba se consume en el proceso, o sea, hay que eliminarla.
procedure ExplotarBomba() {
    /*
        PROPÓSITO: explota una bomba en la parcela actual eliminando árboles.
                   Al explotar, una bomba derriba 5 árboles en la parcela actual y 3 en la
                   parcela lindante al Norte. Si la parcela actual está en el borde Norte, entonces
                   solo se eliminan los árboles de la parcela actual. Atención que cuando haya
                   menos árboles de los que la bomba puede eliminar, entonces elimina los que
                   haya. La bomba se consume en el proceso, o sea, hay que eliminarla.
        PRECONDICIONES: debe existir una bomba en la celda actual.
        BSERVACIÓNES: llamamos parcela a una celda.
    */
     // consulta con Valeria.Tiene que ser como un cuento posta 
}

d. Polinizar(): los árboles en la celda actual polinizan la celda lindante en la
dirección Este, generando tantas semillas en esa celda como árboles haya
en la celda actual, menos 3. Por ejemplo, si en la celda actual hay 5 árboles,
se generan 2 semillas en la celda lindante al Este. Si en la celda actual hay
menos de 3 árboles, o no tiene lindante al Este, entonces no se hace nada.
procedure Polinizar() { 
    /*
        PROPÓSITO: polinizar la parcela lindante en la dirección Este, generando tantas 
                   semillas en esa parcela como árboles haya en la parcela  actual, menos 3
      
        PRECONDICIONES: ninguna.
        OBSERVACIÓNES: llamamos parcela a una celda.
    */
}

7.BIBLIOTECA Escribir las siguientes funciones, para agregarlas a la biblioteca.
a. esCeldaVacía(), que indica si la celda actual se encuentra vacía.
b. hayAlMenosUnaDeCada(), que indica si en la celda actual hay al menos
una bolita de cada color.
c. esCeldaConBolitas(), que indica si la celda actual tiene al menos una
bolita, de cualquier color.
function esCeldaVacía(){
    /* Proposito:  indica si la celda actual se encuentra vacía.
       Precondición: ninguna es una funcion total.
	  Tipo: Booleano.
       
    */
    return(not hayBolitas(Rojo) && not hayBolitas(Negro) && not hayBolitas(Azul) && not hayBolitas(Negro) )
}
function hayAlMenosUnaDeCada(){
    /* Proposito: indica si en la celda actual hay al menos una bolita de cada color.
	  Precondición: ninguna es una funcion total.
	  Tipo: Booleano.
    */
	return( hayBolitas(Rojo) &&  hayBolitas(Negro) &&  hayBolitas(Azul) &&  hayBolitas(Negro) )
}
function esCeldaConBolitas(){
    /*Proposito: indica si la celda actual tiene al menos una bolita, de cualquier color.
	 Precondición: ninguna es una funcion total.
	 Tipo: Booleano.
    */
	return( hayBolitas(Rojo) ||  hayBolitas(Negro) ||  hayBolitas(Azul) ||  hayBolitas(Negro) )
} 

9. Sobre el ejercicio “Soporte técnico” trabajado en la práctica anterior:
a. Modificar la solución propuesta para agregar funciones donde resulte
conveniente. ¿Qué ventajas se obtienen?
b.Modificar nuevamente la solución, teniendo en cuenta que ahora el
procedimiento RepararMáquina(), ya NO debe tener como precondición
que haya virus en la máquina actual, ya que podría haber tableros iniciales
donde algunas máquinas no se hubieran infectado, y no debe pasarse un
antivirus sobre una máquina que ya tiene la marca de Ok. Con este cambio,
¿el nombre del procedimiento debería seguir siendo el mismo?
-----SOPORTE TECNICO------
/* REPRESENTACIÓN DEL DOMINIO
   - los virus se representan con bolitas Rojas, de 1 a 6 
   - una indicación de que la máquina de la celda actual no 
     tiene virus (indicación de OK) se representa con una 
     bolita Verde
   - el Hall del edificio en la celda 0,0 con la cantidad de 
     pisos representada por las bolitas Azules
   - el Hall del piso en la celda del borde Oeste de cada piso, 
     con la cantidad de máquinas del piso representada por las 
     bolitas Negras 
*/
procedure RepararEdificioSiEsNecesario(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del edificio. 
         El cabezal queda en el Hall del último piso 
         del edificio (el hall más al Norte)
     PRECONDICIONES: ninguna
  */
  if( esElHall() && hayPisosParaReparar() ) then{
    repeat(nroBolitas(pisos())){
        PasarAlProximoPiso()
        RepararPisoSiEsNecesario()
    }   
  }
  else{
    RepararPisoSiEsNecesario()
  }
}
function esElHall(){
    /* 
     PROPÓSITO: indica si el cabezal esta en la celda 0,0.
     PRECONDICIONES: ninguna.
     TIPO: Booleano.
  */
  return (puedeMover(Norte) && puedeMover(Este))

}
function hayPisosParaReparar(){
    /* 
     PROPÓSITO: indica si hay pisos que necesiten reparacion.
     PRECONDICIONES: ninguna.
     TIPO: Booleano.
  */
  return (hayBolitas(pisos()))

}

function pisos(){
    /* 
     PROPÓSITO: describe el color con el que se representa los pisos de un edificio.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Azul)

}
procedure PasarAlProximoPiso(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar el proximo piso a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Norte)
}
procedure RepararPisoSiEsNecesario(){
  /* 
     PROPÓSITO: 
       * reparar todas las máquinas del piso actual
         (sacando todos los Virus de las máquinas del piso)
     PRECONDICIONES: 
       * la celda actual es el Hall del piso
  */
  if(esUnPisoConVirus()) then{
    repeat(nroBolitas(maquinaConVirus())){
        PasarAProximaMáquina()
        RepararMáquinaSiEsNecesario()
    }
    IrAlBorde(Oeste)
  }
}
function esUnPisoConVirus(){
    /* 
     PROPÓSITO: indica si un piso del edificio tiene algun virus.
     PRECONDICIONES: ninguna.
     TIPO: Booleano.
  */
  return (puedeMover(Este) && hayBolitas(maquinaConVirus()) )

}
function maquinaConVirus(){
    /* 
     PROPÓSITO: describe el color con el que se representa las maquinas con virus de un piso.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Negro)

}
procedure PasarAProximaMáquina(){
    /* 
     PROPÓSITO: 
       * Pasa a reparar la proxima maquina a partir de la celda actual.
     PRECONDICIONES: 
       * debe existir al menos una celda lindante al
          Este y debe estar vacia.
  */
  Mover(Este)
}
procedure RepararMáquinaSiEsNecesario(){
  /* 
     PROPÓSITO: 
       * eliminar los virus de la celda actual y dejar 
         la marca de OK 
     PRECONDICIONES: 
       * en la celda actual hay una máquina con virus
         y sin marcas de OK
  */
  repeat(nroBolitas(virus())){
      Sacar(virus())
    }
  IndicarOk()
}
function virus(){
    /* 
     PROPÓSITO: describe el color con el que se representa los virus de una maquina.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Rojo)
}

procedure IndicarOk() {
  /* 
     PROPÓSITO: 
       * indicar que la máquina de la celda actual no tiene 
         virus poniendo la indicación de OK
     PRECONDICIONES: 
       * la máquina de la celda actual no tiene virus ni 
         indicación de OK
  */
  Poner(ok())
}
function ok(){
    /* 
     PROPÓSITO: describe el color con el que se representa  una maquina sin virus.
     PRECONDICIONES: ninguna.
     TIPO: Color.
  */
  return (Verde)
}
/* LO QUE APRENDI--------
 Las funciones que agregue traen abstracciona al problema es suficiente con que retorne 
 solo el color???????????????'??!! <3
 Ya no necesitos SacarTodas_(colorASacar), ni Sacar_DeColor_(numero, color)!!!!!<3
 
*/

 10. ¡A la batalla!, parte 2
/* Escribir las siguientes funciones para el juego ¡A la batalla! de la práctica anterior,
donde en las celdas del tablero se representan Soldados (los aliados con una bolita
de color Negro y los enemigos con una bolita de color Rojo por cada soldado). */

/* a. colorAliado() y colorEnemigo() que describen el color de los aliados
y los enemigos, respectivamente. */
function colorAliado() {
    /*
    PROPOSITO: denota el color de los soldados aliados.
    RESULTADO: un Color.
    PRECONDICIONES: no tiene.
    */
    return (Negro)
}
function colorEnemigo() {
    /*
    PROPOSITO: denota el color de los soldados enemigos.
    RESULTADO: un Color.
    PRECONDICIONES: no tiene.
    */
    return (Rojo)
}
/* b. cantidadDeSoldadosDel_(colorDelEjército), que describe la
cantidad de soldados de la celda actual del ejército dado. */
function cantidadDeSoldadosDel_(colorDelEjército) {
    /*
    PROPOSITO: describe la cantidad de soldados del ejercito dado en la 
    celda actual.
    PARAMETROS:
        * colorDelEjército; un Color.
    RESULTADO: un Numero.
    PRECONDICIONES: no tiene.
    */
    
}
/* c. esCeldaIndefensa() que describe verdadero cuando no hay soldados
aliados en la celda actual. */
function esCeldaIndefensa() {
    /*
    PROPOSITO: indica si en la celda actual no hay soldados aliados.
    RESULTADO: un Booleano. Verdadero cuando en la celda actual no hayan
    soldados aliados. Falso en caso contrario.
    PRECONDICIONES: no tiene.
    */
   
}
/* d. estadoDeEmergencia() que describe verdadero solamente si existen más
de 100 soldados enemigos, y además la celda está indefensa. */
function estadoDeEmergencia() {
    /*
    PROPOSITO: indica si existen mas de 100 soldados enemigos y ademas la celda
    esta indefensa.
    RESULTADO: un Booleano. Verdadero cuando hayan mas de 100 soldados enemigos
    y la celda este indefensa. Falso en caso contrario.
    PRECONDICIONES: no tiene.
    */
    
}
/* e. haySuficientesAliadosARazónDe_PorCada_(cantidadDefensa,cantidadAtaque) 
que describe verdadero si hay por lo menos cantidadDefensa soldados aliados por cada 
cantidadAtaque soldados enemigos en la celda actual.
Pista: Piense en aplicar regla de tres simple donde:
cantidadDefensa de aliados --- cantidadAtaque de enemigos
X cantidad de aliados --- Y cantidad en celda enemigos */
function haySuficientesAliadosARazónDe_PorCada_(cantidadDefensa, cantidadAtaque) {
    /*
    PROPOSITO: indica si hay por lo menos **cantidadDefensa** soldados aliados por 
    cada **cantidadAtaque** soldados enemigos en la celda actual.
    PARAMETROS:
        * cantidadDefensa; un Numero, la cantidad de soldados aliados.
        * cantidadAtaque; un Numero, la cantidad de soldados enemigos.
    RESULTADO: un Booleano. 
    PRECONDICIONES: no tiene.
    */
   
}
/* f. aliadosNecesariosParaDefensaEficaz() que describe el número de
soldados aliados que faltan para defender la celda actual. Tener en cuenta
que en la celda actual puede ser que haya soldados, pero que es
precondición de esta función que no hay suficientes aliados. Recordemos
que 2 soldados enemigos pelean contra 3 soldados aliados y todos mueren */

function aliadosNecesariosParaDefensaEficaz() {
    /*
    PROPOSITO: describe el número de soldados aliados que faltan para defender
    la celda actual.
    RESULTADO: un Numero. 
    PRECONDICIONES: no deben haber suficientes aliados para defender la 
    celda actual.
    */
  // hacer una regla de tres simple ojo a lo que hay que tener en cuenta!!!!!!
    
  
}
/* 12)¿Vamos al banco? - Parte 1
En este ejercicio utilizaremos el tablero de Gobstones para representar cuentas
bancarias. Cada celda representará a una cuenta bancaria, y en cada una de ellas
puede haber dinero en distintas monedas, que representaremos con distintos
colores:
● bolitas negras para pesos argentinos.
● bolitas verdes para dólares estadounidenses.
● bolitas azules para euros.
● bolitas rojas para yuanes chinos.
Se pueden hacer tres operaciones: depósitos, extracciones y conversiones a divisa
extranjera. Las extracciones pueden hacerse en cualquier moneda, pero los
depósitos siempre serán en pesos.
En el caso en que se quiera depositar un monto en una moneda extranjera, se
aplicará automáticamente la conversión a pesos según el precio de venta dado en la
siguiente tabla:
Precios de venta
1 dólar -->80 pesos
1 euro -->90 pesos
1 yuan -->12 pesos
En cuanto a la conversión a divisa extranjera, el banco actualmente aplica las
siguientes tarifas para la compra de divisa:
Precios de compra
100 pesos -->1 dólar
115 pesos -->1 euro
17 pesos -->1 yuan
Realizar los siguientes procedimientos para poder manipular la cuenta:
c.Depositar_EnMoneda_ComoPesos(cantidadADepositar,moneda),
que dada una cantidad de dinero a depositar y un color que representa la
moneda en la que está representado ese monto, agrega a la cuenta la
cantidad de pesos equivalente a lo indicado para depositar. En este
procedimiento hay que aplicar la conversión indicada para el precio de venta.
Ej...
d. ExtraerHasta_EnMoneda_(cantidadAExtraer,moneda), que dada
una cantidad de dinero a extraer y un color que representa la moneda en la
que se va a extraer, remueve de la cuenta la cantidad que se indica. Si no
hubiera tanto dinero como el solicitado, se extrae todo lo que haya.
e.ConvertirHasta_PesosA_(pesosAConvertir,moneda), que dada
una cantidad de pesos a convertir y un color que representa la moneda en la
cual se quiere convertir, remueve los pesos de la cuenta y agrega la moneda
solicitada. Si en la cuenta hubiera menos pesos de lo solicitado, se convierte
todo lo que haya.
El último ejemplo es interesante: se piden convertir 100 pesos a dólares pero no hay
10 pesos en la cuenta, por lo que se va a intentar convertir el total de pesos que haya,
90. Con 90 pesos, no se llega a comprar ningún dólar, y como Gobstones solo trabaja
con números enteros, no es posible tener medio dólar, por lo que queda en cero
dólares.
f. RealizarCorridaCambiaria(), que dado un tablero de 1 única fila y 10
columnas, donde cada celda representa una cuenta bancaria, se realiza una
corrida cambiaria, donde en cada cuenta se cambia la totalidad de los pesos
a dólares.

13.¿Vamos al banco? - Parte 2
Continuaremos utilizando el mismo dominio del banco de la práctica anterior. Esta
vez, vamos a realizar funciones que nos permitan abstraernos de la representación
subyacente, así como simplificar cálculos en nuestras operaciones.
Se pide entonces que realice las siguientes funciones:
a. pesos() que describe el color con el que se representan los pesos en el
tablero, Negro.
b. dólares() que describe el color con el que se representan los dólares en el
tablero, Verde.
c. euros() que describe el color con el que se representan los euros en el
tablero, Azul.
d. yuanes() que describe el color con el que se representan los yuanes en el
tablero, Rojo.
e. ahorrosEn_(moneda) que dada una moneda, indica la cantidad de
unidades de esa moneda en la cuenta actual.
f. cuantosDolaresSePuedeComprarCon_Pesos(cantidadDePesos) que
indica la cantidad de dólares que se pueden comprar con una cantidad de
pesos dada.
g. cuantosEurosSePuedeComprarCon_Pesos(cantidadDePesos)
que indica la cantidad de euros que se pueden comprar con una cantidad de
pesos dada.
h. cuantosYuanesSePuedeComprarCon_Pesos(cantidadDePesos) que
indica la cantidad de yuanes que se pueden comprar con una cantidad de
pesos dada.
i. cuantosPesosSiVendo_Dólares(cantidadDeMonedaExtranjera)
que indica la cantidad de pesos a obtener si se venden (depositan) la
cantidad de dólares dada.
j. cuantosPesosSiVendo_Euros(cantidadDeMonedaExtranjera) que
indica la cantidad de pesos a obtener si se venden (depositan) la cantidad de
euros dada.
k. cuantosPesosSiVendo_Yuanes(cantidadDeMonedaExtranjera) que
indica la cantidad de pesos a obtener si se venden (depositan) la cantidad de
yuanes dada.
l.Vuelva a realizar los procedimientos de la práctica anterior, ahora utilizando
las funciones realizadas en los puntos anteriores.
Reflexionamos: ¿Cuánto esfuerzo conlleva cambiar la representación de Euros y Pesos, para
que ahora los primeros sean representados con bolitas negras y las segundas con azules.?
¿Cuántos lugares hubo que tocar? Sí la respuesta es más de 2, puede que no haya resuelto
bien los ejercicios.
*/
---REPECTICION CONDICIONAL----------------------
---EJERCICIOS INTRODUCTORIOS----------------
// Super Lucho 1.
procedure EncenderFilaDeLuces(){
    while (estáEnLaMeta()) {
        EncenderLuz()
        MoverALuchoAlEste()
    }    
}
// Super Lucho 2.
procedure EncenderLaFilaDeLuces(){
    /*...*/
    while(estáEnLaMeta()){ // funcion primitiva
        EncenderLaLuzSiHay()
    }
}
procedure EncenderLaLuzSiHay(){
    if(hayLuzApahada()) then{
        EncenderLuz() //procedure primitivo
        MoverALuchoAlEste() //procedure primitivo
    }
}
//Laberinto con queso recargado 
procedure SalirDelLaberintoComiendoQueso(){
    while(estoyEnLaSalida()){
        AvanzarUnPasoSiguiendoLaFlecha()
        ComerElQuesoSiHay()
    }
}
procedure AvanzarUnPasoSiguiendoLaFlecha(){
    if(laFlechaApuntaAlNorte())then {
        SacarLaFlecha()
        MoverAlRatónAl_(Norte)
    } elseif(laFlechaApuntaAlEste()){
        SacarLaFlecha()
        MoverAlRatónAl_(Este)
    }elseif(laFlechaApuntaAlSur()){
        SacarLaFlecha()
        MoverAlRatónAl_(Sur)
    }else{
        SacarLaFlecha()
        MoverAlRatónAl_(Oeste)
    }
}
procedure ComerQuesoSiHay() {
    if(hayqueso())then{
        ComerElQueso()
    }
}
procedure ComerElQueso(){
    Sacar(Verde)
}
---GUIA REPETICION CONDICIONAL Y RECORRIDOS ----------------------------

1.Definir el procedimiento IrAlBorde_(dirección), que lleva al cabezal al borde
dado por el parámetro dirección, SIN utilizar el comando primitivo IrAlBorde.
Dado que el único otro comando primitivo que permite mover el cabezal es Mover,
debe repetirse su uso hasta que se haya cumplido el propósito. ¿Cuál es la
condición que indica que el propósito se cumplió?*/
procedure IrAlBorde_(dirección){
    /*
        PROPÓSITO: ir a la primera celda de un recorrido
        PARÁMETROS:
            * dirPrincipal: Direccion, escribe la direcciona moverse.
            * dirSecundaria: Direccion, escribe la direcciona moverse.
        PRECONDICIONES: las direcciones dadas no deben ser opuestas y tampoco pueden ser iguales.
    */
    while(puedeMover(dirección)){
        Mover(dirección)
    }
}
2.Volver a definir el procedimiento SacarTodasLasDeColor_(colorASacar), que
quita todas las bolitas del color dado por el parámetro color de la celda actual,
pero esta vez SIN utilizar la expresión primitiva nroBolitas.*/
procedure SacarTodasLasDeColor_(colorASacar){
    /*Propósito: saca todas las bolitas de color "colorASacar" de la celda actual.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar de la celda.
    Precondicion: niguna.
         
         Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9.
   */
   while(hayBolitas(colorASacar)){
    Sacar(colorASacar)
   }
}
3.Considerar el procedimiento VaciarFilaDe_(color), que debe quitar todas las
bolitas del color dado por el parámetro color de cada una de las celdas de la fila
actual . El cabezal puede empezar en cualquier celda de la fila, y también puede 1
terminar en cualquier celda de la fila (ya sea celda inicial o cualquier otra).*/
/*a.Definir el procedimiento, como siempre, comenzando por establecer el contrato, y 
luego recién el código.

b.¿La solución dada funciona si el cabezal se encuentra en medio de una fila?
Si no es así, corregir el programa para que funcione en este caso también.

c.Al recorrer la fila, ¿en qué dirección se movió el cabezal? ¿Podría haberse
movido en la dirección opuesta?

d.A partir de la respuesta anterior, ¿de cuántas formas posibles se puede
realizar el recorrido de una fila?*/
procedure VaciarFilaDe_(color){
    /*Propósito: quitar todas las bolitas del color "color" de cada una de las celdas
      de la fila actual . El cabezal puede empezar en cualquier celda de la fila,y 
     también puede terminar en cualquier celda de la fila ya sea celda inicial o cualquier 
     otra.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar de la fila.
    Precondicion: ninguna.

     //  Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9, resolucion anterior.
   
    */
    IrAlBorde_(Oeste) //como es un recorrido por  puedefilas  ser Este tambien.
    while(puedeMover(opuesto(Oeste))){ //condiciona la repe
        SacarTodasLasDeColor_(color) // def en el punto anterior,tiene un whilw lo puwdo usar
        Mover(opuesto(Oeste))                                   // o estoy anidando whiles?????   
    }
    SacarTodasLasDeColor_(color)
}
4.En cada uno de los casos siguientes, definir de la forma indicada el procedimiento
VaciarTableroDe_(color), que quite todas las bolitas del color dado por el
parámetro color de cada una de las celdas del tablero. El cabezal puede empezar
en cualquier celda del tablero, y también puede terminar en cualquier celda del
tablero (ya sea la celda inicial o cualquier otra).

a.Estructurar el procedimiento como un recorrido sobre las filas . ¿Qué
2 subtareas van a precisarse en este caso? ¿Es necesario volver a definirlas o
se pueden encontrar en esta práctica?
procedure VaciarTableroDe_(color){
    /*Propósito: quitar todas las bolitas del color "color"  a partir de la celda actual . 
     El cabezal puede empezar en cualquier celda de la fila, y también puede terminar en cualquier celda 
     de la fila ya sea celda inicial o cualquier otra ya que es un recorrido por filas.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar del tablero.
    Precondicion: ninguna.
    Obsrvecion: es un recorrido por filas.
    */
   IrAlInicioDelTableroAl_YAl_(Este, Norte)
   while(hayProximoElementoAl_YAl_(Este,Norte)){
    VaciarFilaDe_(color)
    PasarAProximoElementoAl_Y_(Este, Norte)
   }
   VaciarFilaDe_(color)
}
procedure IrAlInicioDelTableroAl_YAl_(primerDireccion, segundaDireccion){
    /*
        Propósito: ir al inicio del tablero a partir de la celda actual.
        Precondicion:ninguna.
        Parametros: 
            *primerDireccion: Direccion, describe  la primer direccion a moverse.
            *segundaDireccion: Direccion, describe  la segunda direccion a moverse.
        COMO RECORRO POR FILAS PRIMERDIRECCION=ESTE Y SEGUNDADIRECCION= NORTE
    */
    IrAlBorde(opuesto(primerDireccion))
    IrAlBorde(opuesto(segundaDireccion))
}
function hayProximoElementoAl_YAl_(primerDireccion,segundaDireccion){
    /*
    Proposito: indica si esta en el final del recorrido.
    Precondicion: ninguna
    Tipo: Booleano.
    */
    return (puedeMover(primerDireccion) || puedeMover(segundaDireccion))

}
procedure PasarAProximoElementoAl_ Y_(primerDireccion, segundaDireccion){
    /*Proposito: pasar a la proxima fila a procesar.
     Precondicion: ninguna.
    
    while(finalDelRecorrido()){//Norte
        IrAlBorde(opuesto(Este))
        Mover(Norte)
    ESTO NO HACE NADA POR ESO TENGO QUE USAR UNIF???!!!!!!!OJO
    */
    if(puedeMover(primerDireccion)) then{
        Mover(primerDireccion)   
    }
    else{
        Mover(segundaDireccion)
        IrAlBorde(primerDireccion)
    }
}
b.Estructurar el procedimiento como un recorrido sobre las celdas del tablero.
Las subtareas necesarias serán diferentes, y puede ser que sea necesario
definir alguna que aún no está disponible en esta práctica.
procedure VaciarTableroDe_(color){
    /*Propósito: quitar todas las bolitas del color "color"  de un tablero a partir de la columna actual . 
     El cabezal puede empezar en cualquier celda de la columna, y también puede terminar en cualquier celda 
     de la columna ya sea celda inicial o cualquier otra ya que es un recorrido por columnas.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar del tablero.
    Precondicion: ninguna.
    */
   IrAlInicioDelTableroAl_YAl_(Este, Norte)
   while( hayProximoElementoAl_YAl_(Este,Norte)){
        VaciarColumnaDe_(color)// solo cambio esto del codigo, que ademas  solo le cambio las direcciones 
    PasarAProximoElementoAl_Y(Este, Norte)
   }
   VaciarColumnaDe_(color)
}
procedure VaciarColumnaDe_(color){
    /*Propósito: quitar todas las bolitas del color "color" de cada una de las celdas
      de la columna actual . El cabezal puede empezar en cualquier celda de la fila,y 
     también puede terminar en cualquier celda de la fila ya sea celda inicial o cualquier 
     otra.
    Parametros: 
        *colorASacar: Es un color que indica el color de las bolitas a sacar de la fila.
    Precondicion: ninguna.

     //  Sacar_DeColor_(nroBolitas(colorASacar), colorASacar)// def. guia 4 ejercicio 9, resolucion anterior.
   
    */
    IrAlBorde_(Sur) //como es un recorrido por columna puede ser Norte tambien 
    while(puedeMover(opuesto(Sur))){ //condiciona la repe
        SacarTodasLasDeColor_(color) // def en el punto anterior,tiene un whilw lo puwdo usar
        Mover(opuesto(Sur))                                   // o estoy anidando whiles?????   
    }
    SacarTodasLasDeColor_(color)
}
c.Reflexionar sobre las diferencias de los recorridos dados en los puntos a. y b.
¿Qué subtareas son más complejas en cada caso?
*Pasar a proximo fila requiere de un condicional, como no sabemos las cantidad de bolitas de cada 
celda que vamos a vacias ya que no queremos que esten representadas lo podemos resolver con una
repeticion condicional.

¿Podrían considerarse otros recorridos que no fueran sobre celdas o filas? 
*No consideriaria otros recorridos que no fueran por filas( hacia diferentes direcciones) o por
 celdas.

5.Considerar los recorridos por filas y por celdas del tablero realizados en el ejercicio
anterior, y en cada uno, las posibles direcciones en las que se realiza el
procesamiento.

a.En el caso del recorrido por filas, ¿cuántas posibilidades hay para recorrer
todas las filas (suponiendo que ya está hecho el procedimiento para procesar
una fila)? ¿Qué dato es el que cambia en cada caso?
*Cambia la direccion de inicio ya que podemos recorrer la ila de Oeste a Este  o de Este a Oeste.

b.En el caso del recorrido por celdas, ¿cuántas posibilidades hay para recorrer
todas las celdas?
*Cambia la direccion de inicio ya que podemos recorrer la ila de Sur  a Norte  o de Norte a Sur.

c.Volver a definir los recorridos por filas y por celdas del ejercicio anterior, pero
con diferentes direcciónes de recorrido.

6.Escribir el procedimiento VaciarFilaDe_HaciaEl_(color, dirección), que
generalice el recorrido de la fila, recibiendo la dirección de movimiento como
parámetro. ¿Cuáles son los valores posibles para el parámetro dirección? ¿Por
qué no puede ser cualquiera, si lo que se desea es recorrer una fila?
procedure VaciarFilaDe_HaciaEl_(color, dirección) {
    /*   //???????????????????????
        Procedimiento:vaciar la fila "color" hacia la "dirección".
                      El cabezal puede empezar en cualquier celda de la fila,y también puede 
                      terminar en cualquier celda de la fila ya sea celda inicial o cualquier 
                      otra.
        Parametros: 
        *dirección: Dirección, que describe la dirección hacia donde inicia el recorrido de la fila.
        *color: Color, es un color que describe el color de las bolitas a sacar.
        Precondicion: ninguna.
    */
    IrAlInicioDelRecorridoAl_(dirección) //como es un recorrido por columna puede ser Norte tambien 
    while(puedeMover(opuesto(dirección))){ //condiciona la repe
        SacarTodasLasDeColor_(color) // def en el punto anterior,tiene un whilw lo puwdo usar o estoy anidando whiles?????  
        Sacar_DeColor_(nroBolitas(color), color) // o mejor uso este????
        Mover(opuesto(dirección))                                    
    }
    SacarTodasLasDeColor_(color)
    Sacar_DeColor_(nroBolitas(color), color)    
}
7.BIBLIOTECA Escribir los procedimientos necesarios para generalizar la noción de
recorrido por celdas de un tablero, para que las direcciónes de recorrido no estén
fijas. En particular, definir (como siempre, comenzando por los contratos):

a.IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria){
    /*   
        PROPÓSITO: ir a la primera celda de un recorrido
        PARÁMETROS:
            * dirPrincipal:Dirección, escribe la direcciona moverse.
            * dirSecundaria: Direccion, escribe la direcciona moverse.
        PRECONDICIONES: las direcciones dadas no deben ser opuestas y tampoco pueden ser iguales.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}
//b.haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPÓSITO: indica si hay una celda en las direcciones por "dirPrincipal" y "dirSecundaria". 
        PARÁMETROS:
            * dirprincipal: Direccion, describe la direccion a mover.
            * dirSecundaria: Direccion, describe la direccion a mover.
        PRECONDICIONES: las direcciones dadas no deben ser opuestas y tampoco pueden ser iguales.
        TIPO: Booleano.
    */
    return( puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}
//c.IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)  {
    /*
        PROPÓSITO: ir a la siguiente celda dada por las direcciones "dirPrincipal" y "dirSecundaria".
        PARÁMETROS:
            * dirPrincipal: Direccion - describe la direccion a mover.
            * dirSecundaria: Direccion - describe la direccion a mover.
        PRECONDICIONES: ninguna.
    */
    if(puedeMover(dirPrincipal))then{
        Mover(dirPrincipal)
    }
    else{
        Mover(dirSecundaria)
        IrAlBorde(opuesto(dirPrincipal))
    }
}
Al escribir las precondiciones, tener en cuenta que las direcciones no pueden ser
cualesquiera, sino que deben estar relacionadas… ¿Cuál es esa relación? ¿Cómo
expresarla?
Las direcciones dadas no deben ser contrarias y tampoco deben ser iguales.

8.EN PAPEL El caminante
Se puede modelar el paseo de un caminante por el tablero con las siguientes
consideraciones para la representación.

●El caminante está representado por una a cuatro bolitas azules. La dirección
de su paseo es Norte si es una bolita, Este si son dos, Sur si son tres y Oeste
si son cuatro.

●Las indicaciones de cambio de dirección se representan con bolitas verdes.
Si el caminante llega a una celda con una de estas indicaciones, debe
cambiar de dirección. La cantidad de bolitas verdes indica la nueva dirección,
con la misma representación de direcciones dadas para el caminante.

●El caminante deja una huella de bolitas negras a su paso, una por cada paso.

●La meta se representa con cualquier número de bolitas rojas. El paseo del
caminante termina si llega a la meta.

●La celda actual siempre se encuentra sobre el caminante.

●La única celda con bolitas azules es la del caminante.

●Todas las celdas tienen un máximo de 4 bolitas verdes.

●Las indicaciones llevan al caminante a la meta.

Como ayuda para guiar la división en subtareas, ya se realizó un análisis top-down
de la estrategia, y se eligieron ciertas subtareas. Se pide, entonces, implementar los
procedimientos y funciones que expresan dichas subtareas, que son los indicados a
continuación. Observar que en su gran mayoría, las tareas están presentadas en
forma top-down, por lo que es interesante mirarlas todas antes de empezar a
implementar, y definir todos los contratos antes de proceder a escribir el código de
cada una, ya que las de niveles más alto se pueden servir de las de niveles más
bajos. Además, puede tomarse la siguiente función como primitiva:
//function direcciónDelCódigo_(código)
/* PROPÓSITO: describir la dirección correspondiente al código dado
PRECONDICIONES: el código está entre 1 y 4
PARÁMETROS: código: Número. El número que codifica la dirección descripta
*/
Al escribir los contratos, no olvidar establecer las precondiciones necesarias (ya que
las mismas no siempre se explicitan en los enunciados).

a.caminante(), indicador(), huella() y meta(), que describen los
colores con los que se representa cada uno de los elementos nombrados.

b.LlevarAlCaminanteALaMeta() que, suponiendo que en el tablero está
representado un escenario válido para el caminante, lleva al caminante hasta
la meta.

c.estáEnLaMeta() que indica si el caminante está o no en la meta.

d.DarUnPaso() que realiza un paso en el paseo del caminante, de acuerdo a
las siguientes reglas:

i.Si el caminante ya llegó a destino, no hay nada que hacer.

ii.Si hay que cambiar la dirección, lo hace.

iii.Finalmente, se mueve en la dirección correspondiente.

No hay que olvidar que el caminante debe dejar una huella. En la Figura 1 se
ofrece un ejemplo del uso de DarUnPaso() en medio de la ejecución del
programa.

e.CambiarDeDirecciónSiHayIndicador() que cambia la dirección del
caminante cuando se encuentra con un indicador.
f.DejarHuella() que deja una huella en la celda actual.
g.MoverAlCaminanteAl_(dirección) que mueve al caminante un paso en
la dirección dada.

h.hayIndicadorDeCambioDeDirección() que describe verdadero cuando
en la celda actual hay un indicador de dirección.

i.direcciónIndicada() que describe la dirección en la que está mirando
el caminante.

j.Cambiar_ParaImitar_(colorACambiar,colorAImitar) que
cambia la cantidad de bolitas de colorACambiar según la cantidad de
bolitas de colorAImitar que haya en la celda actual.

k.Mover_Bolitas_Al_(cantidad,color,dirección) que “mueve”
(es decir, quita de una celda para llevar a la otra) la cantidad indicada de
bolitas de color a la celda lindante en la dirección dada, y deja el
cabezal en esa celda. Suponer que hay una celda lindante en esa dirección.

9. Distribución de mercadería
Se desea modelar el movimiento de mercadería en una sencilla red de depósitos,
que tiene un depósito central, más un depósito local para cada punto cardinal. Para
esto, se va a representar en el tablero un mapa muy simplificado.

● Tres bolitas negras marcan el depósito central,

● dos bolitas negras marcan un depósito local,

● una bolita negra marca el camino de central a local,

● cada bolita azul marca una unidad de mercadería.

Los depósitos locales forman una cruz, donde el centro es el depósito central. No se
sabe a qué distancia están los depósitos locales del depósito central. Este es un
ejemplo de modelo:
Escribir
a.esDepósitoCentral() y esDepósitoLocal() que indican si el cabezal
está, respectivamente, en el depósito central o en un depósito local.
function esDepósitoCentral(){
    /*
        Propósito: indican si el cabezal está en el depósito central.
        Precondición: ninguna.
        Tipo: Booleao.
    */
    return( nroBolitas(Negro) == 3)
}
function esDepósitoLocal(){
    /*
        Propósito: indican si el cabezal está en el depósito local.
        Precondición: ninguna.
        Tipo: Booleao.
    */
    return( nroBolitas(Negro) == 2)
}
function esCaminoADeposito(){
    /*
        Propósito: indican si el cabezal está en elcamino de un depósito a otro.
        Precondición: ninguna.
        Tipo: Booleao.
    */
    return( nroBolitas(Negro) == 1)
}
function numeroDeMercaderia(){
    /*
        Propósito: describe una unidad de mercaderia .
        Precondición: ninguna.
        Tipo: Numero, describe una unidad de mecaderia.
    */
    return( nroBolitas(Azul))
}
b.IrDeCentralAlLocal_(dirección), que mueve el cabezal del depósito
central al depósito local que está en la dirección dada, suponiendo que el
cabezal comience en el depósito central.
procedure IrDeCentralAlLocal_(dirección){
    /*
        Propósito: mueve el cabezal del depósito central al depósito local 
        que está en la "dirección" dada, el cabezal comienza el depósito central.
        Prencondición: debe haber un deposito en la direccion dada.
        Parametros:
         *dirección: Direccion, describe la direccion hacia donde se va a 
          mover el cabezal en el recorrido.
    */ 
    Mover(dirección) //  OJo si o si me tengo que mover para iniciar
    while(esCaminoADeposito()){ //condiciona la repe
        Mover(dirección) 
    }
}
c.IrDelLocal_ACentral(dirección), que mueve el cabezal al depósito
central, suponiendo que el cabezal está en el depósito local que está en la
dirección dada.
Aclaración: si se pide IrDelLocal_ACentral(Sur), quiere decir que el
cabezal está en el depósito Sur, por lo tanto, debe moverse hacia el Norte.
Antes de seguir, un ejemplo de uso de estos dos procedimientos. A partir del tablero
que se mostró, IrDeCentralAlLocal_(Sur) deja el cabezal en el depósito local
Sur, o sea:
A partir de este tablero, IrDelLocal_ACentral(Sur) “vuelve” al tablero inicial, o
sea, el cabezal va al depósito central.
procedure IrDelLocal_ACentral(dirección){
    /*
        Propósito: muever el cabezal al depósito central, suponiendo que el 
        cabezal está en el depósito local que está en la dirección dada. 
        Prencondición: ninguna.
        Parametros:
         *dirección: Direccion, describe la direccion hacia donde se va a 
          mover el cabezal en el recorrido.
    */
    Mover(opuesto(dirección)) //  OJo si o si me tengo que mover para iniciar
    while(esCaminoADeposito()){ //condiciona la repe y este cso procesa elemento
        Mover(opuesto(dirección) ) //pasa a prox elemento y procesa
    }
}
d.Llevar_MercaderíasAlLocal_(cantidad,dirección), que lleva la cantidad de mercadería indicada del depósito central al depósito local
que está en la dirección indicada. Si en el depósito central no hay suficiente
cantidad de mercadería, no se hace nada. Se puede suponer que el cabezal
está en el depósito central, y debe dejarse en el mismo lugar.
Por ejemplo a partir del tablero inicial dado como ejemplo,
Llevar_MercaderíasAlLocal_(3, Sur) tiene este efecto:
procedure Llevar_MercaderíasAlLocal_(cantidad,dirección) {
    /*
        PROPÓSITO: lleva la cantidad de mercadería indicada "cantidad" del depósito central al depósito local
        que está en la dirección indicada "dirección".
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia.
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna.
    */
    Preparar_SiHayMercaderiasParaElLocal_(cantidad, dirección)
    while(esCaminoADeposito()){ //condiciona la repe y este cso procesa elemento
        Mover(dirección)  //pasa a prox elemento y procesa
    }
    Recibir_MercaderiasYVolverAlCentral_(cantidad, dirección)
}
procedure Preparar_SiHayMercaderiasParaElLocal_(cantidad, dirección) {
    /*
        PROPÓSITO: mandar (quita del stock) si hay  una mayor o igual "cantidad" de unidades d mercaderia
        del deposito Central al inicio del camino al deposito Local, sino no hace nada.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia.
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    if(numeroDeMercaderia() >= 3) then{
        Sacar_DeColor_(3,Azul)
        Mover(dirección)
    }    
}
procedure Recibir_MercaderiasYVolverAlCentral_(cantidad, dirección) {
    /*
        PROPÓSITO: mandar (quita del stock) si hay  una mayor o igual "cantidad" de unidades d mercaderia
        del deposito Central al inicio del camino al deposito Local.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia. 
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    Poner_DeColor_(cantidad,Azul)
    IrDelLocal_ACentral(dirección)   
}    
e.Traer_MercaderíasDelLocal_(cantidad, dirección), que lleva la cantidad de mercadería 
indicada del depósito local en la dirección
indicada, al depósito central. Si en el depósito local indicado no hay suficiente
cantidad de mercadería, no se hace nada. Se puede suponer que el cabezal
está en el depósito central, y debe dejarse en el mismo lugar. Por ejemplo, a
partir del tablero inicial, Traer_MercaderíasDelLocal_(3, Sur) tiene
este efecto:
procedure Traer_MercaderíasDelLocal_(cantidad,dirección){
    /*

    */
    Recibir_MercaderiasDelLocal_(cantidad, dirección)
    while(esCaminoADeposito()){ //condiciona la repe y este cso procesa elemento
        Mover(opuesto(dirección) ) //pasa a prox elemento y procesa
    }
    Preparar_MercaderiasAlLocal_(cantidad, dirección)
}
procedure Preparar_MercaderiasAlLocal_(cantidad, dirección) {
    /*
        PROPÓSITO: del camino al deposito Local.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia.
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    if(esMercaderia() >= 3) then{
        Sacar_DeColor_(3,Azul)  
    }
    IrDelLocal_ACentral(dirección)        
}
procedure Recibir_MercaderiasDelLocal_(cantidad, dirección) {
    /*
        PROPÓSITO: mandar (quita del stock) si hay  una mayor o igual "cantidad" de unidades d mercaderia
        del deposito Central al inicio del camino al deposito Local.
        PARÁMETROS:
            * cantidad: Numero - describe las unidades de mercaderia. 
            * direccion: Direccion - describe la direccion a moverse y del deposito.
        PRECONDICIONES: ninguna
    */
    Poner_DeColor_(cantidad,Azul)
    IrDelLocal_ACentral(dirección)
}
f.Mover_MercaderíasDelLocal_AlLocal_(cantidad,origen,destino), que mueve la cantidad
 indicada de mercadería del depósito local que está en dirección origen al que está en 
dirección destino. Si en el depósito origen no hay la cantidad de mercadería necesaria, 
no se hace nada.
Por ejemplo, a partir del tablero inicial, Mover_MercaderíasDelLocal_AlLocal_(3,Este,Sur) 
tiene este efecto:
procedure Mover_MercaderíasDelLocal_AlLocal_(cantidad,origen,destino) {
    /*
        PROPÓSITO: mover  la "cantidad" de mercaderia del deposito local que esta en "origen"
        al que esta en direccion "destino".Si en el depósito origen no hay la cantidad de mercadería necesaria, 
        no se hace nada.
        PARÁMETROS:
            * parámetro1: Numero - describe el numero de mercaderia a mover entre los depositos.
            * parámetro2: Direccion - describe la  primer direccion  a mover del deposito Local.
            * parámetro2: Direccion - describe la  segunda direccion  a mover del destino del  deposito Local.
        PRECONDICIONES: ninguna.
    */
    Traer_MercaderíasDelLocal_(cantidad,origen)
    Llevar_MercaderíasAlLocal_(cantidad,destino)
}
10.En este ejercicio el tablero tiene información sobre las apuestas de diferentes
jugadores en un casino, para un juego de extracción de números. En la mesa del
juego hay una cantidad de jugadores, cada uno identificado por un número. Cada
celda del tablero representa una apuesta, de la siguiente forma.
●Bolitas rojas: el número de jugador.
●Bolitas azules: el número apostado.
●Bolitas verdes: el monto apostado, donde cada bolita verde es un peso.

Puede haber varias apuestas del mismo apostador, a distintos números.
A modo de ejemplo, se muestra uno de los posibles tableros que modela la siguiente
situación:
●El jugador 1 apostó 19 pesos al 48.
●El jugador 2 apostó 22 pesos al 7 y 13 pesos al 13.
●El jugador 3 apostó 5 pesos al 15.
●Queda espacio para registrar dos apuestas más.
Escribir las siguientes operaciones. En cada caso, recordar escribir primero el
contrato, y expresar la estrategia usando subtareas (preferentemente con la
metodología top-down).

a.AgregarApuestaDe_Al_Para_(monto, nroApostado, nroJugador)
que agrega la apuesta indicada en alguna celda vacía, la cual debe existir.

b.PagarYCobrarAl_(nroQueSalió),que pague las apuestas que certaron, y retire el total 
del dinero de las que no acertaron (solamente el dinero).
Se paga 5 veces el monto de la apuesta; por ejemplo, para una
apuesta de 3 pesos se pagan 15, quedando 18 pesos en la celda.

c.RecogerPropinas(), que extrae un peso de cada celda donde haya al
menos 15 pesos.

d.SeVaElJugador_(nroJugador), que borra todas las celdas que registran
una apuesta del jugador indicado.

e.DuplicarApuestasAl_(nroApostado), que duplica el monto de las
apuestas al número indicado.

f.DuplicarApuestasDelJugador_(nroJugador), que duplica el monto
de las apuestas que hizo el jugador indicado.

g.CambiarNroApostadoDel_Al_(nroAnterior, nroNuevo), que
cambia todas las apuestas de nroAnterior para que pasen a apostar a
nroNuevo.

h. AumentarEn_LaApuestaDelJugador_Al_(monto,nroJugador,nroApostado), que agrega el 
monto indicado a la apuesta de este jugadoral número dado.

i.BuscarApuestaDelJugador_Al_(nroJugador, nroApostado), que
posiciona el cabezal en una celda que sea el registro de una apuesta del
jugador y número apostado indicados. Si no se ha registrado una apuesta
con estas características, el cabezal debe ubicarse en el extremo noreste.

--EJERCICION INTRODUCTORIOS VARIABLES Y FUNCIONES CON PROCESAMIENTO------



--GUIA VARIABLES ,RECORRIDOS DE ACUMULACION Y  FUNCIONES CON PROCESAMIENTO.
1.Escribir la función hayBolitas_EnElBorde_(color, dirección), que indica
si en la celda que se encuentra en el borde dado por la dirección, hay bolitas del
color indicado.
function hayBolitas_EnElBorde_(color, dirección) {
    /*
        PROPÓSITO: indica si en la celda que se encuentra en el borde dado por la dirección "direccion", 
        hay bolitas del color "color"
        Indica si hay bolitas en color dado en el borde dado
        PARÁMETROS:
            * parámetro1: tipo - descripción.
            * parámetro2: tipo - descripción.
        PRECONDICIONES: ninguna
        Tipo: Booleano.
    */
    IrAlBorde(dirección)
    return ((hayBolitas(color)))  
}
2.BIBLIOTECA Escribir la función tieneBolitas_Al_(color, dirección), que,
suponiendo que existe una celda lindante en la dirección dada, indica si la misma
tiene o no bolitas del color indicado
function tieneBolitas_Al_(color, dirección){
     /*
        PROPÓSITO: suponiendo que existe una celda lindante en la dirección "direccion", indica si en la celda que
         se encuentra en el borde dado por la dirección "direccion", hay bolitas del color "color"
        PARÁMETROS:
            * color: Color - describe el color de las bolitas que hay.
            * direccion: Direccion - describe la direccion hacia donde va a chequear  si hay bolitas 
        PRECONDICIONES: debe existir una celda en direccion "direccion"
        Tipo: Booleano.
    */
    Mover(dirección)
    return(hayBolitas(color))
}
3.BIBLIOTECA Escribir la función hayBolitas_Al_(color,dirección), que
indica si hay una celda lindante en la dirección indicada y la misma 
tiene bolitas del color dado.
function hayBolitas_Al_(color,dirección){
     /*
        PROPÓSITO: indica si en la celda que se encuentra en el borde dado por la dirección "direccion", hay bolitas del color "color"
        PARÁMETROS:
            * color: Color - describe el color de las bolitas que hay.
            * direccion: Direccion - describe la direccion hacia donde va a chequear  si hay bolitas 
        PRECONDICIONES: debe existir una celda en direccion "direccion"
        Tipo: Booleano.
    */
    return( puedeMover(dirección) && tieneBolitas_Al_(color, dirección))
}
4.Escribir las funciones máximoEntre_Y_(valor1, valor2),
mínimoEntre_Y_(valor1,valor2) que describen el valor más grande o más
chico, respectivamente, de los valores dados. ¿Qué herramienta hace falta? Si el
código resultante utiliza una función con procesamiento, ofrecer otra versión que no
utilice solamente funciones sin procesamiento.
function máximoEntre_Y_(valor1, valor2) {
    /*
    PROPOSITO: describe el valor mas grande de los dados.
    PARAMETROS:
        * valor1; un valor de cualquier tipo, representa el primer valor a verificar.
        * valor2; un valor de cualquier tipo, representa el segundo valor a verificar.
    RESULTADO: un valor del Tipo dado.
    PRECONDICIONES: 
        * los valores dados deben ser del mismo tipo.
    */
    return (
        choose valor1 when (valor1 >= valor2) //condicion,el valor1 es mas grande que valor2
               valor2 otherwise
    )
}

function mínimoEntre_Y_(valor1,valor2) {
    /*
    PROPOSITO: describe el valor mas chico de los valores dados.
    PARAMETROS:
        * valor1; un valor de cualquier tipo, representa el primer valor a verificar.
        * valor2; un valor de cualquier tipo, representa el segundo valor a verificar.
    RESULTADO:un valor del Tipo dado.
    PRECONDICIONES:
        * los valores dados deben ser del mismo tipo.
    */
    return (
        choose valor1 when (valor1 <= valor2)
               valor2 otherwise
    )
}
5. Escribir la función nroBolitas_EnLaFilaActual(color) que describa la
cantidad de bolitas del color dado en la fila actual.

a. Escribir la solución con un recorrido de la fila actual que utilice una variable
cantidadDeBolitasYaVistas cuyo propósito sea describir la cantidad
de bolitas del color correspondiente que se contaron en cada momento.
¿Cuántas se vieron antes de empezar a contar? ¿Cómo estar seguro que se
consideraron todas las celdas para contarlas?
function  nroBolitas_EnLaFilaActual(color){
     /*   
        PROPÓSITO: describe el numero de bolitas del color "color" de la fila actual.
        PARÁMETROS:
            * color: Color - describe el color de las bolitas a contar.
          
        PRECONDICIONES: ninguna
        Tipo: Numero, describe el numero total de bolitas "color" de la fila actual.
    */
    cantidadDeBolitasYaVistas := 0  // inicio el contdor
    while(puedeMover(Este)){
        Mover(Este)
        cantidadDeBolitasYaVistas := cantidadDeBolitasYaVistas + nroBolitas(color)
    }
    cantidadDeBolitasYaVistas := cantidadDeBolitasYaVistas + nroBolitas(color) // caso de borde
    return(cantidadDeBolitasYaVistas)
}
b. ¿En qué celda queda el cabezal al utilizar la función desde cualquier punto
del programa? ¿Por qué?

En la celda de inicio ya que el recorrido de busqueda del numero de  bolitas Rojo es imaginario  o sea que no se mueve de la celda de inicio
para buscar el numero de bolitas rojas.

6.Escribir las funciones nroFilas() y nroColumnas() que describan la cantidad de
filas y columnas del tablero. ¿Se podría conocer la cantidad de filas o columnas del
tablero sin que el cabezal se mueva realmente de la celda actual?
Si se puede con una funcion con procesamiento como la de la  resolucion.
¿Qué habría que usar si hubiese que hacerlo exclusivamente con procedimientos?
Subtareas???
function nroFilas(){  
    /*
        PROPÓSITO: describe el  numero de filas de un tablero.
          
        PRECONDICIONES: ninguna
        Tipo: Numero, describe el numero de filas de un tablero
    */
   numeroDeFilas := 0 // Inicio el procesamiento
    while(puedeMover(Este) && puedeMover(Norte)){ // condiciono la repe
        Mover(Norte) // mueve para que no de error el while 
        numeroDeFilas := numeroDeFilas + 1  // procesa elemento(cuenta la fila)
    }
    return(numeroDeFilas)
}
function nroColumnas(){  
    /*
        PROPÓSITO: describe el  numero de columnas de un tablero.
          
        PRECONDICIONES: ninguna
        Tipo: Numero, describe el numero de filas de un tablero
    */
    numeroDeColumnas := 0 // por que siempre va existir una fila.
   
    while(puedeMover(Norte) && puedeMover(Este)){
        Mover(Este)
        numeroDeColumnas := numeroDeColumnas + 1 
    }
    return(numeroDeColumnas)
}
7.Escribir la función distanciaAlBorde_(dirección), que describe la cantidad de
celdas que hay entre la celda actual y el borde indicado. Observación: si la celda
actual se encuentra en el borde, la distancia es 0.
function distanciaAlBorde_(dirección){
    /*
        PROPÓSITO: describe el  numero de celdas que hay entre la celda actual y el borde "dirección".
          
        PRECONDICIONES: ninguna
        Tipo: Direccio, describe la direccion hacia donde se va a medir la distancia. 
    */
    distanciaHaciaElBorde := 0 // inicio el procesamiento
    while(puedeMover(dirección)){  // condiciono la repe
        Mover(dirección)                                    // proceso elemento
        distanciaHaciaElBorde := distanciaHaciaElBorde + 1 // proceso elemnto
    }
    return(distanciaHaciaElBorde)
}
8. Escribir las funciones coordenadaX() y coordenadaY() que retornen la
coordenada columna y la coordenada fila de la celda actual, respectivamente.
Suponer que 0 es la coordenada de la primer fila y columna. ¿Es necesario escribir
un recorrido para estas funciones, o puede reutilizarse alguna otra función ya
hecha?
Se puede usar la funcion echa en el punto anterior ya que parametriza las direcciones de 
los bordes a los que me puedo dirigir.
function coordenadaX(){
     /*
        PROPÓSITO: describe el  numero de la coordenada X a partir de la celd actual.
          
        PRECONDICIONES: la celda de inicio es la coordenada de la primer fila y columna 0,0.
        Tipo: Numero, describe la coordenada X de un eje. 
    */
    return(distanciaAlBorde_(Este))
}
function coordenadaY(){
     /*
        PROPÓSITO: describe el  numero de celdas que hay entre la celda actual y el borde "dirección".
          
        PRECONDICIONES: ninguna
        Tipo: Direccio, describe la direccion hacia donde se va a medir la distancia. 
    */
    return(distanciaAlBorde_(Norte))
}
9. El bosque, parte 3

a.Escribir las funciones árbol(), semilla(), bomba(), nutriente() que
describen las representaciones de los elementos del ejercicios “El bosque”,
de las prácticas 4 y 5.
function semilla() {
    /*
    PROPOSITO: denota un el color de la semilla.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Rojo)
}
function arbol() {
    /*
    PROPOSITO: denota un el color del arbol.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Verde)
}
function bomba() {
    /*
    PROPOSITO: denota un el color de la bamba.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Negro)
}
function Nutriente() {
    /*
    PROPOSITO: denota un el color del nutriente.
    RESULTADO: un Color.
    PRECODICIONES: no tiene.
    */
    return (Azul)
}
b.Escribir la función nroTotalDeÁrbolesEnElTerreno() que describa la
cantidad de árboles que hay en el bosque. Organizar el código como un
recorrido genérico sobre las parcelas instanciado para el sentido Sur-Oeste.
function  nroTotalDeÁrbolesEnElTerreno(){
     /*
    PROPOSITO: describe la cantidad total de árboles que hay en el bosque.
    RESULTADO: un Numero.
    PRECONDICIONES: las direcciones no pueden opuestas ni iguales.
    OBSERVACION: se realizará un recorrido genérico sobre las parcelas en 
    sentido Sur-Oeste.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte) //va al inicio del recorrido
    numeroDeArbolesYaContados := 0               // inicia el contador
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){ // si cumple cond, osea si hay siguiente celda para procesar para ver si hay arbol
        numeroDeArbolesYaContados := numeroDeArbolesYaContados + nroBolitas(arbol()) // procesa arbola cuenta las bolitas Verde porque el numero represntan los arboles
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)                            // pasa al prox arbol y aprte para que funcione el while
    }
    numeroDeArbolesYaContados := numeroDeArbolesYaContados + nroBolitas(arbol())   // OJOOOO  caso de borde 
    return(numeroDeArbolesYaContados )                       
}
10. Escribir una función nrovacias() que describa la cantidad de celdas vacias del
tablero. Estructurar el código como recorrido de celdas.
Con respecto al código:recordar que no es buena práctica anidar herramientas en el mismo
procedimiento o función. ¿Cómo hacer, entonces, para aumentar la cantidad de
vacias en cada momento, dado que la variable solo puede modificarse de forma local?
function nroVacias(){
     /*
    PROPOSITO: describe la cantidad de celdas vacias del tablero.
    RESULTADO: un Numero.
    PRECONDICIONES: las direcciones no pueden opuestas ni iguales.
    OBSERVACION: se realizará un recorrido genérico sobre las parcelas en 
    sentido Sur-Oeste.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte) // inicio el recorrido
    numeroDeCeldasVaciasYaVistas := 0              // inicio el contador
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){ //cond repe se mueve miestars hay celdas al este y al NOrte.
        numeroDeCeldasVaciasYaVistas :=  
            numeroDeCeldasVaciasYaVistas +  unoSi_CeroSino(esCeldaVacia()) // proceso celda esta vez con el COND EL CONTEO // funcion biblioteca
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    numeroDeCeldasVaciasYaVistas +  unoSi_CeroSino(esCeldaVacia())
    return(numeroDeCeldasVaciasYaVistas)
}
function unoSi_CeroSino(condicion) { // funcion de biblioteca
    /*
    PROPOSITO: describe un uno si hay una celda vacia, y un cero en 
    caso contrario.
    PARAMETROS:
        * condición; tipo Booleano, representa la condicion a evaluar.
    RESULTADO: un Numero.
    PRECONDICIONES: no tiene.
    */
    return (
        choose 1 when (esCeldaVacia()) // funcion Biblioteca
               0 otherwise
            )
}
Ayuda: considerar una función que devuelva la cantidad de celdas vacias que hay
considerando solamente la celda actual… (Observar que esa cantidad solamente
puede ser 1 o 0.)

11. Escribir una función colorMínimoConBolitas() que denote el color más chico
(en el orden Azul, Negro, Rojo, Verde) del cual hay bolitas en la celda actual.

a. Considerar primero el contrato. ¿Qué ocurre si en la celda actual no hay
bolitas de ningún color?
No funciona  ya que no hay bolitas de ningun color para evaluar la condicion entre los colores.

b. Escribir la solución organizada como un recorrido de búsqueda sobre los
colores que use una variable colorActual cuyo propósito sea denotar el
color que se está recorriendo.
function colorMínimoConBolitas(){
    /*
        Proposito: denote el color más chico de la celda actual.
        Precondicion: debe existir al menos una bolita de algun  color.
        Tipo: Color.
        Observacion: es un recorrido de busqueda sobre colores.

    */
    colorActual := minColor()  // inicio el recorrido buscando el color mini
    while(not hayBolitas(colorActual)){ // sino hay color minimo
        colorActual := siguiente(colorActual) // declaro al prox color que hay como mini
    }
    return(colorActual)
}

c. ¿La solución funciona si se agregan más colores a Gobstones? En caso
negativo, modificar la solución para que funcione con cualquier cantidad de
colores.
Funciona para cualquier color que elija.

Ayuda: considerar utilizar las expresiones primitivas minColor() y maxColor() que 
describen al color más chico y al color más grande posibles.

12. Nova enfrentó su primer revisión de pares de su código, y no le fue muy bien. Los
nombres de la mayoría de las funciones que escribió son letras sueltas, que no
aportan legibilidad, ¡y encima no escribió los contratos de ninguna de las funciones!
(El caradura puso los comentarios con puntitos. Se vé que vio en el código de
algunos colegas algo parecido, y no se dio cuenta que en realidad el editor permite
colapsar secciones y las muestra con puntitos. Por suerte indenta bien, porque si no,
sería mucho más catastrófico…)
El revisor estuvo escribiendo los propósitos para cada función, pero lo hizo en una
serie de post-its (los cuadraditos de papel sueltos) y se mezclaron todas.

a.Corresponder las siguientes propuestas de propósito hechas por el revisor,
con las funciones correspondientes.

A. Describir el color del cual hay más bolitas en la celda actual.

B. Describir la cantidad de bolitas de la que hay más entre las bolitas de
los colores dados.

C. Describir la cantidad de bolitas del color dado que tiene el tablero.

D. Describir la cantidad total de bolitas de todos los colores de la celda
actual.

E. Describir el color de entre los dados que tiene más bolitas en la celda
actual.

F.Describir cuál es la mayor cantidad de bolitas del color dado que tiene
alguna celda del tablero.

G. Describir el mayor de dos valores dados.


b.Una vez hecha la correspondencia, renombrar las funciones, parámetros (y
sus usos) de manera adecuada, para que el programa resulte legible.

15. Escribir un procedimiento IrANésimaVacía_(n) que posicione el cabezal en la
celda vacía número n que se encuentra en un recorrido del tablero por celdas en las
direcciones Este y Norte. Si no hay suficientes celdas vacías, deja el cabezal en la
esquina NorEste.
Por ejemplo, IrANésimaVacía_(1) posiciona el cabezal en la primer celda vacía,
IrANésimaVacía_(2) posiciona el cabezal en la segunda celda vacía, etc.
Organizar la solución como un recorrido de búsqueda por celdas que utilice una
variable celdasVacíasYaVistas, cuyo propósito sea denotar la cantidad de
celdas vacías que ya se recorrieron.
procedure IrANésimaVacía_(n) {
    /*
        PROPÓSITO: posiciona el cabezal el en la celda numero "n".
        PARÁMETROS:
            * n: NUmero - describe el numero de  celda
        PRECONDICIONES: ninguna 
        Observacion: recorrido de 
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeCeldasVaciasVistas := 0
    while( haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && cantidadDeCeldasVaciasVistas /= n ){
        cantidadDeCeldasVaciasVistas := cantidadDeCeldasVaciasVistas + unoSiCeroSino(esCeldaVacía())// cuenta si esta vacia 
        MoverSiSonDistintas__(cantidadDeCeldasVaciasVistas, n)  // mueve solo si 
    }    
}
procedure MoverSiSonDistintas__(valor1, valor2){
    if(valor1 /= valor2){
            IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)    
     }
}
function unoSi_CeroSino(condicion){
    return(choose 1 when (condicion)
                  0 otherwise
          )
}
----opcion2--------------
procedure IrANésimaVacía_(n) {
    /*
        PROPÓSITO: posiciona el cabezal el en la celda numero "n".
        PARÁMETROS:
            * parámetro1: NUmero - describe el numero de  celda
        PRECONDICIONES: ninguna 
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    cantidadDeCeldasVaciasVistas := unoSi_CeroSino(esCeldaVacia())
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && cantidadDeCeldasVaciasVistas /= n ){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        cantidadDeCeldasVaciasVistas := cantidadDeCeldasVaciasVistas + unoSi_CeroSino(esCeldaVacia())
         MoverSi__SonDistintos(cantidadDeCeldasVaciasVistas,n)
    }    
}
procedure MoverSi__SonDistintos(valor1, valor2 ){
    if(valor1 /= valor2){
            IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)    
        }
}
function unoSi_CeroSino(condicion){
    return(choose 1 when (condicion)
                  0 otherwise
          )
}

16. La torre de control
En este ejercicio las columnas del tablero representan canales aéreos por los que
despegan y aterrizan aviones. Se considera que un canal está libre para aterrizar si
no hay avión en ninguna de las posiciones de ese el canal. Los aviones se
representan con tantas bolitas azules como el número de su vuelo, y con una bolita
Roja en la misma celda si está aterrizando o con una bolita Verde si está
despegando. El tablero representa a todo el aeropuerto; en cada celda hay a lo
sumo un avión. Implementar las siguientes operaciones:

a.La función cantidadDeCanalesLibres(), que devuelva la cantidad de
canales sin aviones.

b.La función cantidadDeAvionesDespegando(), que devuelva la cantidad
total de aviones que están despegando en todo el aeropuerto.

c.El procedimiento IrACanalLibreParaDespegar(), que deje el cabezal
en el primer canal libre más cercano al Sureste del aeropuerto.

d.La función cantidadDeAvionesTotales(), que devuelva la cantidad
total de aviones que están despegando/o aterrizando en todo el aeropuerto.

e.El procedimiento IrACanalLibreParaAterrizar(), que debe dejar al
cabezal en el primer canal libre más cercano al Noroeste del aeropuerto.

f.La función cantidadDeCanalesConColisiónInminente(), que devuelva la cantidad de carriles con posibles colisiones en todo el
aeropuerto. Se considera que hay una colisión posible si en el mismo carril hay un avión que está despegando debajo de un avión
que está aterrizando.

g.El procedimiento IrACanalConColisiónInminente(), que deje el cabezal en el primer Carril con una colisión inminente (desde el extremo
Suroeste del aeropuerto).

h. La función mayorNroDeVueloDespegando(), que retorne el número de vuelo más grande que esté despegando en el aeropuerto.

17. El casino, parte 2
En el marco del ejercicio del casino de la práctica 6, escribir las siguientes
operaciones. En cada caso, recordar escribir primero el contrato, y expresar la
estrategia usando subtareas (preferentemente con la metodología top-down).

a. estáElJugador_(nroJugador), que denota verdadero si el jugador indicado tiene registrada, al menos, una apuesta.

b. alguienJugóA_MasDe_(nroApostado, cantidadMínima), que denota verdadero si algún jugador apostó al número indicado por un monto mayor a
cantidadMínima.

---- GUIAS REGISTROS Y VARIANTES-------------------------------------------
1.Declarar un tipo variante llamado DíaDeLaSemana, que sirva para identificar los
días de la semana. Luego implementar las siguientes funciones (sin olvidar sus
contratos):
type DiaDeLaSemana is variant{
    /* Proposito: Modelar los dias de la semana.
    */
    case Lunes{}
    case Martes{}
    case Miercoles{}
    case Jueves{}
    case Viernes{}
    case Sabado{}
    case Domingo{}
}
a.díaSiguienteA_, que dado un día de la semana, devuelve el día siguiente.
function diaSiguienteA_(diaDeLaSemana){
    /*Proposito: describe el dia siguiente al "diaDelaSemana".
    Precondicion: ninguna.
    Parametro: 
        diaDeLaSemana: DiaDeLaSemana, representa el dia  para obtener el siguiente
    Tipo: DiaDeLaSemana.
    */
   return( choose Lunes when (diaDeLaSemana == Domingo )
                  Martes when(diaDeLaSemana == Lunes) 
                  Miercoles when(diaDelaSemana == Martes)
                  Jueves when (diadeLaSemana == Miercoles)
                  Viernes when (diaDeLaSemana == Jueves)
                  Sabado when (diaDeLaSemana == Viernes)
                  Domingo otherwise
         )                   
}
b.díaPrevioA_, que dado un día de la semana, devuelve el día previo.
function diaPrevioA_(diaDeLaSemana){
     /*Proposito: describe el dia previo al "diaDelaSemana".
    Precondicion: ninguna.
    Parametro: 
        diaDeLaSemana: DiaDeLaSemana, representa el dia  para obtener al previo.
    Tipo: DiaDeLaSemana.
    */
    return( choose Lunes when (diaDeLSemana == Martes )
                  Martes when(diaDeLaSemana == Miercoles) 
                  Miercoles when(diaDelaSemana == Jueves)
                  Jueves when (diadeLaSemana == Viernes)
                  Viernes when (diaDeLaSemana == Sabado)
                  Sabado when (diaDeLaSemana == Domingo)
                  Domingo otherwise
         )                   
}
c.es_DíaDeFinDeSemana, que indica si el día dado es uno del fin de semana.
function es_DiaDeFinDeSemana(diaDeLaSemana){
     /*Proposito: describe el dia "diaDelaSemana" es dia de fin de semana.
    Precondicion: ninguna.
    Parametro: 
        diaDeLaSemana: DiaDeLaSemana, representa el dia para obtener si es parte del finde semana.
    Tipo: DiaDeLaSemana.
    */
    return (( diaDeLaSemana == Sabado) &&  (diaDeLaSemana == Domingo))


}
2.Implementar las siguientes funciones utilizando el tipo Carta definido en la clase teórica

a.es_Figura, que dada una Carta, describa verdadero solo si es una figura.
Se dice que una carta española es una figura, porque sus dibujos
representan diferentes personajes. La carta con número 10 representa un
paje medieval, número 11 un caballero, número 12 el rey.
function es_Figura(carta){
    Proposito: indica si una "carta" es una figura.
    Precondicion: ninguna.
    Parametro:
    carta: Carta Española.
    Tipo: Booleano
    */
    return(nroCarta(carta) == 10 || nroCarta(carta) == 11 || nroCarta(carta) == 12)
// puedo definir las funciones es zota es caballo es rey

}

b.envidoCon_Y_, que dadas 2 cartas, describa el valor del envido. Tener en
cuenta la función realizada en clase teórica para el envido simple y
contemplar los nuevos casos. Cuando el envido tiene alguna figura, las
figuras no suman nada.

c.envidoCon_Y_mayorA_, que dadas 2 cartas y una cantidad, indique si
representa ese valor de envido o mayor

3.Implementar las siguientes funciones utilizando el tipo Celda.
type Celda is record{
    /*Proposito: modelar una celda del tablero.
    Inv Rep:  los numeros son mayores a cero.
    */
    field cantidadDeAzules // Numero. funcion observadora
    field cantidadDeRojos // Numero.
    field cantidadDeNegros // Numero.
    field cantidadDeVerdes // Numero.
}

a.celdaActual , que describa la celda actual.
function celdaActual(){
    /*Proposito: modelar una celda actual.
      Precondicion: ninguna.
      Tipo: Celda.
    */
    return (Celda ( cantidadDeAzules <- nroBolitas(Azul),
                    cantidadDeNegros <- nroBolitas(Negro),
                    cantidadDeVerdes <- nroBolitas(Verde),
                    cantidadDeRojos <-  nroBolitas(Rojo)
                  )
           )
}
b.cantidadDeAzulesEn_, que describe la cantidad de azules de la celda dada.
function cantidadDeAzulesEn_(celda){
      /*Proposito: modelar una cantidad de azules en la "celda".
      Precondicion: ninguna.
      Parametro: 
        celda: Celdas, representa la celda a evaluar las bolitas azules.
      Tipo: Numero.
    */
    return(cantidadDeAzules(celda) )
}
c.cantidadTotalDeBolitasEn_, que describe la cantidad total de bolitas
de los 4 colores de la celda dada.
function cantidadTotalDeBolitasEn_(celda){
     /*Proposito: modelar una cantidad total de bolitas en  "celda".
      Precondicion: ninguna.
      Tipo: Numero.
    */
    return( cantidadDeAzules(celda) +
            cantidadDeVerdes(celda) +
            cantidadDeRojos(celda) + 
            cantidadDeNegros(celda) 
          )
}
d.tiene_MásBolitasQue_, que dadas dos celdas, indica si la primera tiene más bolitas que la segunda.
function tiene_MasBolitasQue_(celda1, celda2){
    /*Proposito: indica si  la "celda1" tiene mas bolitas que la "celda2".
    Precondicion: ninguna.
    Parametros:
        *celda1: Celda, describe la primer celda comparar.
        *celda2: Celda, describe la segunda celda comparar.
    Tipo: Booleano.
    */
    return( cantidadTotalDeBolitasEn_(celda1)
            >
            cantidadTotalDeBolitasEn_(celda2)
            )
}
4. Declarar un tipo de registros llamado Cuenta que contenga el número de cuenta, el
tipo de cuenta (modelado por TipoDeCuenta), el nombre del cliente (representado
como un String), un tipo de moneda (modelado por Moneda) y un saldo
(representado como un número de centavos). Implementar las siguientes funciones:

type Cuenta is record {
    /*
        Proposito: Modelar una cuenta.
        INV Rep: 
            "nombre" no es vacio.
            "saldo" es mayor o igual a cero.
    */
    field numeroDeCuenta // Numero
    field tipoDeCuenta // TipiDeCuenta
    field nombreDelCliente // String 
    field tipoDeMoneda // Moneda
    field saldo // Numero 

}
type TipoDeCuenta is variant {
/* PROPÓSITO: modelar los diferentes tipos de cuenta que
ofrece el banco
*/
case CuentaCorriente {}
case CajaDeAhorro {}
case CuentaSueldo {}
}
type Moneda is variant {
/* PROPÓSITO: modelar los diferentes tipos de moneda con los
que trabaja el banco
*/
case Pesos {}
case Dolares {}
case Euros {}
case Reales {}
}

a.cuenta_ConSaldoActualizadoA_, que dada una cuenta y un nuevo
saldo describa la cuenta con el saldo actualizado.
function cuenta_ConSaldoActualizadoA_(cuenta, nuevoSaldo){
    /*
        Proposito: que dada una"cuenta" bancaria y un "nuevoSaldo" describe la cuenta con el saldo actualizado al dado.
        Precondicion: el saldo debe ser un numero positivo.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a actualizar
        *nuevoSaldo: Numero, representa el nuevo saldo a actualizar.
        Tipo: Cuenta.
    */
    
}
b.cuenta_ConTipoDeCuentaCambiadoA_, que dada una cuenta y un nuevo
tipo de cuenta bancaria describa la cuenta con el tipo cambiado al dado.
function cuenta_ConTipoDeCuentaCambiadoA_(cuenta, nuevoTipoDeCuenta){


c.Por disposición bancaria todas las cuentas bancarias de tipo Sueldo cuyo
saldo supera los $25.000 deben cambiar su tipo de cuenta bancaria a Caja
de Ahorro.
Implementar cuenta_ConTipoCambiadoSegúnDisposición, que dada
una cuenta bancaria describe la cuenta con el tipo que corresponda a cada
caso.
function cuenta_ConTipoCambiadoSegunDisposicion(cuenta){
/*
        Proposito: que dada una"cuenta" bancaria describe la cuenta con el tipo que corresponda a cada caso.
        Precondicion: ninguna.????
        Parametros:
        *cuenta: Cuenta, representa la cuenta a actualizar
        Tipo: Cuenta.
        Observacion:todas las cuentas bancarias de tipo Sueldo cuyo saldo supera los $25.000 deben cambiar 
                    su tipo de cuenta bancaria a Caja de Ahorro.
            
    */    

function nuevoTipoDeCuenta_SegunDisposicion(cuenta){  // AQUI AGRUPO A TIPO DE CUENTA:CAJA DE AHORRO A LAS QUE CUMPLEN CON LA CONDICION ANTERIOR SINO DEVUELVE EL TIPO DE CUENTA 
/* 
        Proposito: que dado un nuevo tipo de una"cuenta" bancaria describe el nuevo tipo de  cuenta segun la diposicion bancaria.
        Precondicion: ninguna.
        Parametros:
        *cuenta: TipoDeCuenta, representa la cuenta a actualizar
        Tipo: TipoDeCuenta.
        Observacion:todas las cuentas bancarias de tipo Sueldo cuyo saldo supera los $25.000 deben cambiar 
                    su tipo de cuenta bancaria a Caja de Ahorro.
            
    */    
    
}
function cumpleLaCondicion_(cuenta){  //AQUI CONDICIONO LAS CUENTAS QUE TIENE QUE SER MAYOR S 2500 Y TIENE QUE SER CAJA CUENTA SUELDO
    /*
        Proposito: indica si la cuenta  se cumple la diposicion bancaria  de su tipo de cuenta.
        Precondicion: ninguna.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        Tipo: Booleano.
        Observacion:todas las cuentas bancarias de tipo Sueldo cuyo saldo supera los $25.000 deben cambiar 
                    su tipo de cuenta bancaria a Caja de Ahorro.
            
    */
 
}

d.saldoEnPesosDe_, que dada una cuenta describe el saldo en pesos de la
misma. Asumir los valores cambiarios dados en la siguiente tabla .
function saldoEnPesosDe_(cuenta){
  /*
        Proposito:que dada una "cuenta" describe el saldo en pesos de la misma .
        Precondicion: ninguna.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        Tipo: Numero.    
    */  
 
e.númeroDeCuentaConMayorSaldoEntre_Y_, que dadas dos cuentas
bancarias describe el número de la cuenta que tiene mayor saldo entre
ambas. Tener en cuenta que las cuentas pueden estar expresadas en
diferentes monedas.
function numeroDeCuentaConMayorSaldoEntre_Y_(cuenta1, cuenta2){
      /*
        Proposito:que dada dos cuentas  "cuenta1" y "cuenta2"  describe el numero de la cuenta que tiene mayor saldo entre ambas.
        Precondicion: las cuenta deben ser expresadas en diferentes monedas.
        Parametros:
        *cuenta1: Cuenta, representa una de las cuenta a comparar.
        *cuenta2: Cuenta, representa una de las cuentas a comparar.
        Tipo: Cuenta.   
    */
   
}
f. cuenta_ActualizadaTrasExtracciónDeCajeroDe_, que dada una cuenta y un monto a
 extraer describa la cuenta con el saldo actualizado. ¿Es necesario establecer alguna una precondición?
function cuenta_ActualizadaTrasExtraccionDeCajeroDe_(cuenta, montoAExtraer){
       /*
        Proposito: que dada cuenta  "cuenta" y un "monto" a extraer  describe la cuenta con el saldo actualizado.
        Precondicion: el monto no debe ser mayor al saldo.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a actualizar.
        *monto: Numero, representa un monto a extraer.
        Tipo: Cuenta.   
    */
    return()
}

g.puedeExtraer_PorCajeroDeLaCuenta_, que dado un monto a extraer y
una cuenta indique si la extracción NO resultaría en un saldo negativo.
function puedeExtraer_PorCajeroDeLaCuenta_(montoAExtraer, cuenta){
      /*
        Proposito: que dado  un "monto" a extraer  y una "cuenta" indica si la extraccion No resultaria en un saldo negativo.
        Precondicion: el monto no debe ser mayor al saldo.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        *montoAExtraer: Numero, representa un monto a extraer.
        Tipo: Booleano.
    */

}

h.cuenta_ActualizadaTrasDepósitoEnCajeroDe_, que dada una
cuenta y un monto a depositar describa la cuenta con el saldo actualizado.
function cuenta_ActualizadaTrasDepositoEnCajeroDe_(cuenta, montoADepositar){
        /*
        Proposito: que dada una "cuenta" y un "montoADepositar" describa la cuenta con el saldo actualizado.
        Precondicion: ninguna.
        Parametros:
        *cuenta: Cuenta, representa la cuenta a analizar.
        *montoADepositar: Numero, representa un monto a depositar.
        Tipo: Cuenta.
    */

}
------GUIA LISTAS-----
1.Escribir la función cantidadesDeRojasEnFilaActual que describe una Lista de
números cuyos elementos son las cantidades de bolitas rojas en cada una de las celdas
de la fila actual, leídas desde el Oeste hasta el Este.
function cantidadesDeRojasEnFilaActual(){
    /*
        Proposito: describe una lista de numeros cuyos elementos son las cantidades de bolitas rojas en la fila actual.
        Leídas desde el Oeste hasta el Este.
        Precondicion: ninguna.
        Tipo: [Numero]
    */
    listaDeNumerosConBolitasRojas := []
    IrAlBorde(Oeste)
    while(puedeMover(Este)){
      listaDeNumerosConBolitasRojas := snoc(listaDeNumerosConBolitasRojas,nroBolitas(Rojo)) //procesar 
      Mover(Este)  // 
    }
    return(snoc( listaDeNumerosConBolitasRojas, nroBolitas(Rojo)) )    
}
2.Escribir la función cantidadDeRojasADistancia2DelBordeOesteDe_ que dada
una lista de números que representa las cantidades de bolitas rojas de una fila
cualquiera, describa la cantidad de bolitas rojas que había en la celda a distancia 2 del
borde Oeste de la fila dada al momento de su lectura. Por ejemplo, dada la lista del
ejemplo anterior, debería describir el número 5.
function cantidadDeRojasADistancia2DelBordeOesteDe_(listaDeNumeros){
    /*Proposito: dada una "lista", describe la cantidad de bolitas rojas que habia en la celda a distancia 2 del borde Oeste de la fila dada al momento de su lectura
     Leídas desde el Oeste hasta el Este.
     Parametro: 
        *listasDeNumeros: Lista de numeros
    Tipo: Numero.
    */
    return(primero(sinLosDosPrimeros(listasDeNumeros))) // funcion biblioteca diapo
}
program{
   return(cantidadDeRojasADistancia2DelBordeOesteDe_(cantidadesDeRojasEnFilaActual()))
    
}
3.Escribir las funciones dadas a continuación, que reciben como parámetros una lista de
números que representa las cantidades de bolitas rojas de una fila cualquiera:

a.las3PrimerasDe_ConLaMismaCantidad, que indica si las primeras 3 celdas
al Oeste de la fila representada tenían la misma cantidad de bolitas rojas al
momento en que la fila fue leída.
function las3PrimerasDe_ConLaMismaCantidad(lista){
    /*
        PROPÓSITO:  indica si las primeras 3 celdas al Oeste de la fila representada
                tenían la misma cantidad de bolitas rojas al momento en que la
                fila fue leída
        PRECONDICONES:
        *la lista dada debe contar con al menos 3 elementos
        PARÁMETROS:
        *lista: [Número]
        TIPO: Bool
    */
    return((primero(lista) == segundo(lista)) && (primero(lista) == tercero(lista)))
}
program{
    return(las3PrimerasDe_ConLaMismaCantidad(cantidadesDeRojasEnFilaActual()))
    
}
b.las3PrimerasDe_ConDistintasCantidades que indica si en las primeras 3
celdas al Oeste hay diferente cantidad de bolitas de rojas (es decir, son todas
distintas).
funcion las3PrimerasDe_ConDistintasCantidades(lista) {
    /*
    PROPOSITO: indica si en las primeras 3 celdas al Oeste hay diferente cantidad de bolitas de rojas
    PRECONDICONES: 
        *la lista dada debe contar con al menos 3 elementos
    PARAMETROS:
        *lista: [Numero]
    TIPO: Booleano
    */
    return(not las3PrimerasDe_ConLaMismaCantidad(lista))
    return((primero(lista) /= segundo(lista) && (primero(lista) /= tercero(listas))))
}
program{
    return(las3PrimerasDe_ConDistintasCantidad(cantidadesDeRojasEnFilaActual()))    
}
c.hayAlgunaCantidadIgualEnLas3PrimerasDe_ que determine si en algún
caso hay la misma cantidad de bolitas de dos colores (por ejemplo, la primera y
la tercera celda tienen la misma cantidad de bolitas rojas, o la segunda y la
tercera, etc.).
function hayAlgunaCantidadIgualEnLas3PrimerasDe_(lista){
    /*
        PROPÓSITO:Indica si en algún caso hay la misma cantidad de bolitas de dos colores
        PRECONDICONES:
        *La lista dada debe contener al menos 3 numeros.
        PARAMETROS:
        *lista: [Número ]
        TIPO: Booleano.
    */
    return(choose   True when (primero(lista) == segundo(lista))
                    True when (primero(lista) == tercero(lista))
                    True when (segundo(lista) == tercero(lista))
                    False otherwise)
}
function hayAlgunaCantidadIgualEnLas3PrimerasDe_V2(lista){ // esta es la mejor version.
    /*
        PROPÓSITO:Indica si en algún caso hay la misma cantidad de bolitas de dos colores
        PRECONDICONES:
        *La lista dada debe contener al menos 3 numeros.
        PARAMETROS:
        *lista: [Número ]
    T   IPO: Booleano.
    */
    return( (primero(lista) == segundo(lista))  ||
            (primero(lista) == tercero(lista))  ||
            (segundo(lista) == tercero(lista)))
}
4.Escribir la función direccionesAlBorde que retorne la lista de direcciones en las que
el cabezal no se puede mover. En el siguiente tablero direccionesAlBorde describe
la lista [Sur, Oeste], ya que el cabezal en este caso no puede moverse ni al Sur, ni
al Oeste.

a.¿Cómo puede utilizarse direccionesAlBorde para determinar si el tablero
tiene una única celda?
function direccionesAlBorde(){
      /*
    PROPÓSITO: retorna la lista de direcciones en las que el cabezal no se puede mover.
    PRECONDICONES: ninguna
    TIPO: [Direcciones]
    */
    direccionesAObservar := minDir()
    listaDeDireccionesQueNoPuedeMover := []  
    while(direccionesAObservar /= maxDir()){
        listaDeDireccionesQueNoPuedeMover := listaDeDireccionesQueNoPuedeMover ++ noPuedeMoverseEn_(direccionesAObservar)
        direccionesAObservar := siguiente(direccionesAObservar)
    }
    return(listaDeDireccionesQueNoPuedeMover ++ noPuedeMoverseEn_(direccionesAObservar))
}
function noPuedeMoverseEn_(direccion){
    return(choose [direccion] when (not puedeMover(direccion))
                    [] otherwise)
}
5. Escribir la función es_Singular, que dada una Lista de elementos de cualquier tipo,
indique si la lista tiene exactamente un único elemento.
SUGERENCIA: pensar en combinación con qué otras operaciones puede aprovecharse
la expresión primitiva esVacía.
function es_Singular(listaDeElementos){   
    /*  Proposito: dada una "lista" de elementos de cualquier tipo, indique si la lista tiene exactamente un único elemento.
        Precondicion: ninguna.
        Parametro.
            *listaDeElementos: Lista de elementos
        Tipo: Booleano.
    */
    return(not esVacía(listaDeElementos) && esVacía(resto(listaDeElementos)))
}
6.Escribir las siguientes funciones que suponen dada una lista de Direcciones que
expresa una ruta. Tener en cuenta que el siguiente tramo de la ruta solamente se
compone de las primeras dos direcciones de la ruta si existen.

a.haySiguienteTramoEn_, función total que indique si la ruta tiene al menos un
tramo completo.
function haySiguienteTramoEn_(ruta){  // son solo las 2 primeras direcciones
    /*  Proposito: indica si la ruta tiene al menos un tramo completo.
        Precondicion: ninguna.
        Parametro:
        * ruta:Lista de Direcciones.
        Tipo: Booleano.
    */
    return(not esVacía(ruta) && y tengo que obtener las dos primeras direcciones creo???:|)

}
b.sigueUnaCurvaEn_, función total que indique si el tramo que sigue en la ruta
es una curva.
function sigueUnaCurvaEn_(ruta){
    /*  Proposito: indica si el tramo  que sigue en la "ruta" es una curva.
        Precondicion: ninguna.
        Parametro:
            *ruta: Lista de Direcciones.
        Tipo: Booleano.
    */
    return

}
c.sigueCurvaADerechaEn_, que, teniendo en cuenta que viene una curva,
indique si la curva que sigue en la ruta es hacia la derecha.
function sigueCurvaADerechaEn_(curva){
     /*  Proposito: teniendo en cuenta que viene una curva, indique si la curva que sigue en la ruta es hacia la derecha.
         Precondicion: ninguna.
         Parametro: 
            *curva: Lista de Direcciones
         Tipo: Booleano.
    */

}
d.sigueCurvaAIzquierdaEn_, que, teniendo en cuenta que viene una curva,
indique si la curva en la ruta es hacia la izquierda.
function sigueCurvaAIzquierdaEn_(curva){
      /*  Proposito: teniendo en cuenta que viene una curva, indique si la curva en la ruta es hacia la izquierda.
         Precondicion: ninguna.
         Parametro: 
            *curva: Lista de Direcciones.
         Tipo: Booleano.
    */

}
e.sigueRectaEn_, que indique si el tramo que sigue en la ruta es una recta.
function sigueRectaEn_(ruta){
       /*  Proposito: indique si el tramo que sigue en la ruta es una recta.
         Precondicion: ninguna.
         Parametro: 
            *ruta: Lista de Direcciones.
         Tipo: Booleano.
    */

}

9.Escribir las siguientes funciones que continúan utilizando listas de elementos de tipo
Carta. Si bien varias de las funciones están inspiradas en el juego del Truco, no es
necesario conocer las reglas para realizarlas. Solo debe saberse que las Figuras son las
cartas con números 10, 11 y 12, ya que se dibujan en las cartas reales utilizando las
figuras de una Sota (una especie de paje o escudero), un Caballo (usualmente con su
caballero) y un Rey; y además, que el valor de una carta es el número de la misma si no
es una figura, o cero si es una figura.

a.manoDe3CartasDe_, que dado un mazo, describa una mano de 3 cartas
tomadas del mismo
function manoDe3CartasDe_(mazo){
       /*  Proposito: dado un "mazo", describa una mano de 3 cartas tomadas del mismo.
           Precondicion: ninguna.
           Parametro: 
            *mazo: Lista de Carta, que representa un mazo de cartas Españolas.
           Tipo: [Carta]
    */
    return([ primero(mazo),
             segundo(mazo),
             tercero(mazo)])
}
b.tiene_Envido, que dada una mano de 3 cartas, indique si tiene exactamente 2
cartas del mismo Palo.
function tiene_Envido(manoDe3Cartas){
       /*  Proposito: dado un "manoDe3Cartas", indica si tiene exactamente 2 cartas del mismo Palo.
           Precondicion: ninguna.
           Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
           Tipo: Booleano.
        */
        return ( choose True when ( Palo(primero(manoDe3Cartas)) ==( Palo(segundo(manoDe3Catas))))
                        True when (Palo(primero(manoDe3Cartas)) == (Palo(tercero(manoDe3Cartas))))
                        True when (Palo(segundo(manoDe3Cartas)) == (Palo(tercero(manoDe3Cartas))))
                        False otherwise
               )
}
c.tiene_Flor, que dada una mano de 3 cartas, indique si las 3 cartas son del
mismo Palo.
function tiene_Flor(manoDe3Cartas){
     /*  Proposito: dado un "manoDe3Cartas", indica si las 3 cartas son del mismo Palo
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Booleano.
        */
        return( (Palo(primero(manoDe3Cartas)) == Palo(segundo(manoDe3Cartas))) == Palo(tercero(manoDe3Cartas)) )
}
d.puntajeDe_ParaFlor, que, dada una mano de 3 cartas, describe la suma de
los valores de las cartas más 30 en caso que tenga flor, o cero en caso contrario.
Recordar que el valor de las figuras es 0.
function puntajeDe_ParaFlor(manoDe3Cartas){
    /*  Proposito: dado un "manoDe3Cartas", describe la suma de los valores de las cartas más 30 en caso que tenga flor,
                    o cero en caso contrario.
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Numero.
        */
        return( choose puntajeDe_ConFlor(manoDe3Cartas) when tiene_Flor(manoDe3Cartas)
                       0 otherwise
              )
}
function puntajeDe_Flor(manoDe3Cartas){
    quiero hacer un recorriso de acumulacion de no figuras =)
    /*  Proposito:dada una "manoDe3Cartas" describir la suma de los valores de las cartas mas 30 en caso que no sean figuras
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Numero.
        Observacion: es un recorrido sobre cartas de acumulacion de  cartas no  figuras. ?????PUEDO MEJORAR NO??
        */
        cartaAObservar := [Numero(primero(manoDe3Cartas))]
        puntajeDeFlorVisto := []
        while (cartaAObservar /= Numero(tercero(manoDe3Cartas))){
            puntajeDeFlorVisto := puntajeDeFlorVisto ++ noEsFiguraLa_(manoDe3Cartas)
            cartaAObservar := [Numero(siguiente(manoDe3Cartas))] ???????
        }
        return( puntajeDeFlorVisto ++ noEsFiguraLa_(manoDe3Cartas) + 30)
}
function noEsFiguraLa_(manoDe3Cartas){
     /*  Proposito:dada una "manoDe3Cartas", describir la suma de los valores de las cartas mas 30 en caso que no sean figuras
        Precondicion: ninguna.
        Parametro: 
            *manode3Cartas: Lista de Carta, que representa una mano de 3 cartas ,tomadas de un mazo de cartas.
        Tipo: Numero.
    */
    return( choose Numero(primero(manoDe3Cartas)) when (Numero(primero(manoDe3Cartas)) =< 7 )
                   Numero(segundo(manoDe3Cartas)) when (Numero(segundo(manoDe3Cartas)) =< 7 )
                   Numero(tercero(manoDe3Cartas)) when (Numero(tercero(manoDe3Cartas)) =< 7 )
                                            0     otherwise
          )
}
e.puntajeDe_ParaEnvido, que, dada una mano de 3 cartas, describe cuánto se
suma para un envido. Este valor es: si tiene envido, la suma de los valores de
las cartas del mismo palo más 20; si tiene flor, la suma de las 2 cartas de mayor
valor más 20; y si no tiene ni envido ni flor, el valor de la carta de mayor valor.
Recordar que el valor de las figuras es 0.
--RECORRIDOS SOBRE LISTAS--------------------------------------
1.Construir el procedimiento PonerColores_EnLaCeldaActual, que dada una lista de
Colores, pone una bolita del color correspondiente por cada uno de los elementos de la misma.
Por ejemplo,
PonerColores_EnLaCeldaActual([Verde,Verde,Azul]) pone dos bolitas Verdes y una Azul en la celda actual.
procedure PonerColores_EnLaCeldaActual(listaDeColores){
    /*Proposito: dada una lista de Colores, pone una bolita del color correspondiente por cada uno de los
                 elementos de la misma en la celda actual.
      Precondicion: la celda debe estar vacia.
      Parametro: 
        *listaDeColores: [Color]
    */
    foreach color in listaDeColores{ // por  cada color de la lista 
        Poner(color)                 // va a poner un color en la celda.
    }
}
2. Construir el procedimiento RecorrerCamino_, que dada una lista de Direcciones
mueve el cabezal en la dirección indicada por cada elemento, en orden. Por ejemplo,
RecorrerCamino_([Este, Este, Norte, Este]) debe mover el cabezal primero
hacia el Este dos veces, luego hacia el Norte 1 vez y por último se mueve hacia el Este.
¿Cuál es la precondición de este procedimiento?
procedure RecorrerCamino_(listaDeDirecciones){
       /*Proposito:  dada una lista de Direcciones mueve el cabezal en la dirección indicada por cada elemento, en orden.
         Precondicion: debe haber al menos celdas lindantes  en direccion hacia "listaDeDirecciones".
                        debe ser dado un camino valido en el tablero actual."Charly"
         Parametro: 
            *listaDeDirecciones: [Direccion]
    */
    caminoARecorrer := listaDeDirecciones
    while(not esVacía(listaDeDirecciones)){
        Mover(primero(listaDeDireccionesQueNoPuedeMover))
        caminoARecorrer := resto(listaDeDirecciones)
    }
    // otra opcion de resolucion 
    foreach direccion in listaDeDirecciones{
        Mover(listaDeDirecciones)
    }    
}

3.Construir la función aparicionesDeColor_, que dado un color, colorBuscado,
describa una lista de números que indican para cada una de las celdas del tablero
recorridas en dirección principal Norte y dirección secundaria Oeste, la cantidad de
bolitas del color buscado en esa celda del tablero. Por ejemplo, para el siguiente
tablero, aparicionesDeColor_(Rojo) debería describir la lista[4,0,3,1,0,2,10,7]:
function aparicionesDeColor_(colorBuscado){
       /*Proposito: describe una lista de números que indican para cada una de las celdas del tablero
                    recorridas en dirección principal Norte y dirección secundaria Oeste, la cantidad de bolitas del color 
                    buscado dado por "colorBuscado" en esa celda del tablero.
         Precondicion: ninguna.
         Parametro: 
            *colorBuscado: Color.
        Tipo: [Numero]
        Observacion : es un recorrido de acumulacion 
    */
    aparicionesDeColores := [nroBolitas(colorBuscado)]
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Oeste)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)
        aparicionesDeColores := aparicionesDeColores ++ [nroBolitas(colorBuscado)]
    }
    return(aparicionesDeColores)
}

4.Construir el procedimiento Poner_Bolitas_EnElTablero, que dada una lista de
números y un color, recorre el tablero con dirección principal Norte y dirección
secundaria Oeste y pone en cada celda la cantidad de bolitas del color dado, según el
elemento en la posición correspondiente. Si hubiera menos números que celdas, en las
celdas restantes no se pondrán bolitas, y si hubiera más números que celdas, se
ignoran los números sobrantes.
Por ejemplo
Poner_Bolitas_EnElTablero([4,0,3,1,0,2,10,7],Rojo), si se
ejecuta en un tablero inicial vacío de 4 columnas y 2 filas, produce el tablero de la figura
del ejercicio anterior.

5.Construir la función coloresEnLaCeldaActual, que describa la lista de los colores
que aparecen en la celda actual. ¿Cuál es el número mínimo de elementos que tendrá
esta lista? ¿Y el máximo?

6.Construir la función aparicionesDelColor_EnElCamino_, que dado un color,
colorBuscado,
y una lista de Direcciones, direccionesDelCamino, describa la
lista con la cantidad de bolitas del color dado en las celdas recorridas, si las mismas se
recorren en el orden en que indica el camino dado, incluyendo la celda en que se
encuentra el cabezal antes de empezar y al finalizar el recorrido. ¿Cuál es la
precondición del procedimiento?

7.Construir la función longitudDe_, que dada una lista cualquiera, describa la cantidad
de elementos de la misma.
Por ejemplo, longitudDe_([Azul,Azul,Verde,Rojo]) describe 4.
function longitudDe_(lista){
    /*  Proposito: describa la cantidad de elementos de la "lista" dada.
        Precondicion: ninguna.
        Parametro: 
            *lista: [Elemento]
        Tipo: Numero.
        Observacion: es un recorrido de acumulacion ????
    */
    cantidadDeElementos := 0
    foreach elemento in lista{
        cantidadDeElementos := cantidadDeElementos + 1 
    }
    return(cantidadDeElementos)     
}

8.Construir las funciones
a.sumatoriaDe_, que dada una lista de Números, describa la suma de todos los
elementos de la misma.
Porejemplo,
sumatoriaDe_([1,10,15,7,9]) describe el número 42, porque 1+10+15+7+9 es igual a 42;

b.productoriaDe_, que dada una lista de Números, describa el producto de
todos los elementos de la misma.
Por ejemplo, productoriaDe_([1,5,7,9]) describe el número 315, porque
1*5*7*9 es igual a 315.

c.cantidadDeBolitas_DelTablero, que dado un color, indique la cantidad
total de bolitas de ese color que hay en el tablero. ¿Puede hacerse reutilizando
código ya hecho?
AYUDA: pensar en combinar algunas de las funciones hechas en ejercicios
anteriores con alguna de las de este.

9.Construir las funciones
a.repetición_VecesDe_, que dado un número y un elemento de cualquier tipo,
describa una lista con la cantidad indicada de repeticiones del elemento dado. Si
el número es menor o igual que cero, retorna la lista vacía.
Por ejemplo, repetición_VecesDe_(3,8) describe la lista [8,8,8], mientras que
repetición_VecesDe_(5,Verde)describe la lista [Verde,Verde,Verde,Verde,Verde].
function repeticion_DeVeces_(numero, elemento){
    /*
        Prop: describe una,lista con la cantidad "numero" de repeticiones del elemento "elemento". Si es menor o igual 
              a cero devuelve una lista vacia.
        Precond: ninguna
        Param: 
            numero: Numero
            elemento: elemento
        Tipo: [Elemento]
    */
    listaDeElementos := []
    repeat(numero){
        listaDeElementos :=  listaDeElementos ++ elemento
    }
    return(listaDeElementos)
}

b. laLista_Clonada_Veces, que dados una lista de elementos y un número,
describa la lista resultante de clonar la lista dada tantas veces como se indica.
Por ejemplo,
laLista_Clonada_Veces([Rojo,Azul,Verde], 3) retorna [Rojo,Azul,Verde,Rojo,Azul,Verde,Rojo,Azul,Verde]
function laLista_Clonada_Veces(listaDeElementos, numero){
      /*
        Prop: describe la lista resultante de clonar la lista "listaDeElementos tantas veces como indica "numero".
        Precond: ninguna
        Param: 
            numero: Numero
            listaDeElemento: [Elemento]
        Tipo: [Elemento]
    */
    return(repeticion_DeVeces_(numero, listaDeElementos))
}


c.losElementosDe_Clonados_Veces, que dados una lista de elementos y un
número, describa la lista que contenga los elementos dados en el orden de dicha
lista, pero repetidos la cantidad de veces indicada.
Por ejemplo,
losElementosDe_Clonados_Veces([Rojo,Azul,Verde],3) retorna [Rojo,Rojo,Rojo,Azul,Azul,Azul,Verde,Verde,Verde].

d.La solución anterior, ¿fue construida reutilizando repetición_VecesDe_? Si
no es así, resolverla nuevamente utilizando esa función.

10. Construir la función reversoDe_, que dada una lista, describa la lista que tiene los
mismos elementos que la dada, pero en orden reverso.
Por ejemplo,
reversoDe_([Negro,Azul,Azul,Verde,Rojo])
describe [Rojo,Verde,Azul,Azul,Negro].

11. Construir las funciones
a.direccionesOpuestasDe_, que dada una lista de direcciones, describa la
lista de direcciones en donde cada elemento es el opuesto al de la posición
original.
Por ejemplo,
direccionesOpuestasDe_([Oeste,Sur,Norte]) describe [Este,Norte,Sur].

b. siguientesDe_, que dada una lista de colores, describa la lista de colores en
donde cada elemento es el siguiente del original.
Por ejemplo,
siguientesDe_([Rojo,Azul,Verde,Azul,Azul]) describe [Verde,Negro,Azul,Negro,Negro].

12. Construir la función lista_HomologadaPorDebajoDe_A_, que dada una lista de
números, y dos números umbral y default, describa una lista de números que está
basada en la lista dada de la siguiente manera: aquellos números de la lista dada que
son mayores o iguales al umbral, permanecen igual, pero aquellos que son menores,
son reemplazados por el valor default.
Por ejemplo, lista_HomologadaPorDebajoDe_A_([3,7,8,5,1,3,2,4], 4, 2)
describe [2,7,8,5,2,2,2,4].
13. Construir las funciones
a.númerosParesDe_, que dada una lista de Números, describa
la lista de números pares que aparecen en la misma.
Por ejemplo, númerosParesDe_([3,4,5,2,5]) describe [4,2].

b. laLista_SinElElemento_, que dados una lista y un elemento, describa la
lista que resulta de quitar todas las apariciones del elemento dado que ocurren
en lista dada. ¿De qué tipo debe ser elemento?
Porejemplo,
laLista_SinElElemento_([Azul,Verde,Azul,Rojo], Azul) describe [Verde,Rojo].

14. Construir la función contiene_A_, que dada una lista y un elemento, indica si el
elemento está en la lista.
Por ejemplo, contiene_A_([21,3,42], 3) indica que es verdadero que la lista
contiene a 3, mientras que contiene([21,3,42], 5) indica que es falso que la lista contiene a 5.

15. Construir la función sinDuplicados_, que dada una lista, describa una lista que tenga
todos los elementos de la lista dada, pero donde no aparecen elementos repetidos,
pues las repeticiones que aparecen luego de la primera fueron eliminadas.
Por ejemplo,
sinDuplicados_([1,3,4,2,4,3,5]) describe a la lista [1,3,4,2,5]. Observar que no es lo mismo describir a la lista [1,2,4,3,5], que
podría ser un resultado válido, pero no es el solicitado (porque no se conservó el primero de cada uno).

16. Construir las funciones
a. intersecciónDe_Con_, que dadas dos listas que no contienen elementos
repetidos, describe la lista de todos los elementos que aparecen en ambas.
Por ejemplo:
intersecciónDe_Con_([1,3,4], [2,4,3,5]) describe [3,4].

b. uniónDe_Con_, que dadas dos listas que no contienen elementos repetidos,
describe una lista sin repetidos que contenga todos los elementos que aparecen
en alguna de las 2 listas.
Por ejemplo, uniónDe_Con_([1,3,4],[2,4,3,5]) describe [1,3,4,2,5].
¿De qué tipo es la primera lista? ¿Y la segunda? ¿Pueden ser de tipos diferentes?

17. Construir la función algunoDe_Entre_Y_, que, dada una lista de Números y dos
números desde y hasta, indica si la lista contiene algún elemento que se encuentre
entre los números desde y hasta, sin incluirlos. Es decir, si algún elemento k de la lista,
cumple desde < k < hasta.
Por ejemplo, algunoDe_Entre_Y_([7,3,1,25,16], 13, 18) indica que es verdadero que hay un
elemento entre 13 y 18 (el 16), mientras que algunoDe_Entre_Y_([7,3,1,25,16], 13, 16) indica que es falso que haya
algún elemento entre 13 y 16 (el 16 no es menor que 16).
¿La solución propuesta requirió el uso de variables que recuerdan valores booleanos?
Si fue así, considerar ofrecer una solución que NO utilice variables booleanas.
18. Construir la función lista_estáIncluidaEn_ que dadas 2 listas que no contienen
elementos repetidos, describe si la primer lista se encuentra contenida en la segunda
lista (o sea, todos los elementos de la primera aparecen en la segunda).
Por ejemplo,
las expresiones lista_estáIncluidaEn_([4,5],[5,3,4,6]) y lista_estáIncluidaEn_([4,5],[2,3,4,6,5])
indican que es verdadero que está incluida, mientras que lista_estáIncluidaEn_([4,5,8],[4,3,5,6]) indica
que es falso que esté incluida.

19. Construir la función estáOrdenada_ que, dada una lista de Números indica si está
ordenada de menor a mayor. Para que una lista esté ordenada, cada elemento debe ser
menor o igual al que le sigue.
Por ejemplo, la expresión estáOrdenada_([2,7,9,15]) indica verdadero, mientras
que la expresión estáOrdenada_([2,15,9,7]) indica falso.
¿La solución propuesta requirió el uso de variables que recuerdan valores diferentes a
la lista que todavía falta recorrer? Si fue así, considerar ofrecer una solución que NO
utilice variables además de la que se utiliza para recordar la lista a recorrer.

20. Construir la función posiciónDe_enLaQueAparece_ que dada una lista y un
elemento, describe la posición de la lista en la que aparece ese elemento por primera
vez. Se define la posición de un elemento como un número que representa la cantidad
de veces que debe usarse la función sinElPrimero para acceder a ese elemento.
¿Cuál es la precondición de la función? ¿Por qué no tendría sentido que esta función
sea total?
Por ejemplo, posiciónDe_enLaQueAparece_([4,8,15,16,42],8) describe al número 1, porque solo
se usa una vez sinElPrimero (para quitar el 4), posiciónDe_enLaQueAparece_([4,8,15,16,42],16)
describe 3, porque se deben usar 3 veces la función (para quitar el 4, el 8 y el 15), y
posiciónDe_enLaQueAparece_([4,8,15,16,23,42],4) describe 0, porque no hace falta usar sinElPrimero.

21. Construir la función sinLaPrimeraApariciónDe_en_ que dado un elemento y una
lista, describe la lista que se obtiene de eliminar una única vez el elemento, si es que
este aparece en la lista.
Por ejemplo, sinLaPrimeraApariciónDe_en_(8,[4,8,42,15,8,42]) describe [4,42,15,8,42] y
sinLaPrimerApariciónDe_en_(42,[4,8,42,15,8,42]) describe [4,8,15,8,42].

22. Construir las siguientes funciones:
a. mínimoElementoDe_, que dada una lista de Números, describe el elemento
más chico que se encuentra en la lista. ¿Cuál es la precondición de la función?
Por ejemplo, mínimoElementoDe_([13,21,3,9,45,3,7]) describe 3.

b. sinElMínimoElemento_, que dada una lista de Números, describe la lista que
se obtiene de eliminar una única vez el elemento más chico. ¿Cuál es la
precondición de la función?
Por ejemplo, sinElMínimoElemento_([13,21,3,9,45,3,7]) describe [13,21,9,45,3,7].

c. lista_ordenada, que dada una lista de Números, describe la lista con los
mismos elementos que la dada, pero ordenada de menor a mayor. ¿Se puede
elaborar una estrategia combinando los ejercicios anteriores?
Por ejemplo, lista_ordenada([13,21,3,9,45,17,8,3,7])
describe [3,3,7,8,9,13,17,21,45].

d. ¿Puede hacerse la función anterior con alguna otra estrategia diferente a esa,
que no sea simplemente utilizar la variante de funciones del ejercicio siguiente…? 
Este tema es un tema amplio que se tratará en detalle en la materia Estructuras de Datos.

23. Construir las siguientes funciones. ¿Cuáles son las precondiciones de estas funciones?

a. máximoElementoDe_, que dada una lista de Números, describe el elemento
más grande que se encuentra en la lista.
Por ejemplo, máximoElementoDe_([13,21,3,9,45,3,7]) describe 45.

b. sinElMáximoElemento_, que dada una lista de Números, describe la lista que
se obtiene de eliminar una única vez el elemento más grande.
Por ejemplo,
sinElMáximoElemento_([13,21,3,9,45,3,7]) describe [13,21,3,9,3,7].

24. Construir la función segmentoInicialDeLargo_de_ que, dado un número que
representa a una cantidad y una lista de cualquier tipo, describe la lista que se obtiene
de quedarse únicamente con esa cantidad de elementos de la lista comenzando por el
primero (sus primeros elementos), o todos, si no hay suficientes. ¿Cuál es la
precondición de esta función? ¿Qué nombre te parece adecuado en este caso para el
parámetro de tipo número? ¿Para qué tipos de lista funciona tu solución?
Por ejemplo, segmentoInicialDeLargo_de_(4,[4,8,15,16,99,42]) describe
[4,8,15,16], mientras que segmentoInicialDeLargo_de_(2,[4,8,15,42]) describe [4,8] y
segmentoInicialDeLargo_de_(7,[4,8,15,42]) describe [4,8,15,42].

25. Construir la función lista_AgrupadosDeA_, que dadas una lista de elementos
cualesquiera y un número que representa a una cantidad, describe la lista de listas que
agrupa los elementos de la lista dada en grupos, donde cada grupo tiene exactamente
la cantidad de elementos indicada, excepto el último grupo, que puede tener menos
elementos.
Por ejemplo, lista_AgrupadosDeA_([1,2,3,4,5,6,7,8,9,10,11],3) describe
a la lista [[1,2,3],[4,5,6],[7,8,9],[10,11]]. Observar que la la lista original
tiene 11 elementos, mientras que la lista resultante tiene 4.
Para realizarla, considerar utilizar la función del ejercicio anterior al pensar una
estrategia. ¿Qué otra subtarea haría falta para completar dicha estrategia?

26. Construir la función lista_Desagrupada, que dada una lista de listas, describe una
lista que contiene cada uno de los elementos de las listas internas de la lista dada.
Por ejemplo, lista_Desagrupada([[1,2,3],[4,5,6],[7,8,9]]) describe la
lista [1,2,3,4,5,6,7,8,9]. Observar que la lista argumento tiene 3 elementos,
mientras que la lista resultado tiene 9.

27. Construir la función laLista_SinLosPrimeros_, que dados una lista de elementos
de cualquier tipo y un número que representa a una cantidad, describe la lista que se
obtiene de quedarse con todos los elementos excepto el segmento inicial del largo
dado.
Por ejemplo, laLista_SinLosPrimeros_([4,8,15,23,42],4) describe [42],
laLista_SinLosPrimeros_([4,8,16,23,9,42],4) describe [9,42], y la
expresión laLista_SinLosPrimeros_([4,8,15,16,23,42],8) describe [].
ATENCIÓN:
según qué estrategia se haya utilizado al escribir la función lista_AgrupadosDeA_, 
es posible que ya se haya resuelto este ejercicio como
subtarea de aquél (quizás con otro nombre). En ese caso, ¿sería necesario volverlo a
escribir? ¿Puede reutilizarse lo hecho con anterioridad?

28. Construir la función sinInternos_, que dada una lista de Números, describa la lista
que se obtiene de quitar todos los elementos internos. Un elemento de una lista se dice
interno si es igual al anterior de la lista.
Por ejemplo, sinInternos_([1,1,2,2,2,3,1,2,2]) describe [1,2,3,1,2].
